---
title: Java的基本程序设计结构
tags:
- Java
- Java核心技术卷1读书笔记
categories: 编程
---
-> 源代码的文件名必须与**公共类**的名字相同。

## 数据类型

在Java中共有8种基本类型，其中有4种整型，2种浮点类型，1种表示Unicode编码字符类型的char，1种表示真值的boolean类型。

### 整型

整型用于表示没有小数部分的数值， 它允许是负数。Java 提供了 4 种整型。

| 类型  | 存储需求 | 取值范围                                            |
| ----- | -------- | --------------------------------------------------- |
| int   | 4字节    | -2 147 483 648 - 2 147483647 (正好超过 20亿)        |
| short | 2字节    | -32768 - 32767                                      |
| long  | 8字节    | -9 223372 036 854 775 B08 - 9 223372 036854 775 807 |
| byte  | 1字节    | -128-127                                            |

在 Java 中， 整型的范围与运行 Java代码的机器无关。

长整型数值有一个后缀 L 或 1 (如 4000000000L)。十六进制数值有一个前缀 0x 或 0X (如 0xCAFE 八进制有一个前缀 0, 例如， 010 对应八进制中的 8。很显然， 八进制表示法比较 容易混淆， 所以建议最好不要使用八进制常数。

 从 Java7 开始， 加上前缀 0b 或 0B 就可以写二进制数。例如，0b1001就是 9。另外，同样是 从 Java7开始，还可以为数字字面量加下划线，如用 1_000_000(或者0b1111_0100_0010_0100_0000) 表示一百万。这些下划线只是为丫让人更易读。Java 编译器会去除这些下划线。

### 浮点类型

| 类型   | 存储需求 | 取值范围                                             |
| ------ | -------- | ---------------------------------------------------- |
| float  | 4字节    | 大约 ± 3.402 82347E+38F (有效位数为 6 ~ 7 位）       |
| double | 8字节    | 大约 ± 1.797693 134862315 70E+308 (有效位数为 15 位> |

float类型的数值有一个后缀 F 或 f (例如，3.14F)。没有后缀 F 的浮点数值（如 3.14 ) 默 认为double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。 

所有的浮点数值计算都遵循 IEEE 754规范。具体来说，下面是用于表示溢出和出错情况 的三个特殊的浮点数值： 

•正无穷大   常量 Double_POSITIVE_INFINITY

•负无穷大   常量 Double.NEGATIVE_INFINITY 

•NaN (不是一个数字）常量 Double.NaN 

一 正整数除以 0 的结果为正无穷大。计算 0/0 或者负数的平方根结果为 NaN。 

如果想检测一个特定值x是否等于 Double.NaN，请使用`Double.isNaN(x)`,不要使用`x==Double.NaN`

### char类型

char 类型原本用于表示单个字符。不过，现在情况已经有所变化。 如今，有些 Unicode 字符可以用一个 char值描述，另外一些 Unicode 字符则需要两个char 值。

####　Unicode中的坑

**Unicode 转义序列会在解析代码之前得到处理。** 例如，"\u0022+\u0022”并不是一 个由引号（U+0022) 包围加号构成的字符串。 实际上， \u0022 会在解析之前转换为""+""， 这会得到也就是一个空串。 

更隐秘地， **一定要当心注释中的 \u**。注释 // \u00A0 is a newline 会产生一个语法错误， 因为读程序时 \u00A0 会替换为一个换行符类似地， 下面这 个注释 // Look inside c:\users 也会产生一个语法错误， 因为 \u 后面并未跟着 4 个十六进制数。

#### 码点与代码单元

在设计 Java 时决定采用 16 位的 Unicode 字符集。

**码点（code point)：** 是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中， 码点采用十六进制书写，并加上前缀 U+, 例如 U+0041 就是拉丁字母 A 的码点。

Unicode 的 码点可以分成 17 个代码级别（code plane)。第一个代码级别称为基本的多语言级别（basic multilingual plane), 码点从 U+0000 到 U+FFFF, 其中包括经典的 Unicode 代码；其余的 16 个级别码点从 U+10000 到 U+10FFFF, 其中包括一些辅助字符（supplementary character)。 

**代码单元（code unit)：**在基本的多语言级别中，每个字符用 16 位表示，通常被称为代码单元（code unit）; 而辅助字符采用一对连续的代码单元 进行编码。这样构成的编码值落人基本的多语言级别中空闲的 2048字节内， 通常被称为替 代区域（surrogate area) [ U+D800 ~ U+DBFF 用于第一个代码单元，U+DC00 ~ U+DFFF 用 于第二个代码单元]。

**char代表一个代码单元，不代表一个码点，一个码点可能由两个代码单元组成。**

### boolean 类型

boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间 不能进行相互转换。

## 变量

变量名必须是一个以字母开头并由字母或数字构成的序列。需要注意，与大多数程序设 计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括’A’ ~ ’Z’、 ’a‘ ~ ’z’、 或在某种语言中表示字母的任何 Unicode 字符。

尽管 $ 是一个合法的 Java 字符， 但不要在你自己的代码中使用这个字符。它只用 在 Java 编译器或其他工具生成的名字中。 

1) 局部变量初始化（局部变量：函数、语句中的变量，只在所属区域内有效） 局部变量声明后，Java虚拟机不会自动给它初始化为默认值。 因此对于局部变量，必须经过显示的初始化，才能使用它。 如果使用一个没有被初始化的局部变量，编译器会报错。

2) 对于类的成员变量，不管程序有没有显示的初始化，Java虚拟机都会先自动给它初始化为默认值。

3)对于数组，数组引用类型的变量的默认值为null。当数组变量实例化后，如果没有显式地为每个元素赋值，Java会把该数组的所有元素初始化为相应类型的默认值。

C 和C++ 区分变量的声明与定义。

例如： int i = 10; 是一个定义。 定义：给i分配了空间。

而 extern int i; 是一个声明，外部变量。声明：只是有这个变量（可能在该文件之外），但是没有给其分配空间。

在 Java 中， 不区分变量的声明与定义。 （因为java没有外部变量）

## 常量

在 Java中， 利用关键字 final指示常量。关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上, 常量名使用全大写。

`final double CM_PER_INCH = 2.54; `

## 运算符

### strictfp

可移植性是 Java 语言的设计目标之一 ， 无论在哪个虚拟机上运行，同一运算应该 得到同样的结果3 对于浮点数的算术运算， 实现这样的可移植性是相当困难的。double 类型使用 64 位存储一个数值， 而有些处理器使用 80 位浮点寄存器这些寄存器增加了 中间过程的计算精度. 例如， 以下运算：

 double w = x * y / z; 

很多Intel处理器计算 x * y，并且将结果存储在 80 位的寄存器中， 再除以 z 并将结 果截断为 64 位„ 这样可以得到一个更加精确的计算结果， 并且还能够避免产生指数溢出但是，这个结果可能与始终在 64 位机器上计算的结果不一样。 因此，Java 虚拟机 的最初规范规定所有的中间计算都必须进行截断这种行为遭到了数值计算团体的反对。 截断计算不仅可能导致溢出， 而且由于截断操作需要消耗时间， 所以在计算速度上实际 上要比精确计算慢。 为此，Java 程序设计语言承认了最优性能与理想结果之间存在的冲 突，并给予了改进。在默认情况下， 虚拟机设计者允许对中间计算结果采用扩展的精度。 

但是， 对于使用 strictfp 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。
例如，可以把 main 方法标记为 

`public static strictfp void main(String[] args)` 

于是， 在 main 方法中的所有指令都将使用严格的浮点计算。如果将一个类标记为 strictfp, 这个类中的所有方法都要使用严格的浮点计算。 

实际的计算方式将取决于 Intel 处理器的行为。在默认情况下，中间结果允许使用扩展 的指数， 但不允许使用扩展的尾数（Intel 芯片在截断尾数时并不损失性能） 。**因此，这两种 方式的区别仅仅在于采用默认的方式不会产生溢出， 而采用严格的计算有可能产生溢出。** 

如果没有仔细阅读这个注释， 也没有什么关系。对大多数程序来说， 浮点溢出不属 于大向题。

### 数值类型之间的转换 

在下图中有 6 个实心箭头，表示无信息丢失的转换；有 3 个虚箭头， 表示可能有精度损失的转换。 

![type_casting](https://github.com/Misakasister/misakasister.github.io/blob/master/images/java_core_technonlgy_1/base_program/type_casting.png?raw=true)

例如，123 456 789 是一个大整数， 它所包含的位数比 float 类型所能够表达的位数多。 当将这个整型数值转换为 float 类型时，将会得到同样大小的结果，但却失去了一定 的精度。 

int n = 123456789;

 float f= n;//f is 1.23456792E8 

当使用上面两个数值进行二元操作时（例如 n + f，n 是整数，f 是浮点数)， 先要将两个操作数转换为同一种类型，然后再进行计算。 

•如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 

•否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 

•否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 

•**否则， 两个操作数都将被转换为 int 类型。** 

```java
byte b1 = 11;
byte b2 = 12;
byte b3 = 0;
b3=b1+b2;//错误，两个操作数会被转换成int类型
b3=(byte)(b1+b2);//正确，int需要强制类型转换
```

### 强制类型转换

在必要的时候， int类型的值将会自动地转换为 double 类型。但另 一方面，有时也需要将 double转换成 int。 在 Java中， 允许进行这种数值之间的类型转换。 当然， 有可能会丢失一些信息。

例如： 

double x * 9.997; 

int nx = (int) x; 

这样， 变量 nx 的值为 9。强制类型转换通过截断小数部分将浮点值转换为整型。 

可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如， X += 4; 等价于： x = x + 4; 

如果运算符得到一个值， **其类型与左侧操作数的类型不同， 就会发生强制类型转换**。 例如，如果 x 是一个 int, 则以下语句 x += 3.5; 是合法的， 将把 X 设置为（int)(x+ 3.5)。 

## 字符串

从概念上讲， Java 字符串就是 Unicode 字符序列。 例如， 串“ Java\u2122” 由 5 个 Unicode 字符 J、a、v、a 和™。Java 没有内置的字符串类型， 而是在标准 Java类库中提供了 一个预定义类，很自然地叫做 String。

与绝大多数的程序设计语言一样，Java语言允许使用 + 号连接（拼接）两个字符串。 

当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。

### 不可变字符串

String greeting = "Hello"; 

String类没有提供用于修改字符串的方法6 如果希望将 greeting 的内容修改为“ Help!”， 不能直接地将 greeting的最后两个位置的字符修改为 ‘ p’ 和 ‘ ！ 、这对于 C 程序员来说，将会感到无从下手 。如何修改这个字符串呢？ 

在 Java中实现这项操作非常容易。首先提取需 要的字符， 然后再拼接上替换的字符串： 

greeting = greeting.substring(0, 3) + "p!"; 

上面这条语句将 greeting 当前值修改为“ Help !”。 

由于不能修改 Java 字符串中的字符， 所以在 Java 文档中将 String类对象称为不可变字 符串， 如同数字 3 永远是数字 3—样，字符串“ Hello” 永远包含字符 H、 e、1、1 和 o 的代 码单元序列， 而不能修改其中的任何一个字符。

当然， 可以修改字符串变量 greeting，让它 引用另外一个字符串， 这就如同可以将存放 3 的数值变量改成存放 4一样。

为了弄清具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量 指向存储池中相应的位置。如果复制一个字符串变量， 原始字符串与复制的字符串共享相同 的字符。 

### 字符串是否相等

可以使用 equals方法检测两个字符串是否相等。

对于表达式： 

s.equals(t) 

如果字符串 s 与字符串 t 相等， 则返回 true ; 否则， 返回 false。

一定不要使用 == 运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串是否放置在同一个位置上。当然， 如果字符串放置在同一个位置上， 它们必然相等。但是， 完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。 

如果虚拟机始终将相同的字符串共享， 就可以使用==运算符检测是否相等。但实际上 只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。因此，千万不 要使甩 == 运算符测试字符串的相等性， 以免在程序中出现糟糕的 bug。

### 码点与代码单元 

length（） 方法将返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。不是码点数量，所以有可能一个字符的length()值是2。

要想得到实际的长度，即码点数量，可以调用：

`int cpCount = greeting.codePointCount(0, greeting.length());` 

如果想要遍历一个字符串，并且依次査看每一个码点， 可以使用下列语句：


```java
 int cp = sentence.codePointAt(i); 
if (Character.isSupplementaryCodePoint(cp)) i += 2; else i++; 
```

可以使用下列语句实现回退操作： 

```java
i-- ； 
if (CharacterssSurrogate(sentence.charAt(i))) i-- ; 
int cp = sentence.codePointAt(i);
```

显然， 这很麻烦。更容易的办法是使用 codePoints 方法， 它会生成一个 int 值的“ 流”， 每个 int 值对应一个码点。（流将在卷 II 的第 2 章中讨论〉 可以将它转换为一个数组，再完成遍历。 
`intD codePoints = str.codePoints（）.toArray（）;`
反之，要把一个码点数组转换为一个字符串， 可以使用构造函数。
`String str = new String(codePoints, 0, codePoints.length);`

## 输入与输出

### 格式化输出

可以使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出： String message = String.format("Hello, %s. Next year, you'll be %d", name, age);

 ![format](https://github.com/Misakasister/misakasister.github.io/blob/master/images/java_core_technonlgy_1/base_program/print_format.png?raw=true)

### 文件输入输出

要想对文件进行读取，就需要一个用 File 对象构造一个 Scanner 对象，如下所示： 

`Scanner in = new Scanner(Paths.get("niyflle.txt"), "UTF-8"); `

如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠： `“ c:\\mydirectory\\myfile.txt” ` 

现在，就可以利用任何一个 Scanner方法对文件进行读取。 



要想写入文件， 就需要构造一个 PrintWriter 对象。在构造器中，只需要提供文件名： 

PrintWriter out = new PrintWriter("myfile.txt", "UTF-8"); 

如果文件不存在，创建该文件。可以像输出到 System.out—样使用 print、 println 以及 printf 命令。 

```java
public class FileFormat {
private static PrintWriter pw;
private static Scanner sc;
public static void main(String[] args) throws IOException {
	pw = new PrintWriter("src/test.txt");
	pw.println("321");
	pw.close();//不关闭就读文件会报错
	sc = new Scanner(Paths.get("src/test.txt"));
	String str = sc.next();
	System.out.println(str);//321
	sc.close();
}
}
```

## 数组

在声明数组变量时， 需要指出数组类型 （数据元素类型紧跟 []) 和数组变量的名字。下面声明了整型数组 a: 

int[] a; 

不过， 这条语句只声明了变量 a， 并没有将 a 初始化为一个真正的数组。应该使用 new 运算 符创建数组。 

int[ ] a = new int[100];

这条语句创建了一个可以存储 100 个整数的数组。数组长度不要求是常量： newint[n] 会创建 一个长度为 n 的数组。 

###  for each 循环 

这种增强的 for 循环的语句格式为：

 for (variable : collection) statement

定义一个变量用于暂存集合中的每一个元素， 并执行相应的语句（当然，也可以是语句块)。 collection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象（例如 ArrayList)。

### 数组初始化以及匿名数组

在 Java中，提供了一种创建数组对象并同时赋予初始值的简化书写形式。下面是一 例子：

 int[] smallPrimes = { 2, 3, 5, 7, 11, 13 };

请注意， 在使用这种语句时，不需要调用 new。 甚至还可以初始化一个匿名的数组： 

new int[] { 17, 19, 23, 29, 31, 37}

 这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的 个数。使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。例如： 

smallPrimes = new int[] { 17, 19, 23, 29, 31, 37};

### 命令行参数

每一个 Java应用程序都有一个带 String arg[]参数的 main方法。这个参数表明 main方法将接收一个字符串数组， 也就是命令行参数

如果使用下面这种形式运行这个程序： 

java Message -g cruel world
args 数组将包含下列内容: 

args[0]:"-g" 

args[1] :"cruel"

args[2]:"world"

### 不规则数组

Java 实际上没有多维数组，只有一维数组。多维数组被解释为“ 数组的数组。

由于可以单独地存取数组的某一行， 所以可以让两行交换。 

```java
double[] temp = balances[i];
balances[i] = balances[i + 1 ]; 
balances[i + 1 ] = temp;
```

可以方便地构造一个“ 不规则” 数组， 即数组的每一行有不同的长度。

int[][] odds = new int\[MAX + 1 ][];

 接下来， 分配这些行。 

for (int n = 0; n <= MAX; n++) 

odds[n] = new int[n + 1];

## 高精度运算

如果基本的整数和浮点数精度不能够满足需求， 那么可以使用jaVa.math 包中的两个 很有用的类：Biglnteger 和 BigDecimal 这两个类可以处理包含任意长度数字序列的数值。 Biglnteger类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。 

使用静态的 valueOf方法可以将普通的数值转换为大数值： `Biglnteger a = Biglnteger.valueOf(100);`

 遗憾的是，不能使用人们熟悉的算术运算符（如：+ 和 *) 处理大数值。 而需要使用大数 值类中的 add 和 multiply 方法。 Biglnteger c = a.add(b); // c = a + b 

Biglnteger d = c.nultipiy(b.add(Biglnteger.valueOf(2))); // d = c * (b + 2)