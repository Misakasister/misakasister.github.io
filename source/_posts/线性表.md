---
title: 线性表
tags:
- C语言
- 数据结构
categories: 编程
---

线性表（sequence list）是最基本、最简单、也是最常用的一种数据结构。

## 定义

```txt
ADT List{
    数据对象：D={$a_i$|ai∈ElemSet,i=1,2,3...n>=0}\\n是表长，为0时为空表
	数据关系：R1={<ai-1,ai>|ai-1,ai∈D,i=1,2,3....n}
	常用基本操作：
	
	初始化操作：
	InitList(&L) 
	无--构造一个空线性表L
	
	引用型操作：	
	ListEmpty(L)
	线性表L已存在--判断L是否为空表
	
	ListLength(L)
	线性表L已存在--返回L中数据的个数
	
	GetElem(L,i,&e)
	线性表L已存在,0<=i<=ListLength(L)--用e返回第i个元素的值
	
	LocateElem(L,e，compare())
	线性表L已存在,compare()时数据元素判定函数--返回L中第一个与e满足compare()关系的位序，若不存在返回0.
	
	加工型操作：
	ListInsert(&L,i,e)
	线性表L已存在,0<=i<=ListLength(L)+1--在L中第i个位置插入新的元素e,L的长度加1
	ListDelte(&L,i,&e)
	线性表L已存在,0<=i<=ListLength(L)--删除L中的第i个元素，用e返回其值，L的长度减1.
```

线性表（顺序结构）的存储结构

```c
#define List_Init_Size 100//线性表存储空间的初始分配量（也就是最多能存多少个的值，实际用时不一定会超过这个值，超过了就要报错或者增加最长值）
#define ListIncrement 10 //线性表存储空间的分配增量（其实就是初始有几个值）
typedef struct{
    Element *elem;//存储空间的基地址（相当于数组名）
    int length; //当前长度
    int listSize;//当前分配的存储容量（以sizeof(ElemeType)为单位）（就相当于数组的角标）
}SqList;

//因此也可以这样定义
typedef struct{
    Element date[100];
    int length;
}
```

线性表（链式结构--单向链表）的存储结构

```c
typedef struct LNode{
    ElemType data;
    struct Lnode *next;
}LNode,*LinkList;
//LinkList 专门用来设置头节点，LinkList head == LNode *head
```

## 习题

### 顺序表应用1：多余元素删除之移位算法

Time Limit: 1000 ms Memory Limit: 650 KiB

Problem Description

一个长度不超过10000数据的顺序表，可能存在着一些值相同的“多余”数据元素（类型为整型），编写一个程序将“多余”的数据元素从顺序表中删除，使该表由一个“非纯表”（值相同的元素在表中可能有多个）变成一个“纯表”（值相同的元素在表中只保留第一个）。
要求：
       1、必须先定义线性表的结构与操作函数，在主函数中借助该定义与操作函数调用实现问题功能；
       2、本题的目标是熟悉顺序表的移位算法，因此题目必须要用元素的移位实现删除；

nput

 第一行输入整数n，代表下面有n行输入；
之后输入n行，每行先输入整数m，之后输入m个数据，代表对应顺序表的每个元素。

Output

 输出有n行，为每个顺序表删除多余元素后的结果

Sample Input

```
4
5 6 9 6 8 9
3 5 5 5
5 9 8 7 6 5
10 1 2 3 4 5 5 4 2 1 3
```

Sample Output

```
6 9 8
5
9 8 7 6 5
1 2 3 4 5
```

Hint

Source

主要考察数组的删除 （ListDelte），数组删除某个元素，要把其后的元素往前移动一位，要求a\[i]=a\[i+1]

思路：先固定住a[i]，从a[i+1]到a[length-1]分别与a[i]比较，相同的话，返回其角标，交给删除函数进行删除，**然后指针前移一位**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct{
    int data[10001];
    int length;
}SqList;

void CreateSql(SqList *a,int n);
void ShowSql(SqList *a);
void DelSql(SqList *a, int i);
int SearchSql(SqList *a, int j);
int main()
{
    int n, m, i, j, q, f=-1;
    SqList a;
    scanf("%d", &n);
    for(i=0;i<n;i++){
        scanf("%d", &m);
        CreateSql(&a,m);
        for(j=0;j<a.length;j++){
            for(q=j+1;q<a.length;q++){
                f=SearchSql(&a,j);
                if(f==-1){
                   break;
                }
                else{
                    DelSql(&a,f);
                    q--;//注意这个q--的用法，删除完不前置q,就会把a[q]位置的元素漏掉
                }
            }
        }
        ShowSql(&a);
        a.length=0;
    }
    return 0;
}

//创建线性表
void CreateSql(SqList *a,int n){
    int i;
    for(i=0;i<n;i++){
        scanf("%d", &a->data[i]);
    }
    a->length=n;
}

//删除第j个元素
void DelSql(SqList *a, int i){
    int j;
    for(j=i;j<a->length-1;j++){
        a->data[j]=a->data[j+1];
    }
    a->length--;
}

//查询J位置后的重复元素
int SearchSql(SqList *a, int j){
    int i;
    for(i=j+1;i<a->length;i++){
        if(a->data[i]==a->data[j]){
            return i;
        }
    }
        return -1;
}

//输出线性表
void ShowSql (SqList *a){
    int i;
    for(i=0;i<a->length;i++){
        printf("%d%c", a->data[i], i==a->length-1?'\n':' ');
    }
}
```

值得注意的是，这里在函数里对线性表操作，必须把地址给传进去，单纯的结构体名不是地址，只代表一个变量。

### 顺序表应用2：多余元素删除之建表算法

Time Limit: 3 ms Memory Limit: 600 KiB

Problem Description

一个长度不超过10000数据的顺序表，可能存在着一些值相同的“多余”数据元素（类型为整型），编写一个程序将“多余”的数据元素从顺序表中删除，使该表由一个“非纯表”（值相同的元素在表中可能有多个）变成一个“纯表”（值相同的元素在表中只保留第一个）。
要求：
       1、必须先定义线性表的结构与操作函数，在主函数中借助该定义与操作函数调用实现问题功能；
       2、本题的目标是熟悉在顺序表原表空间基础上建新表的算法，要在原顺序表空间的基础上完成完成删除，建表过程不得开辟新的表空间；
       3、不得采用原表元素移位删除的方式。

Input

 第一行输入整数n，代表下面有n行输入；
之后输入n行，每行先输入整数m，之后输入m个数据，代表对应顺序表的每个元素。

Output

  输出有n行，为每个顺序表删除多余元素后的结果

Sample Input

```
4
5 6 9 6 8 9
3 5 5 5
5 9 8 7 6 5
10 1 2 3 4 5 5 4 2 1 3
```

Sample Output

```
6 9 8
5
9 8 7 6 5
1 2 3 4 5
```

Hint

 Source

注意到此题限时非常短，而顺序表的删除与增加元素，要移动很多元素，非常的消耗时间，因此应该采用的是非顺序结构域（链表）存储数据

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct Lnode{
    int data;
    struct Lnode *next;
}Lnode,*LinkList;

LinkList InitList(int n);//构造长度为n的线性表
void ListDelete(LinkList q,LinkList p);
void LocateElem(LinkList head, int k, LinkList p);
void ShowLnode(LinkList head);

int main()
{
    int n,m;
    LinkList head, p;
    scanf("%d", &m);
    while(m--){
        scanf("%d", &n);
        head=InitList(n);
        p=head->next;
        while(p!=NULL){
            LocateElem(head,p->data,p);
            p=p->next;//不要忘了往后移动
        }
        ShowLnode(head);
    }
    return 0;
}

//尾叉法建立链表
LinkList InitList(int n){
    LinkList head, p, tail;
    int m;
    head=(LinkList)malloc(sizeof(Lnode));
    head->next=NULL;
    tail=head;
    while(n--){
        p=(LinkList)malloc(sizeof(Lnode));
        scanf("%d", &m);
        p->next=tail->next;
        tail->next=p;
        tail=p;
        p->data=m;
    }
    return head;
}


//遍历链表并删除
void LocateElem(LinkList head, int k,LinkList p){
        LinkList  q,m;
        m=p;
        q=p;
        p=p->next;
        while(p!=NULL){
            if(p->data==k){
                 q->next=p->next;
    			 free(p);
    			 p=q->next;
            }
            else{
                q=p;
                p=p->next;
            }
        }
        p=m;
    }

//展示链表
void ShowLnode(LinkList head){
    LinkList p;
    p=head->next;
    while(p!=NULL){
        if(p->next==NULL){
            printf("%d\n", p->data);
        }
        else{
            printf("%d ",p->data);
        }
        p=p->next;
    }
}
```

 这道题我在函数传参数时犯了一个错误，记录在https://misakasister.github.io/2018/10/06/C%E8%AF%AD%E8%A8%80%20%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E7%90%86%E8%A7%A3/

### 顺序表应用3：元素位置互换之移位算法

Time Limit: 1000 ms Memory Limit: 570 KiB

Problem Description

一个长度为len(1<=len<=1000000)的顺序表，数据元素的类型为整型，将该表分成两半，前一半有m个元素，后一半有len-m个元素（1<=m<=len)，借助元素移位的方式，设计一个空间复杂度为O(1)的算法，改变原来的顺序表，把顺序表中原来在前的m个元素放到表的后段，后len-m个元素放到表的前段。
注意：先将顺序表元素调整为符合要求的内容后，再做输出，输出过程只能用一个循环语句实现，不能分成两个部分。

Input

 第一行输入整数n，代表下面有n行输入；
之后输入n行，每行先输入整数len与整数m(分别代表本表的元素总数与前半表的元素个数），之后输入len个整数，代表对应顺序表的每个元素。

Output

 输出有n行，为每个顺序表前m个元素与后（len-m）个元素交换后的结果

Sample Input

```
2
10 3 1 2 3 4 5 6 7 8 9 10
5 3 10 30 20 50 80
```

Sample Output

```
4 5 6 7 8 9 10 1 2 3
50 80 10 30 20
```

Hint

注意：先将顺序表元素调整为符合要求的内容后，再做输出，输出过程只能在一次循环中完成，不能分成两个部分输出。



思路：空间复杂度O(1)要求不能新开数组，因此把先第一个元素放最后，然后数组前移，把第一个元素覆盖，重复m次,就把m个元素放到最后了

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data[10001];
    int length;
}SqList;

SqList list;

void createList(int n){
    int i;
    for(i=0;i<n;i++){
        scanf("%d", &list.data[i]);
    }
    list.length=n;
}
void tranList(SqList *list,int m){
    //保存第一个数，然后让其他元素向前移动一位
    //再把第一个数放到末尾，就完成了，执行m次
    int i, j;
    while(m--){
        j=list->data[0];
        for(i=0;i<list->length-1;i++){
            list->data[i]=list->data[i+1];
        }
        list->data[list->length-1]=j;
    }
}
void ShowList(SqList *list){
        int i;
        for(i=0;i<list->length;i++){
            printf("%d%c", list->data[i],i==list->length-1?'\n':' ');
        }
}
int main()
{
    int n, m, p;
    scanf("%d", &n);
    while(n--){
        scanf("%d", &m);
        scanf("%d", &p);
        createList(m);
        tranList(&list, p);
        ShowList(&list);
    }
    return 0;
}

```

### 顺序表应用4-2：元素位置互换之逆置算法(数据改进）

Time Limit: 80 ms Memory Limit: 600 KiB

Problem Description

一个长度为len(1<=len<=1000000)的顺序表，数据元素的类型为整型，将该表分成两半，前一半有m个元素，后一半有len-m个元素（1<=m<=len)，设计一个时间复杂度为O(N)、空间复杂度为O(1)的算法，改变原来的顺序表，把顺序表中原来在前的m个元素放到表的后段，后len-m个元素放到表的前段。
注意：交换操作会有多次，每次交换都是在上次交换完成后的顺序表中进行。

Input

第一行输入整数len(1<=len<=1000000)，表示顺序表元素的总数；

第二行输入len个整数，作为表里依次存放的数据元素；

第三行输入整数t(1<=t<=30)，表示之后要完成t次交换，每次均是在上次交换完成后的顺序表基础上实现新的交换；

之后t行，每行输入一个整数m(1<=m<=len)，代表本次交换要以上次交换完成后的顺序表为基础，实现前m个元素与后len-m个元素的交换；

Output

输出一共t行，每行依次输出本次交换完成后顺序表里所有元素。

Sample Input

```
10
1 2 3 4 5 6 7 8 9 -1
3
2
3
5
```

Sample Output

```
3 4 5 6 7 8 9 -1 1 2
6 7 8 9 -1 1 2 3 4 5
1 2 3 4 5 6 7 8 9 -1
```

Hint

Source

思路：整体逆置的思想，比如样例：

```text
1 2 3 4 5 6 7 8 9 -1 将前2个移动到最后
-1 9 8 7 6 5 4 3 2 1 整体逆置
9 -1 8 7 6 5 4 3 2 1 前2个逆置
9 -1 1 2 3 4 5 6 7 8 剩下的逆置
```

因此要定义一个逆置数组的函数res，res具体就是遍历数组的一半，与另外一半进行交换

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct{
    int data[10000001];
    int length;
}SqList;

SqList list;

void createList(int n){
    int i;
    for(i=0;i<n;i++){
        scanf("%d", &list.data[i]);
    }
    list.length=n;
}
//逆置数组
void res(int l, int r){
    int i, j, t;
    j=r;
    for(i=l;i<=(l+r)/2;i++){
        t=list.data[i];
        list.data[i]=list.data[j];
        list.data[j]=t;
        j--;
    }
}

void show(){
    int i;
    for(i=0;i<list.length;i++){
        printf("%d%c", list.data[i], i==list.length-1?'\n':' ');
    }
}
int main()
{
    int l, t, m;
    scanf("%d", &l);
    createList(l);
    scanf("%d", &t);
    while(t--){
        scanf("%d", &m);
        res(0,list.length-1);
        res(list.length-m,list.length-1);
        res(0,list.length-m-1);
        show();
    }
    return 0;
}
```

### 顺序表应用5：有序顺序表归并

Time Limit: 100 ms Memory Limit: 880 KiB

Problem Description

已知顺序表A与B是两个有序的顺序表，其中存放的数据元素皆为普通整型，将A与B表归并为C表，要求C表包含了A、B表里所有元素，并且C表仍然保持有序。

Input

 输入分为三行：
第一行输入m、n（1<=m,n<=10000）的值，即为表A、B的元素个数；
第二行输入m个有序的整数，即为表A的每一个元素；
第三行输入n个有序的整数，即为表B的每一个元素；

Output

 输出为一行，即将表A、B合并为表C后，依次输出表C所存放的元素。

Sample Input

```
5 3
1 3 5 6 9
2 4 10
```

Sample Output

```
1 2 3 4 5 6 9 10
```

Hint

Source

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data;
    struct node *next;
}Lnode, *LinkList;

LinkList createLnode(int n){
    Lnode *head, *p, *t;
    head=(LinkList)malloc(sizeof(Lnode));
    head->next=NULL;
    t=head;
    while(n--){
        p=(LinkList)malloc(sizeof(Lnode));
        scanf("%d", &p->data);
        p->next=NULL;
        t->next=p;
        t=p;
    }
    return head;
}

//归并链表
 LinkList merge(LinkList l1, LinkList l2){
     LinkList p, q, t;
     p=l1->next;
     q=l2->next;
     t=l1;
     free(l2);
     while(p!=NULL&&q!=NULL){
        if(p->data<q->data){
            t->next=p;
            t=p;
            p=p->next;//不要忘了往下移动
            t->next=NULL;
        }
        else{
            t->next=q;
            t=q;
            q=q->next;
            t->next=NULL;
        }
     }
     if(p==NULL){
        t->next=q;
     }else{
        t->next=p;
     }
     return l1;
 }

 void show(LinkList head){
    LinkList p;
    p=head->next;
    while(p!=NULL){
        printf("%d%c", p->data, p->next==NULL?'\n':' ');
        p=p->next;
    }
 }
int main()
{
    int n, m;
    LinkList h1, h2;
    scanf("%d %d", &n, &m);
    h1=createLnode(n);
    h2=createLnode(m);
    h1=merge(h1,h2);
    show(h1);
    return 0;
}
```

### 顺序表应用6：有序顺序表查询

Time Limit: 1000 ms Memory Limit: 4096 KiB

Problem Description

顺序表内按照由小到大的次序存放着n个互不相同的整数，任意输入一个整数，判断该整数在顺序表中是否存在。如果在顺序表中存在该整数，输出其在表中的序号；否则输出“No Found!"。

Input

 第一行输入整数n (1 <= n <= 100000)，表示顺序表的元素个数；
第二行依次输入n个各不相同的有序非负整数，代表表里的元素；
第三行输入整数t (1 <= t <= 100000)，代表要查询的次数；
第四行依次输入t个非负整数，代表每次要查询的数值。

保证所有输入的数都在 int 范围内。

Output

 输出t行，代表t次查询的结果，如果找到在本行输出该元素在表中的位置，否则本行输出No Found!

Sample Input

```
10
1 22 33 55 63 70 74 79 80 87
4
55 10 2 87
```

Sample Output

```
4
No Found!
No Found!
10
```

Hint

Source

思路：二分查找（不可能考遍历寻找的。。。。。

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct {
    int data[100001];
    int length;
}SqList;

void initList(SqList *list,int n){
    int i;
    for(i=0;i<n;i++){
        scanf("%d", &list->data[i]);
    }
    list->length=n;
}
//二分查找
int midsearch(SqList *list, int k, int l, int r ){
    int mid;
    mid=(l+r)/2;
    //相等的情况也能查找,所以不要写等于号
    if(l>r){
        return -1;
    }
    else if(k==list->data[mid]){
       return mid;
    }
    else if(k<list->data[mid]){
        return midsearch(list,k,0,mid-1);
    }
    else {
        return midsearch(list,k,mid+1,r);
    }
}
int main()
{
    SqList list;
    int n, t, k, m;
    scanf("%d", &n);
    initList(&list,n);
    scanf("%d", &t);
    while(t--){
        scanf("%d", &k);
        m=midsearch(&list, k,0,(list.length)-1);
        if(m!=-1){
            printf("%d", m+1);
        }else{
        printf("No Found!");
        }
        printf("\n");
    }
    return 0;
}
```

### 顺序表应用7：最大子段和之分治递归法

Time Limit: 10 ms Memory Limit: 400 KiB

Problem Description

 给定n(1<=n<=50000)个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。**当所给的整数均为负数时定义子段和为0**，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]},1<=i<=j<=n。 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2)时，最大子段和为20。 

**注意：**本题目要求用分治递归法求解，除了需要输出最大子段和的值之外，还需要输出求得该结果所需的递归调用总次数。

递归调用总次数的获得，可以参考以下求菲波那切数列的代码段中全局变量count的用法：

```c
#include
int count=0;
int main()
{
    int n,m;
    int fib(int n);
    scanf("%d",&n);
    m=fib(n);
    printf("%d %d\n",m,count);
    return 0;
}
int fib(int n)
{
    int s;
    count++;
    if((n==1)||(n==0)) return 1;
    else s=fib(n-1)+fib(n-2);
    return s;
}
```

Input

第一行输入整数n(1<=n<=50000)，表示整数序列中的数据元素个数；

第二行依次输入n个整数，对应顺序表中存放的每个数据元素值。

Output

一行输出两个整数，之间以空格间隔输出：

第一个整数为所求的最大子段和；

第二个整数为用分治递归法求解最大子段和时，递归函数被调用的总次数。

Sample Input

```
6
-2 11 -4 13 -5 -2
```

Sample Output

```
20 11
```

Hint

Source

思路：

**子段与子序列不一样**

子段的定义：(a[i],a[i+1],…+a[j]) 是连续的, 相当于连续的子序列

子序列：一个序列(a1, a2, ..., aN)，子序列(ai1, ai2, ..., aiK)，这里1<= i1 < i2 < ... < iK <= N。不一定是连续的

样例找的是a[2],a[3],a\[4\] (从1开始数) 三个数的和为20。

网上搜到了一个视频，但需要翻墙才能看。。

<video src="https://d3c33hcgiwev3.cloudfront.net/045%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C.9d429c70da9811e4be004bedc55dc744/full/720p/index.webm?Expires=1538956800&Signature=f35N0QyYFQMvDvvb55AEwU9NiVg3SOqXz710f9ojO1YnV9STezCiSL8xs1M5R~3rod3c0pvVOe~IGGFbXj4mcjb7R51PP5afAPmltR7yauo1zdjm6nUSqM-WSB~Y8o2d76muY1pbUC1tUlJfd2K5K-LoGBv4gKls~PsYm13OblE_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A"></video>

分治法的思路就是，将序列分为左右两半，中间点为mid

递归计算左边的最大和lsum和右边的最大和rsum

那么整个序列的最大子段可能在左边lsum（i和j都在左边）,或者右边rsum(i和j都在右边)，或者是i在左边，j在右边，而前两种情况是递归计算出来的，第三种情况需要算一下，左半边的最大值，即从a[mid]开始往左边一直加到a\[0](如果是第三种情况，那么a[mid]一定在序列中\),用一个lmax记录加的过程中的最大值，同理也要计算右半边的最大值，从a[mid+1]加到a[length-1] ，用rmax记录累加过程中的最大值，那么第三种情况最大和就是lmax+rmax，之后再与lsum，rsum中取一个最大的即可

递归的结束条件就是l==r 只有一个元素的时候，需要注意的是如果为负值要返回0

```txt
                lmax    rmax
             <-------|------->
<------------------->|<------------------->
       lsum                   rsum
a[0]...........a[mid]|a[mid+1].............a[length-1]
```

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int data[50001];
    int length;
}Sqlist;

int count=0;

void createSqlist(Sqlist *list,int n);
int sub(Sqlist *list, int l, int r);
int main()
{
    Sqlist list;
    int n, k;
    scanf("%d", &n);
    createSqlist(&list,n);
    k=sub(&list,0,(list.length)-1);
    printf("%d %d\n", k, count);
    return 0;
}

void createSqlist(Sqlist *list,int n){
    int i;
    for(i=0;i<n;i++){
        scanf("%d", &list->data[i]);
    }
    list->length=n;
}

int sub(Sqlist *list, int l, int r){
    int sum, lmax, rmax, lsum, rsum, i, mid;
    count++;
    if(l==r){
        return list->data[l]>0?list->data[l]:0;
    }
    mid=(l+r)/2;
    lsum=sub(list,l,mid);
    rsum=sub(list,mid+1,r);
    //i和j不在同一个区间
    sum=0;
    lmax=0;//记录左边包含a[mid]的最大和
    for(i=mid;i>=l;i--){
      sum+=list->data[i];
      if(sum>=lmax){
        lmax=sum;
      }
    }
    sum=0;
    rmax=0;//记录右边包含a[mid+1]的最大和
    for(i=mid+1;i<=r;i++){
        sum+=list->data[i];
        if(sum>=rmax){
            rmax=sum;
        }
    }
    sum=rmax+lmax;
    if(lsum>sum){
        sum=lsum;
    }
    //这里不能使用elseif
    if(rsum>sum){
        sum=rsum;
    }
    return sum;
}
```

这里还犯了一个很低级的错误，那就是if与else if混用，以前没注意过233333

`if...if 都要进行判断 if...else if 第一个判断成功就不判读第二个`

https://zhidao.baidu.com/question/541324936.html

### 顺序表应用8：最大子段和之动态规划法

Time Limit: 5 ms Memory Limit: 500 KiB

Problem Description

 给定n(1<=n<=100000)个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为[负数](http://baike.baidu.com/view/71543.htm)时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]},1<=i<=j<=n。 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2)时，最大子段和为20。

 

注意：本题目要求用动态规划法求解，只需要输出最大子段和的值。

Input

第一行输入整数n(1<=n<=100000)，表示整数序列中的数据元素个数；

第二行依次输入n个整数，对应顺序表中存放的每个数据元素值。

Output

输出所求的最大子段和

 

Sample Input

```
6
-2 11 -4 13 -5 -2
```

Sample Output

```
20
```

Hint

Source

思路：动态规划法：

子问题的划分:

C[i-1]对应截止到a[i-1] 的最大子段和，那么C[i]的最大子段和就是

如果C[i-1]+a[i]>C[i],（就是C[i-1]>0)，C[i]=C[i-1]+a[i]

如果C[i-1]+a[i]<C[i],(就是C[i-1]<0),C[i]=a[i]

然后我们找到的最大的C[i]就行了（有点像最长上升子序列，但是这是子串，必须连续，子序列不一定连续）

这题开两个数组会超内存，注意到我们只需要C[i]和C[i-1]，因此用两个变量存一下就行了

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct{
    int data[100001];
    int length;
}Sqlist;

 void createSqlist(Sqlist *list,int n);

int main()
{
    Sqlist list;
    int n, before, after, max, i;
    scanf("%d", &n);
    createSqlist(&list, n);
    max=0;
    before=list.data[0];
    for(i=1;i<list.length;i++){
        if(before>0){
            after=before+list.data[i];
        }else{
            after=list.data[i];
        }
        if(after>max){
            max=after;
        }
        before=after;
    }
    printf("%d\n", max>0?max:0);//小于0的时候输出0
    return 0;
}

void createSqlist(Sqlist *list,int n){
    int i;
    for(i=0;i<n;i++){
        scanf("%d", &list->data[i]);
    }
    list->length=n;
}

```

### 数据结构实验之链表一：顺序建立链表

Time Limit: 1000 ms Memory Limit: 65536 KiB

Problem Description

输入N个整数，按照输入的顺序建立单链表存储，并遍历所建立的单链表，输出这些数据。

Input

第一行输入整数的个数N；
第二行依次输入每个整数。

Output

输出这组整数。

Sample Input

```
8
12 56 4 6 55 15 33 62
```

Sample Output

```
12 56 4 6 55 15 33 62
```

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data;
    struct node *next;
}Lnode, *Linklist;

Linklist create(int n);
void show(Linklist head);

int main()
{
    Linklist head;
    int n;
    scanf("%d", &n);
    head=create(n);
    show(head);
    return 0;
}

Linklist create(int n){
    Linklist p, head;
    head=(Linklist)malloc(sizeof(Lnode));
    head->next=NULL;
    while(n--){
        p=(Linklist)malloc(sizeof(Lnode));
        scanf("%d", &p->data);
        p->next=head->next;
        head->next=p;
    }
    return head;
}

void show(Linklist head){
    Linklist p;
    p=head->next;
    while(p!=NULL){
        printf("%d%c", p->data,p->next==NULL?'\n':' ');
        p=p->next;
    }
}
```

### 数据结构实验之链表二：逆序建立链表

Time Limit: 1000 ms Memory Limit: 65536 KiB

Problem Description

输入整数个数N，再输入N个整数，按照这些整数输入的相反顺序建立单链表，并依次遍历输出单链表的数据。

Input

第一行输入整数N;；
第二行依次输入N个整数，逆序建立单链表。

Output

依次输出单链表所存放的数据。

Sample Input

```
10
11 3 5 27 9 12 43 16 84 22 
```

Sample Output

```
22 84 16 43 12 9 27 5 3 11 
```

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data;
    struct node *next;
}Lnode, *Linklist;

Linklist create(int n);
void show(Linklist head);

int main()
{
    Linklist head;
    int n;
    scanf("%d", &n);
    head=create(n);
    show(head);
    return 0;
}

Linklist create(int n){
    Linklist p, head, t;
    head=(Linklist)malloc(sizeof(Lnode));
    head->next=NULL;
    t=head;
    while(n--){
        p=(Linklist)malloc(sizeof(Lnode));
        scanf("%d", &p->data);
        p->next=t->next;
        t->next=p;
        t=p;
    }
    return head;
}

void show(Linklist head){
    Linklist p;
    p=head->next;
    while(p!=NULL){
        printf("%d%c", p->data,p->next==NULL?'\n':' ');
        p=p->next;
    }
}
```

### 数据结构实验之链表三：链表的逆置

Time Limit: 1000 ms Memory Limit: 65536 KiB

Problem Description

输入多个整数，以-1作为结束标志，顺序建立一个带头结点的单链表，之后对该单链表的数据进行逆置，并输出逆置后的单链表数据。

Input

输入多个整数，以-1作为结束标志。

Output

输出逆置后的单链表数据。

Sample Input

```
12 56 4 6 55 15 33 62 -1
```

Sample Output

```
62 33 15 55 6 4 56 12
```

Hint

不得使用数组。

---

就是逆序建立链表，不过元素不用输入，而是从原来的链表里拿

---

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data;
    struct node *next;
}Lnode, *Linklist;
Linklist create();
void res(Linklist head);
void show(Linklist head);
int main()
{
    Linklist head;
    head=create();
    res(head);
    show(head);
    return 0;
}

Linklist create(){
    int n;
    Linklist head, p, t;
    head=(Linklist)malloc(sizeof(Lnode));
    head->next=NULL;
    t=head;
    while(1){
        scanf("%d", &n);
        if(n==-1){
            break;
        }
        p=(Linklist)malloc(sizeof(Lnode));
        p->data=n;
        p->next=t->next;
        t->next=p;
        t=p;
    }
    return head;
}

void res(Linklist head){
    Linklist p, q;
    p=head->next;
    q=p->next;//需要一个q防止断了，让p插在头指针后还能在找到原链表
    head->next=NULL;
    while(p!=NULL){
        p->next=head->next;
        head->next=p;
        p=q;
        //注意这个判断条件，不是单纯的反向建立链表
        if(q!=NULL){//后置指针为空的时候，不能在往后了
            q=p->next;
            //NULL没有next值
        }
    }
}

void show(Linklist head){
    Linklist p;
    p=head->next;
    while(p!=NULL){
        printf("%d%c", p->data,p->next==NULL?'\n':' ');
        p=p->next;
    }
}
```

### 数据结构实验之链表四：有序链表的归并

Time Limit: 1000 ms Memory Limit: 65536 KiB

Problem Description

分别输入两个有序的整数序列（分别包含M和N个数据），建立两个有序的单链表，将这两个有序单链表合并成为一个大的有序单链表，并依次输出合并后的单链表数据。

Input

第一行输入M与N的值； 
第二行依次输入M个有序的整数；
第三行依次输入N个有序的整数。

Output

输出合并后的单链表所包含的M+N个有序的整数。

Sample Input

```
6 5
1 23 26 45 66 99
14 21 28 50 100
```

Sample Output

```
1 14 21 23 26 28 45 50 66 99 100
```

Hint

不得使用数组！

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data;
    struct node *next;
}Lnode, *Linklist;

Linklist create(int n);
void merge(Linklist h1,Linklist h2);
void show(Linklist head);

int main()
{
    int n, m;
    Linklist h1, h2;
    scanf("%d %d", &n, &m);
    h1=create(n);
    h2=create(m);
    merge(h1,h2);
    show(h1);
    return 0;
}

Linklist create(int n){
    Linklist head, p, t;
    head=(Linklist)malloc(sizeof(Lnode));
    head->next=NULL;
    t=head;
    while(n--){
        p=(Linklist)malloc(sizeof(Lnode));
        scanf("%d", &p->data);
        p->next=t->next;
        t->next=p;
        t=p;
    }
    return head;
}

void merge(Linklist h1,Linklist h2){
    Linklist p1, p2, t;
    p1=h1->next;
    p2=h2->next;
    t=h1;
    h1->next=NULL;
    free(h2);
    while(p1!=NULL&&p2!=NULL){
        if(p1->data>p2->data){
            t->next=p2;
            t=p2;
            p2=p2->next;//记得下移
            t->next=NULL;//记得断开
        }else{
            t->next=p1;
            t=p1;
            p1=p1->next;
            t->next=NULL;
        }
    }
    if(p1==NULL){
        t->next=p2;
    }
    if(p2==NULL){
        t->next=p1;
    }
}
void show(Linklist head){
    Linklist p;
    p=head->next;
    while(p!=NULL){
        printf("%d%c", p->data,p->next==NULL?'\n':' ');
        p=p->next;
    }
}
```

### 数据结构实验之链表五：单链表的拆分

Time Limit: 1000 ms Memory Limit: 65536 KiB

Problem Description

输入N个整数顺序建立一个单链表，将该单链表拆分成两个子链表，第一个子链表存放了所有的偶数，第二个子链表存放了所有的奇数。两个子链表中数据的相对次序与原链表一致。

Input

第一行输入整数N;；
第二行依次输入N个整数。

Output

第一行分别输出偶数链表与奇数链表的元素个数； 
第二行依次输出偶数子链表的所有数据；
第三行依次输出奇数子链表的所有数据。

Sample Input

```
10
1 3 22 8 15 999 9 44 6 1001
```

Sample Output

```
4 6
22 8 44 6 
1 3 15 999 9 1001
```

Hint

不得使用数组！

Source

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data;
    struct node *next;
}Lnode, *Linklist;

Linklist create(int n);
void split(Linklist head);
void show(Linklist head);

int main()
{
    Linklist head;
    int n;
    scanf("%d", &n);
    head=create(n);
    split(head);
    return 0;
}

Linklist create(int n){
     Linklist head, p, t;
     head =(Linklist)malloc(sizeof(Lnode));
     head->next=NULL;
     t=head;
     while(n--){
        p=(Linklist)malloc(sizeof(Lnode));
        scanf("%d", &p->data);
        p->next=t->next;
        t->next=p;
        t=p;
     }
     return head;
}

void split(Linklist head){
    int odd=0, even=0;
    Linklist h1, h2, r, t1, t2;
    r=head->next;
    h1=(Linklist)malloc(sizeof(Lnode));
    h2=(Linklist)malloc(sizeof(Lnode));
    h1->next=NULL;
    h2->next=NULL;
    t1=h1;
    t2=h2;
    while(r!=NULL){
        if(r->data%2!=0){
          t1->next=r;
          t1=r;
          r=r->next;
          t1->next=NULL;
          odd++;
        }
        else{
          t2->next=r;
          t2=r;
          r=r->next;
          t2->next=NULL;
          even++;
        }
    }
    printf("%d %d\n", even, odd);
    show(h2);
    show(h1);
}

void show(Linklist head){
    Linklist p;
    p=head->next;
    while(p!=NULL){
        printf("%d%c", p->data, p->next==NULL?'\n':' ');
        p=p->next;
    }
}
```

### 数据结构实验之链表六：有序链表的建立

Time Limit: 1000 ms Memory Limit: 65536 KiB

Problem Description

输入N个无序的整数，建立一个有序链表，链表中的结点按照数值非降序排列，输出该有序链表。

Input

第一行输入整数个数N；
第二行输入N个无序的整数。

Output

依次输出有序链表的结点值。

Sample Input

```
6
33 6 22 9 44 5
```

Sample Output

```
5 6 9 22 33 44
```

Hint

不得使用数组！

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data;
    struct node *next;
}Lnode, *Linklist;
Linklist create(int n);
void s(Linklist head);
void show(Linklist head);
int main()
{
    Linklist head;
    int n;
    scanf("%d", &n);
    head=create(n);
    s(head);
    show(head);
    return 0;
}

Linklist create(int n){
    Linklist head, t, p;
    head=(Linklist)malloc(sizeof(Lnode));
    head->next=NULL;
    t=head;
    while(n--){
        p=(Linklist)malloc(sizeof(Lnode));
        scanf("%d", &p->data);
        p->next=t->next;
        t->next=p;
        t=p;
    }
    return head;
}

//选择排序 找到最小的放第一个
void s(Linklist head){
    int  t;
    Linklist p, q;
    p=head->next;
    while(p!=NULL){
        q=p->next;
        while(q!=NULL){
            if(p->data>q->data){
                t=p->data;
                p->data=q->data;
                q->data=t;
            }
            q=q->next;
        }
        p=p->next;
    }
}

void show(Linklist head){
    Linklist p;
    p=head->next;
    while(p!=NULL){
        printf("%d%c", p->data, p->next==NULL?'\n':' ');
        p=p->next;
    }
}
```

### 数据结构实验之链表七：单链表中重复元素的删除

Time Limit: 1000 ms Memory Limit: 65536 KiB

Problem Description

按照数据输入的相反顺序（逆位序）建立一个单链表，并将单链表中重复的元素删除（值相同的元素只保留最后输入的一个）。

Input

第一行输入元素个数 n (1 <= n <= 15)；
第二行输入 n 个整数，保证在 int 范围内。

Output

第一行输出初始链表元素个数；
第二行输出按照逆位序所建立的初始链表；
第三行输出删除重复元素后的单链表元素个数；
第四行输出删除重复元素后的单链表。

Sample Input

```
10
21 30 14 55 32 63 11 30 55 30
```

Sample Output

```
10
30 55 30 11 63 32 55 14 30 21
7
30 55 11 63 32 14 21
```

Hint

Source

不得使用数组！

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int data;
    struct node *next;
}Lnode, *Linklist;

Linklist create(int n);
void show(Linklist head);
void del(Linklist head, int n);
int main()
{
    int n;
    Linklist head;
    scanf("%d", &n);
    head=create(n);
    printf("%d\n", n);
    show(head);
    del(head, n);
    return 0;
}

Linklist create(int n){
    Linklist head, p;
    head=(Linklist)malloc(sizeof(Lnode));
    head->next=NULL;
    while(n--){
        p=(Linklist)malloc(sizeof(Lnode));
        scanf("%d", &p->data);
        p->next=head->next;
        head->next=p;
    }
    return head;
}

void show(Linklist head){
    Linklist p;
    p=head->next;
    while(p!=NULL){
        printf("%d%c", p->data,p->next==NULL?'\n':' ');
        p=p->next;
    }
}

void del(Linklist head, int n){
    int count=0;
    Linklist p, q, r;
    p=head->next;
    while(p!=NULL){
        r=p;
        q=r->next;
        while(q!=NULL){
            if(p->data==q->data){
                r->next=q->next;
                free(q);
                q=r->next;
                count++;
            }else{
                q=q->next;
                r=r->next;
            }
        }
        p=p->next;
    }
    printf("%d\n", n-count);
    show(head);
}
```

### 数据结构实验之链表八：Farey序列

Time Limit: 10 ms Memory Limit: 600 KiB

Problem Description

Farey序列是一个这样的序列：其第一级序列定义为（0/1，1/1），这一序列扩展到第二级形成序列（0/1，1/2，1/1），扩展到第三极形成序列（0/1，1/3，1/2，2/3，1/1），扩展到第四级则形成序列（0/1，1/4，1/3，1/2，2/3，3/4，1/1）。以后在每一级n，如果上一级的任何两个相邻分数a/c与b/d满足（c+d）<=n，就将一个新的分数(a+b)/(c+d)插入在两个分数之间。对于给定的n值，依次输出其第n级序列所包含的每一个分数。

Input

输入一个整数n(0<n<=100)

Output

依次输出第n级序列所包含的每一个分数，每行输出10个分数，同一行的两个相邻分数间隔一个制表符的距离。

Sample Input

```
6
```

Sample Output

```
0/1   1/6   1/5   1/4   1/3   2/5   1/2   3/5   2/3   3/4
4/5   5/6   1/1
```

Hint

 Source

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    struct node *next;
    int top, bottom;
}Lnode, *Linklist;

void show(Linklist head);
Linklist create();
Linklist farey(Linklist head, int n);
void simple(int *bottom, int *top);

int main()
{
    Linklist head;
    int n;
    scanf("%d", &n);
    head=create();
    if(n==1){
        show(head);
    }else{
        head=farey(head, n);
        show(head);
    }
    return 0;
}

Linklist create(){//初始化一级序列
    Linklist head, p;
    head=(Linklist)malloc(sizeof(Lnode));
    head->next=NULL;
    p=(Linklist)malloc(sizeof(Lnode));
    p->next=head->next;
    head->next=p;
    p->top=1;
    p->bottom=1;
    p=(Linklist)malloc(sizeof(Lnode));
    p->next=head->next;
    head->next=p;
    p->top=0;
    p->bottom=1;
    return head;
}

Linklist farey(Linklist head, int n){
    Linklist p, q, r;
    int i;
    n--;//一的时候处理了
    i=1;
    while(n--){
         i++;
         q=head->next;
         p=q->next;
        while(p!=NULL){
            //如果直接插入的话会影响下一次的操作，两个相邻的就不是原链表的了，有一个是插入的
            if(p->bottom+q->bottom<=i){
                 r=(Linklist)malloc(sizeof(Lnode));
                 r->top=p->top+q->top;
                 r->bottom=p->bottom+q->bottom;
                 //化简
                 simple(&(r->bottom), &(r->top));
                 q->next=r;
                 r->next=p;
                 //处理操作，保证下次操作的时候不把新插入的元素用来判断
                 q=r->next;
                 p=q->next;
            }else{
                 p=p->next;
                 q=q->next;
            }
        }
    }
    return head;
}

void show(Linklist head){
    Linklist p;
    int c=1;
    p=head->next;
    while(p!=NULL){
        if(c==10||p->next==NULL){
            printf("%d/%d", p->top, p->bottom);
            printf("\n");
            c=0;
        }else{
            //制表符是/t
             printf("%d/%d\t", p->top, p->bottom);
        }
        p=p->next;
        c++;
    }
}

void simple(int *bottom, int *top){
     //分数化简，找出分子，分母的最大公约数，除以它即可
     int t,a,b;
     a=*bottom;
     b=*top;
     //辗转相除法
     if(a<b){
        t=a;
        a=b;
        b=t;
     }
     //余数t，让第二个数b去b%t（a对应b，b对应t）,直到a*b==0,b就是最大公约数
     while(a%b!=0){
        t=a%b;
        a=b;
        b=t;
     }
     *bottom=*bottom/b;
     *top=*top/b;
}
```

### 数据结构实验之链表九：双向链表

Time Limit: 1000 ms Memory Limit: 65536 KiB

Problem Description

学会了单向链表，我们又多了一种解决问题的能力，单链表利用一个指针就能在内存中找到下一个位置，这是一个不会轻易断裂的链。但单链表有一个弱点——不能回指。比如在链表中有两个节点A,B，他们的关系是B是A的后继，A指向了B，便能轻易经A找到B,但从B却不能找到A。一个简单的想法便能轻易解决这个问题——建立双向链表。在双向链表中，A有一个指针指向了节点B，同时，B又有一个指向A的指针。这样不仅能从链表头节点的位置遍历整个链表所有节点，也能从链表尾节点开始遍历所有节点。对于给定的一列数据，按照给定的顺序建立双向链表，按照关键字找到相应节点，输出此节点的前驱节点关键字及后继节点关键字。

Input

第一行两个正整数n（代表节点个数），m（代表要找的关键字的个数）。第二行是n个数（n个数没有重复），利用这n个数建立双向链表。接下来有m个关键字，每个占一行。

Output

对给定的每个关键字，输出此关键字前驱节点关键字和后继节点关键字。如果给定的关键字没有前驱或者后继，则不输出。
注意：每个给定关键字的输出占一行。
           一行输出的数据之间有一个空格，行首、行末无空格。

 

Sample Input

```
10 3
1 2 3 4 5 6 7 8 9 0
3
5
0
```

Sample Output

```
2 4
4 6
9
```

Hint

Source

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct node{
    int data;
    struct node *next, *pre;
}Lnode, *Linklist;

Linklist create(int n);
void locate(Linklist head, int k);
int main(void) {
	int n, m, k;
	Linklist head;
	scanf("%d", &n);
    scanf("%d", &m);
	head=create(n);
	while(m--){
	    scanf("%d", &k);
	    locate(head,k);
	}
	return 0;
}

Linklist create(int n){
    Linklist head, t, p;
    head=(Linklist)malloc(sizeof(Lnode));
    head->next=NULL;
    head->pre=NULL;
    t=head;
    while(n--){
        p=(Linklist)malloc(sizeof(Lnode));
        scanf("%d", &p->data);
        p->next=NULL;
        t->next=p;
        p->pre=t;
        t=p;
    }
    return head;
}

void locate(Linklist head, int k){
    Linklist p;
    p=head->next;
    while(p!=NULL){
        if(p->data==k){
            if(p->pre!=head){
                //注意这条输出语句，而且前置指针除了head为NULL,p->pre不可能为空
                printf("%d%s", p->pre->data,p->next==NULL?"\n":" ");
            }
            if(p->next!=NULL){
                printf("%d\n", p->next->data);
            }
        }
        p=p->next;
    }
}
```

