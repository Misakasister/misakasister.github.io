---
title: 01 背包问题
tags:
- 算法设计
categories: 编程
---
## 问题

| 序号 | 重量 | 价值 |
| ---- | ---- | ---- |
| 1    | 2    | 3    |
| 2    | 3    | 4    |
| 3    | 4    | 5    |
| 4    | 5    | 8    |
| 5    | 9    | 10   |

有5件物品和一个容量为20的背包。求解可以装入背包的最大价值是多少。

## 状态转移方程

定义一个数B(k,w)代表当前背包装载的最大价值,其中

k:前k件物品（不一定把前k件物品都拿进背包）

w:背包剩下的空间

比如B(5,20)代表背包里装了前5件物品，且背包空间为20的情况下所得到背包里物品的最大值，也就是**问题**所需要求的数。

需要说明的是，B(0,x) x可以代表任意的背包空间，0代表拿了0件物品，所以不管背包空间有多大，B(0,x)恒等于0

由于该问题是个动态规划的问题，我们要想知道拿k件物品的情况，就必须知道拿k-1件物品时的情况。

我现在了拿了前k-1件物品（背包价值B(k-1,w)），在拿第k件物品时（想要求B(k,w')会出现下列2种情况

1. 第k件物品太重了，超过了当前背包剩余空间w(wk>w)，那么这第k件物品不能拿，所以此时的B(k,w‘)=B(k-1,w)，相当于什么都没做就过渡到了B(k,w’)。

2. 第k件物品可以装入背包，问题又出现了，我们是装入还是不装呢？装入占空间，有可能就把当前背包的某些物品给挤出去了，所以此时就要比较装入和不装入后背包价值的大小了。

   1. 如果装入第k件物品，B(k,w‘)=B(k-1,w-wk)+value(k)，也就是说我在拿了第前k-1件物品时，背包价值为B(k-1,w),我把第k件物品装入了背包，那么此时的背包剩余的空间要减去第k件物品的重量，也就是w'=w-wk,同时价值要增加第k件物品的价值，即最后+value(k)。
   2. 如果不装入第k件物品，那么情况就相当于超重的情况（反正都是不装），此时B(k,w')=B(k-1,w)

   我们要求出max(装入第k件物品的背包价值，不装入第k件物品的价值)，使其等于B(k,w),即：

   `B(k,w)=max(B(k-1,w-wk)+value(k),B(k-1,w))`

   这就是该问题的状态转移方程

## 二维数组表示计算过程



![karr](https://github.com/Misakasister/misakasister.github.io/blob/master/images/karr/karr.png?raw=true)

## 代码表示

```c++
#include <iostream>
#include <string.h>
using namespace std;

int main()
{
    int dp[6][21];
    int w[6]={0,2,3,4,5,9};//重量
    int v[6]={0,3,4,5,8,10};//价值
    memset(dp,0,sizeof(dp));
    int k,c;
    for(k=1;k<6;k++){//遍历物品
        for(c=1;c<21;c++){//遍历重量
            if(w[k]>c){//如果物品重量太大，装不下
                dp[k][c]=dp[k-1][c];//等于没装之前的重量
            }else{//能装下--> 判断装下去合不合适（装下去可能会拿出一些东西
                int value1=dp[k-1][c-w[k]]+v[k];
                int value2=dp[k-1][c];
                if(value1>value2){
                    dp[k][c]=value1;
                }else{
                    dp[k][c]=value2;
                }
            }
        }
    }
    cout<<dp[5][20];
    return 0;
}

```

