<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多元线性回归]]></title>
    <url>%2F2022%2F01%2F12%2F%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[多元线性回归多维特征我们对房价模型增加更多的特征，例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为$\left( {x_1},{x_2},…,{x_n} \right)$。 引入一系列新的注释： $n$ 代表特征的数量 ${x^\left( i \right)}$代表第 $i$ 个训练实例，是特征矩阵中的第$i$行，是一个向量（vector）。 比方说，上图的 {x}^{(2)}\text{=}\begin{bmatrix} 1416\\\ 3\\\ 2\\\ 40 \end{bmatrix}${x}_{j}^{\left( i \right)}$代表特征矩阵中第 $i$ 行的第 $j$ 个特征，也就是第 $i$ 个训练实例的第 $j$ 个特征。 如上图的$x_{2}^{\left( 2 \right)}=3,x_{3}^{\left( 2 \right)}=2$， 支持多变量的假设 $h$ 表示为：$h_{\theta}\left( x \right)={\theta_0}+{\theta_1}{x_1}+{\theta_2}{x_2}+…+{\theta_n}{x_n}$， 为了使得公式能够简化一些，引入$x_{0}=1$，则公式转化为：$h_{\theta}\left( x \right)={\theta_0}{x_0}+{\theta_1}{x_1}+{\theta_2}{x_2}+…+{\theta_n}{x_n}$ 最终公式可以简化为：$h_{\theta} \left( x \right)={\theta^T}X$ 其中： \theta=\begin{bmatrix} \theta_0\\ \theta_1 \\ \theta_2 \\ ...\\ \theta_n \end{bmatrix} X=\begin{bmatrix} x_0\\ \ x_1 \\ x_2 \\ ...\\ x_n \end{bmatrix}梯度下降与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和，即： J(\theta_0,\theta_1...\theta_n)=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。多变量线性回归的批量梯度下降算法为： \theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1...\theta_n)对各参数$\theta_n$进行梯度下降更新： \theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_0^{(i)}\\ \theta_1:=\theta_1-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_1^{(i)}\\ \theta_2:=\theta_2-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_2^{(i)}\\ ....我们开始随机选择一系列的参数值，计算所有的预测结果后，再给所有的参数一个新的值，如此循环直到收敛。 特征缩放以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0-2000平方英尺，而房间数量的值则是0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。 解决的方法是尝试将所有特征的尺度都尽量缩放到-1到1之间。 最简单的方法是令：${x}_{n}=\frac{x_n-\mu_n}{s_n}$，其中 $\mu_{n}$是平均值，$s_{n}$是标准差。(标准化处理) 学习率梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。 也有一些自动测试是否收敛的方法，例如将代价函数的变化值与某个阀值（例如0.001）进行比较，但通常看上面这样的图表更好。 梯度下降算法的每次迭代受到学习率的影响，如果学习率$a$过小，则达到收敛所需的迭代次数会非常高；如果学习率$a$过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。 通常可以考虑尝试些学习率： $\alpha=0.01，0.03，0.1，0.3，1，3，10$ 多项式回归拟合房屋大小(size)与房价(price)之间的关系，我们可以猜测房价与房屋大小是三次函数的关系（二次函数关系的话，房屋大小增加，房价会下降不符合现实）： h_{\theta}(x)=\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_3\\ x_1=(size)\\ x_2=(size)^2\\ x_3=(size)^3\\ 也可以猜测： h_{\theta}(x)=\theta_0+\theta_1(size)+\theta_2\sqrt{size}在后续的学习中，我们会让算法自动选择合适的函数进行拟合，目前想表达的是可以用不同的函数对数据进行拟合。 注：如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。 正规方程 假设我们的训练集特征矩阵为 $X$（包含了 $x_0=1$）并且我们的训练集结果为向量 $y$，则利用正规方程解出向量 \theta =\left( {X^T}X \right)^{-1}X^Ty以下表示数据为例： 即： 运用正规方程方法求解参数： 梯度下降与正规方程的比较： 梯度下降 正规方程 需要选择学习率$\alpha$ 不需要 需要多次迭代 一次运算得出 当特征数量$n$大时也能较好适用 需要计算$\left( {X^T}X \right)^{-1}$ 如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为$O\left( n^3 \right)$，通常来说当$n$小于10000 时还是可以接受的 适用于各种类型的模型 只适用于线性模型，不适合逻辑回归模型等其他模型 $X’X$不可逆第一种情况： 在预测住房价格时，如果$x_1$是以英尺为尺寸规格计算的房子，$x_2$是以平方米为尺寸规格计算的房子，同时，你也知道1米等于3.28英尺 ( 四舍五入到两位小数 )，这样，你的这两个特征值将始终满足约束：$x_1=x_2*\left( 3.28 \right)^2$。 第二种情况： 在$m$小于或等于n的时候，例如，有$m$等于10个的训练样本也有$n$等于100的特征数量。通常，我们会使用一种叫做正则化的线性代数方法，通过删除某些特征或者是使用某些技术，来解决当$m$比$n$小的时候的问题。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习简介]]></title>
    <url>%2F2021%2F12%2F31%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[机器学习简介定义Arthur Samuel 1959 在没有明确设置的情况下，是计算机具有学习能力的研究领域。 Tom Mitchell 1998 计算机程序从经验E中学习，解决某一任务T 进行某一性能度量P，通过P测定在T上的表现因经验E而提高 对于玩跳棋：E-程序自己下几万次跳棋 T-玩跳棋 P-与新对手玩跳棋赢得概率 监督学习给算法一个数据集，数据集中的数据都有正确的结果标签。算法的目的是给出更多的正确结果。 回归问题：设法预测连续值的属性。 分类问题：设法预测一个离散值的输出。 无监督学习给算法一个数据集，数据集中的数据没有明确的结果标签。算法的目的是对数据集进行分簇。 模型以房屋交易问题为例，假使我们回归问题的训练集（Training Set）如下表所示： 我们将要用来描述这个回归问题的标记如下: $m$ 代表训练集中实例的数量 $x$ 代表特征/输入变量 $y$ 代表目标变量/输出变量 $\left( x,y \right)$ 代表训练集中的实例 $(x^{(i)},y^{(i)})$ 代表第$i$ 个观察实例 $h$ 代表学习算法的解决方案或函数也称为假设（hypothesis） 代价函数对于假设函数$h(\theta)=\theta_0+\theta_1x$： 其代价函数(平方误差函数MSE)为 J \left( \theta_0, \theta_1 \right) = \frac{1}{2m}\sum\limits_{i=1}^m \left( h_{\theta}(x^{i})-y^{i} \right)^{2}$\frac{1}{m}$是为了取平均，$\frac{1}{2}$是为了求平方($x^2$)的导数好计算。 目的是找到其代价函数值最小。 对于其MSE，将 $\theta_0$,$\theta_1$视为变量，有： 是一个碗状函数，可以看出在三维空间中存在一个使得$J(\theta_{0}, \theta_{1})$最小的点。 该函数的等高线图（线上的$J(\theta_{0}, \theta_{1})$值都相等）为： 右图中红色的点对应的$\theta_0$,$\theta_1$拟合的直线为左图中的直线。 梯度下降如何找到 $\theta_0$,$\theta_1$ 使得 $J(\theta_{0}, \theta_{1})$ 的值最小——梯度下降。 梯度下降法可用于更一般的函数。 想象一下你正站立在山的这一点上，站立在你想象的公园这座红色山上，在梯度下降算法中，我们要做的就是旋转360度，看看我们的周围，并问自己要在某个方向上，用小碎步尽快下山。这些小碎步需要朝什么方向？如果我们站在山坡上的这一点，你看一下周围，你会发现最佳的下山方向，你再看看周围，然后再一次想想，我应该从什么方向迈着小碎步下山？然后你按照自己的判断又迈出一步，重复上面的步骤，从这个新的点，你环顾四周，并决定从什么方向将会最快下山，然后又迈进了一小步，并依此类推，直到你接近局部最低点的位置。 梯度下降公式： {\theta_j}:={\theta_j}-\alpha \frac{\partial J\left(\theta_0,\theta_1 \right) }{\partial {\theta_j}}\{j=0,1\}其中$\alpha$是学习率（learning rate），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。$\alpha$ 恒为正值。 对我们之前的线性回归问题运用梯度下降法，关键在于求出代价函数的导数，即： 上面提到过，梯度下降只能获得局部最优解，并不一定能得到全局最优解。但是线性回归的代价函数是凸函数，凸函数没有局部最优解，只有一个全局最优解。 梯度下降算法： 直到两个偏导数为0。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几何]]></title>
    <url>%2F2021%2F11%2F27%2F%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[——不是所有物体都用三角形的面来表示。 几何表示隐式几何点满足一定的关系。 比如要显示一个球，需要满足 x^2+y^2+z^2=1 隐式几何的优点是判断一个点在物体内外很容易。 缺点是只看方程很难判断图形形状。 Constructive Solid Geometry(CSG)CSG指的是可以对各种不同的几何做布尔运算，如并，交，差： 符号距离函数（Signed Distance Function）符号距离函数来说本质上就是一种定义距离的函数。 给出任意点到物体的距离。这个距离是带符号的，有正有负。 可以观察到p点到圆边界的距离为： ||\overrightarrow{ap}|| - r如有空间任意一点到各个几何物体表面的距离，对这些距离做各种各样的运算操作最后得到的一个函数就是最终的距离函数了。 水平集（Level Set）用存储函数近似值的网格表示图形。 对该面内的每一个点利用已经定义好的格子值进行双线性插值(在纹理映射一节已讲解)就可以得到任意一点的函数值，找出所有=0的点作为曲面。 分型（Fractals）分型几何是指许许多多自相似的形体最终所组成的几何形状。类似于递归。 显式几何在空间中直接定义了一些点。 或者在空间中定义一组映射关系： f：R^2\rightarrow R^3\\ (u,v) \rightarrow (x,y,z) 显式几何的优点是判断物体的形状容易。 缺点是判断一个点在物体内外困难。 点云（Point Cloud）使用很多空间中的点所构成的曲面。 可以看出图形上方的点密集，下方的点稀疏。 多边形网格（Polygon Mesh）使用最广泛的显示几何表示。 存储顶点和多边形（一般是三角形或者四边形） 一般建模软件所使用的就是多边形网格表示，建模软件生成的obj文件如下： v 是顶点坐标 vt 是纹理坐标 vn 是点的法向量 f 代表一个面由哪些顶点/纹理/法向量组成 曲线贝塞尔曲线（Bézier Curves）用控制点定义的曲线。 曲线一定过起始点，进入方向为$\overrightarrow{P_0P_1}$，射出方向为$\overrightarrow{P_2P_3}$ 三次贝塞尔曲线如图： 生成考虑有三个顶点控制的曲线（二次贝塞尔曲线）： 在线段上使用线性插值： 考虑一点$b^1_0$在$b_0b_1$上运动，需要在1秒内从$b_0$移动到$b_1$。 那么另一点$b^1_1$在$b_1b_2$上运动，需要在1秒内从$b_1$移动到$b_2$。 那么在t时刻($t\epsilon[0,1]$),利用线性插值公式有： b^1_0=b_0+t*(b_1-b_0)\\ =(1-t)*b_0+t*b_1\tag{1}同理： b^1_1=(1-t)*b_1+t*b_2\tag{2}链接$b^0_1$与$b^{1}_1$。 在$b^2_0$点用插值公式有： b^2_0=(1-t)b^1_0+tb^1_1\tag{3}将公式（1）（2）带入（3）有： b^2_0=(1-t)((1-t)*b_0+t*b_1)+t((1-t)*b_1+t*b_2)\\ =(1-t)^2b_0+2t(1-t)b_1+t^2b_2\\可以看出$b^{2}_0$的展开式的系数是$(1-t+t)^2$的完全平方展开。 同理四个控制点的三次贝塞尔曲线有： 逐层插值有： 可得： b^3_0=(1-t)^3b_0+3t(1-t)^2b_1+3t^2(1-t)b_2+t^3b_3 由此可以得到一般的n阶（n+1个顶点）贝塞尔曲线表达式： b^n(t)=b^n_0(t)=\sum_{j=0}^n{b_jB^n_j(t)}其中$B^n_j(t)$为： B^n_i(t)=C^i_n(1-t)^{n-i}t^i也称伯恩斯坦多项式（Bernstein polynomials） 就是$(1-t+t)^n$的二项展开。相当于1的展开式，因此在各个时刻，伯恩斯坦多项式加起来为1。 $b_i$点可以换成三维空间的点，可以在三维空间中画出贝塞尔曲线。 性质 仿射不变性（投影变换会改变曲线） 凸包性质（曲线会被控制点围起来） 对称性 高阶贝塞尔曲线很难进行控制： 因此，我们常用3阶贝塞尔曲线分段进行控制。 贝塞尔曲面（Bézier Surfaces）使用4x4共16个点描述贝塞尔曲面 首先竖列取4个点生成贝塞尔曲线,一共4组，使用时间u。 横向上，用1生成的4组点再描述贝塞尔曲线，使用时间v。 对于二维不同的u,v，在空间中都能对应一个点。 网格处理（Mesh Operations） 网格细分（Mesh Subdivision） 曲面细分是指将一个模型的面合理的分成更多小的面，从而提升模型精度。 Loop细分（Loop Subdivision）连结三角形的三边的中点，将一个三角形划分为4个三角形。 将三角形的顶点划分为两类：细分前就存在的老顶点，细分后生成的顶点叫做新顶点。 (暂且只考虑非边界的情况) 对新顶点做以下处理： 新顶点（白色的点）由老顶点（A 、B、C、D）的位置所决定，AB点在新顶点的共享边上，CD在新顶点的不共享边上。 V_{new} = \frac{3}{8}*(V_A+V_B)+\frac{1}{8}*(V_C+V_D)对老顶点的处理如下： 老顶点的位置由相邻的老顶点何其自身的位置决定。 n为需要更新的老顶点的度。 u为$\frac{1}{n}*[\frac{5}{8}-(\frac{3}{8}+\frac{1}{4}\cos{\frac{2\pi}{n}})^2]$。 V_{new}=(1-n*u)*原顶点的位置+u*临近顶点的位置之和先细分曲面，再调整顶点。 Loop细分更新效果： Catmull-Clark SubdivisionLoop细分只是针对三角形构成的物体，Catmull-Clark Subdivision可以细分四边形与三角形的混合细分。 对于所有不是四边形的面，称之为Non-quad face 所有度不为4的顶点称之为奇异点 将每个网格边上的中点与网格中线相连： 经过一次细分，可以得到： 会增加Non-quad face数量的奇异点，而且已经没有Non-quad face了。 再次细分： 因为已经没有Non-quad face了，所以再细分也不会增加奇异点数量。 顶点的位置调整： 对应网格重心点$f$，边上的中点$e$，网格的顶点$p$位置调整规则。 Catmull-Clark Subdivision 效果 网格简化（Mesh Simplification） 将一个模型的面合理的合成更少的面，从而降低模型精度。 边坍缩（Collapsing An Edge） 如何保证坍缩后的几何形状不发生大变化？ 引入二次度量误差（Quadric Error Metrics） 左图为五点距离取平均，显然坍缩后形状发生了很大的改变。 右图为构造的新顶点距离原相关三角形面的距离平方（L2距离）之和最小。 边坍缩流程： 为模型每条边赋值，其值为坍缩这条边之后（会形成一个点），代替两个老顶点的新顶点所能得到的最小二次误差度量 选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置 坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值 重复上述步骤，直到到达终止条件 边坍缩效果：]]></content>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[着色]]></title>
    <url>%2F2021%2F11%2F17%2F%E7%9D%80%E8%89%B2%2F</url>
    <content type="text"><![CDATA[——在图片上引入明暗和颜色的不同。（一般定义） ——对不同的物体引入不同的材质。（图形学定义） Blinn- Phong Reflectance ModelBlinn- Phong Reflectance Model只是经验模型，并不代表的实际的物理效果。 我们只考虑一个点的着色，不考虑阴影和点之间的影响。 需要定义： 观察向量 $\overrightarrow{v}$ 表面法向量 $\overrightarrow{n}$ 光源方向 $\overrightarrow{l}$ 材料性质（颜色，材质 ） 漫反射（diffuse reflection） 漫反射，是投射在粗糙表面上的光向各个方向反射的现象。当一束平行的入射光线射到粗糙的表面时，表面会把光线向着四面八方反射，所以入射线虽然互相平行，由于各点的法线方向不一致，造成反射光线向不同的方向无规则地反射，这种反射称之为“漫反射”或“漫射”。这种反射的光称为漫射光。 光会向不同的方向均匀发射，与观察者无关。 兰伯特余弦定理（Lambert）物体完全接受了光照： 物体旋转60°后，只接受了一半的光： 考虑一般情况，物体单位面积上接受光的比例为： \cos\theta=\overrightarrow{l}\cdot\overrightarrow{n} 光照强度考虑到一个点光源在空间中，向四周发射光。我们在空间中截取很多球面，不考虑能量衰减，那么每个球面的总能量是相同的。越往外球面单位面积上所能接受到的能量就越少。 记半径为1的单位球的单位面积上接受到能量为I，根据球的面积公式可以得到，距离点光源直径为R上的点，接受到的能量为$I’=\frac{I}{R^2}$。 推导如下： 假设总光照强度为E，有： I=\frac{E}{4\pi 1^2}\\ I'=\frac{E}{4\pi R^2}\\ I'=\frac{I}{R^2} 综上，我们可以得到漫反射能量公式： L_d=k_d(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{l}) $k_d$ 漫反射率，有物体本身的性质决定，0代表黑色全吸收，1代表一点也不吸收能量。物体的颜色rgb三通道决定。 $(I/r^2)$ 光照到达该点的能量。 $max(0,\overrightarrow{n}\cdot\overrightarrow{l})$ 物体所接受的能量，由位置决定，取max是因为负的接受量没有实际意义。 高光（Specular Term ）强度取决于观察方向。 如何判断镜面反射向量$\overrightarrow{R}$靠近观察向量$\overrightarrow{v}$？ 使用半程向量$\overrightarrow{h}$（也就是灯源方向$\overrightarrow{l}$与观察向量$\overrightarrow{v}$的角平分线） \overrightarrow{h}=\frac{\overrightarrow{v}+\overrightarrow{l}}{||\overrightarrow{v}+\overrightarrow{l}||}与漫反射类似，我们可以得到高光的强度公式： L_s=k_s(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{h})^p $k_s$ 一般是白色（高光一般就是白色） $(I/r^2)$ 光照到达该点的能量。 $max(0,\overrightarrow{n}\cdot\overrightarrow{h})^p$ 高光强度，如果不取指数p，会发现高光太亮了（$\overrightarrow{n}\cdot\overrightarrow{h}$很小的情况下（夹角很大），就能看见很亮的高光，这样是不对的，$\overrightarrow{n}\cdot\overrightarrow{h}$很大（夹角很小）的情况下才应该看见高光） 环境光（Ambient Term）没有光照射到的像素也不应该是黑色的，物体本身有自身的颜色。 L_a=k_aI_a $k_a$ 环境系数 $I_a$ 环境光强度 总结将环境光、漫反射、高光加起来就是Blinn-Phong Reflection Model。 L=L_a+L_d+L_s\\ =k_aI_a+k_d(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{l})+k_s(I/r^2)max(0,\overrightarrow{n}\cdot\overrightarrow{h})^p着色频率着色应用在哪些点上？ 逐面着色（flat shading）三角形是平面，法向量唯一。 但对于光滑的面着色效果不好。 逐顶点着色（Gouraud shading）如何确定一个顶点的法向量。 取顶点相邻面的法向量取平均。 三角形内部进行插值运算。 N_v=\frac{\sum_{i}{N_i}}{||\sum_{i}{N_i}||}也可以对相邻面进行加权求和。权值是三角形的面积。 逐像素着色（Phong shading）算出顶点的法向量，之后对中间的像素点的法向量进行插值运算。 总结着色频率的效果与面数有很大的关系： 图形渲染管线（Real-time Rendering） 顶点处理（Vertex Processing），对输入的顶点数据进行model、view、projection变换。将三维顶点数据变换到二维屏幕坐标上。 三角形处理（Triangle Processing），对变换得到的点连成三角形面。 光栅化（Rasterization），确定三角形如何显示在像素上。 片段着色器（Fragment Processing），着色、深度测试，纹理映射。其中着色、纹理映射也可以在顶点处理中做。 Framebuffer，将所有的像素颜色信息整合在一起，输送给显示设备加以显示。 Shader Programsshader中每个像素都会执行相应的操作。 顶点操作 =&gt; vertex processing 像素操作 =&gt; fragment processing 这也是图形渲染管线中可编程的两个部分。 纹理映射3D图形的表面是2D图像。 假设已知3D三角形到2D中三角形中顶点坐标的映射关系。 3D三角形中每个顶点都对应纹理坐标中一个u,v。 三角形的重心坐标（Barycentric Coordinates）我们在顶点做运算（纹理坐标、颜色，法向量等…….），三角形内部的值就需要根据顶点的值做插值运算。 做插值运算，比较方便的方式就是使用重心坐标。 三角形内的任意一点（x,y）都能使用三个顶点的坐标线性表示。 (x,y) = \alpha A + \beta B + \gamma C\\ \alpha + \beta + \gamma = 1其中$(\alpha,\beta,\gamma)$就是点的重心坐标。 比如顶点A,有： (x_A,y_A) = \alpha A + \beta B + \gamma C\\ =1*A+0*B+0*C\\因此顶点A的重心坐标(1,0,0)。 如果要保证顶点在三角形内部，$\alpha、\beta 、\gamma$都必须是非负的。否则只能保证点在三角形所在平面内。 推导通过面积进行推导： 除了上面的定义，我们还有一种几何观点。 对三角形内任意一点（x,y），我们可以把三角形分成三个小三角形。 通过顶点对面的三角形面积比定义$\alpha、\beta 、\gamma$。 何为一个顶点对面的三角形，就是点不相邻的三角形，比如顶点A对面的三角形就是$\triangle A_A$。 综上，可以得到定义： S=\triangle A_A + \triangle A_B + \triangle A_C\\ \alpha = \frac{A_A}{S}\\ \beta = \frac{A_B}{S}\\ \gamma = \frac{A_C}{S}\\接下来的问题是，知道三角形的三个顶点坐标，如何求三角形的面积。 二维向量的叉乘公式： a点(x1,y1)，b点(x2,y2): \overrightarrow{a}\cross\overrightarrow{b}= x_1y_2-x_2y_1现在推导$\alpha$的表达式,记三角形内某点为D(x,y)： \overrightarrow{BC}=(x_C-x_B,y_C-y_B)\\ \overrightarrow{BD}=(x-x_B,y-y_B)\\ S\triangle A_A =\frac{1}{2}|BC||BD|\sin{\angle CBD}\\ =\frac{1}{2}\overrightarrow{BD}\cross\overrightarrow{BC}\\ =\frac{1}{2}(x_C-x_B,y_C-y_B)\cross(x-x_B,y-y_B)\\ =\frac{1}{2}((x_C-x_B)*(y-y_B)-(x-x_B)*(y_C-y_B)) \overrightarrow{BC}=(x_C-x_B,y_C-y_B)\\ \overrightarrow{BA}=(x_A-x_B,y_A-y_B)\\ S =\frac{1}{2}|BC||BA|\sin{\angle ABC}\\ =\frac{1}{2}\overrightarrow{BC}\cross\overrightarrow{BA}\\ =\frac{1}{2}(x_C-x_B,y_C-y_B)\cross(x_A-x_B,y_A-y_B)\\ =\frac{1}{2}((x_C-x_B)*(y_A-y_B)-(x_A-x_B)*(y_C-y_B)) \alpha =\frac{-(x-x_B)*(y_C-y_B)+(x_C-x_B)*(y-y_B)}{-(x_A-x_B)*(y_C-y_B)+(x_C-x_B)*(y_A-y_B)}同理可得$\beta$值，综上，三角形内任意一点D(x,y)的重心坐标为： \alpha =\frac{-(x-x_B)*(y_C-y_B)+(x_C-x_B)*(y-y_B)}{-(x_A-x_B)*(y_C-y_B)+(x_C-x_B)*(y_A-y_B)}\\ \beta=\frac{-(x-x_C)*(y_A-y_B)+(x_A-x_C)*(y-y_C)}{-(x_B-x_C)*(y_A-y_C)+(x_A-x_C)*(y_B-y_C)}\\ \gamma = 1 - \alpha - \beta总结重心坐标的应用是对三角形进行插值运算。 $V_A、V_C、V_C$可以代表顶点的各种属性(纹理坐标、颜色，法向量等…….),那么三角形中任意一点V的属性值为： V=\alpha V_A + \beta V_B + \gamma V_C再利用重心坐标进行插值的时候，投影到屏幕前后所计算出的重心坐标不一样，因此我们需要在3D空间中进行重心坐标插值再投影。当然也可以在二维屏幕空间进行透视矫正的重心坐标插值。 应用纹理123对屏幕中的每个像素(x,y)#(x,y)是像素中心坐标： (u,v) = (x,y)映射到的纹理坐标#进行重心坐标插值 显示的颜色=纹理坐标下(u,v)的颜色 纹理放大（Texture Magnification ）纹理过小—— 纹理过小（纹理分辨率不够） 想想我们把一张100x100的纹理贴图应用在一500x500的屏幕之上必然会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应(u,v)坐标在texture贴图下最近的那个像素点，往往会造成严重的走样。 邻近过滤 (Nearest)如果我们对屏幕坐标(x,y)映射到纹理坐标(u,v)不做处理，会发生多个屏幕坐标(x,y)映射到一个纹理坐标(u,v)的情况。 Nearest就是用映射完坐标后最接近映射的纹理坐标的那个纹理颜色。 双线性插值（Bilinear）黑色点为纹理坐标点，红点为屏幕像素采样纹理坐标点。 一维线性插值： 有ABC三个点，C点在AB之间，根据长度我们设$\frac{AC}{AB}=x$，x的范围为0~1，那么当我们知道AB的属性（例如颜色，法线等）时，C点对应的属性即为： C=lerp(x,A,B) = A + x (B-A)取出离红色点最近的4个黑色顶点，分别算出，该红色点在水平及竖直方向偏移的比率s,t，图示如下: 接着先利用s，可以线性插值出如下图所示的u0，u1点的颜色值 u_0 = lerp(s,u_{00},u_{10})\\ u_1 = lerp(s,u_{01},u_{11})采样点的颜色为： f(x,y) = lerp(t,u_0,u_1)双三次插值算法（Bicubic）取周围16个像素，每次对4个像素进行三次插值。 纹理过大 近处锯齿！远处摩尔纹！非常严重的走样现象。 地板上铺满了重复的方格贴图，根据近大远小，远处的一张完整的贴图可能在屏幕空间中仅仅是几个像素的大小，那么必然屏幕空间的一个像素对应了纹理贴图上的一片范围的点，这其实就是纹理过大所导致的，直观来说想用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重失真！(从信号的角度来说就是，采样频率过低无法还原信号原貌)。 从纹理图来看，我们的格子其实都是一样大小的，也就是说每个格子所占的纹理像素是一样多的。但是因为透视投影的近大远小效果，我们近处格子看起来会很大，也就是说会有很多的屏幕像素来显示一个格子，那不就导致多个屏幕像素会对应到一个纹理像素了么，也就是我们前面所说的模糊问题。而在远处就恰恰相反了，用极少的像素显示一个甚至多个格子，也就是说我们一个屏幕像素会对应到多个纹理像素，这就产生了摩尔纹（摩尔纹属于欠采样所造成的，即我们很多纹理像素缺只采样了其中一个像素的值，我们只需要利用MSAA的原理，即在一个像素内增加采样点，然后求个平均，来反走样）。 因此我们可以说近处纹理过小，远处纹理过大。 想象一下纹理贴图大小500x500，屏幕空间100x100，将屏幕空间的像素点均匀分布在纹理空间之中，那么1个屏幕空间像素点所占的平均大小就是5x5=25个纹理空间像素，因此这就是纹理过大所导致的结果) Mipmap—— 一张图生成一些列图。 通过超采样的方法效率太低，如果我们知道像素覆盖的纹理范围后能马上知道像素的颜色就好了，这就要引入Mipmap技术。 Mipmap 是快速的、近似的、正方形的范围查询。 每张图是上一张的一半大小（指的分辨率）。 每组Mipmap多占用了$\frac{1}{3}$的存储空间： 假设存储3倍的Mipmap,L0级的大小为x，最终会填充出一个x的大小的格子。 Mipmap组成一个图像金字塔。 如何确定一个像素对应的Mipmap等级？ ——求出该像素对应的纹理范围在第几层Mipmap会对应一个纹理像素。 假设我们要求下面粉色像素$(u，v)_{00}$所对应的Mipmap等级。 取该粉色像素的上面$(u，v)_{01}$和右面$(u，v)_{10}$的像素，查看三个像素在纹理坐标下的距离，取较大的距离记为L。 在$(u，v)_{00}$取边长为L的正方形，就是$(u，v)_{00}$所对应的纹理坐标范围。 假设L在L0的Mipmap对应2个像素，那么该像素就会在L1的Mipmap上对应1个像素。 假设L在L0的Mipmap对应4个像素，那么该像素就会在L1的Mipmap上对应2个像素。在L2的Mipmap上对应1个像素。 如果L对应的不是2的幂次方像素，那么就可能对应L1.6层的Mipmap这种情况，在这种情况下，我们需要在层之间进行插值。 在L(D)层进行双线性插值，在L(D+1)进行双线性插值，再在层之间进行一次线性插值，得到非整数层的Mipmap属性值。 Mipmap的结果： 会发现远处十分模糊，因为Mipmap只能近似正方形。 各向异性过滤（Anisotropic Filtering） 横行，固定高度，只对宽度取半。 竖列，固定宽度，只对高度取半。 Mipmap是对角线。 开销是原图的3倍。 各向异性对矩形区域处理的比较好，对于Mipmap只能处理正方形是一个进步。 但对斜条形处理不好，可以用EWA filtering。 环境贴图（Environment Map）将环境光存贮在一个球体中（Spherical Map）： 存储在球体中会产生一些问题 会发现图像的上部和下部会产生扭曲。 因此，会用正方体保存环境光（Cube Map）： 假设用一个包围盒将球体包裹，延球心到球面像素点的方向，将球面的像素打在正方体上。 凹凸贴图（Bump mapping）也叫法线贴图（Normal mapping）。 用纹理存储法向量的相关信息。或者用纹理存储点的高度信息。并不是用纹理存储颜色。 凹凸贴图只是虚拟的（从逻辑上）改变点的高度，从而改变了法向量。实际上物体的几何形体并没有发生变化。 黑线是实际的物体几何表面，黄线是虚拟的，是凹凸贴图所认为的物体表面。 位移贴图（Displacement mapping）会真实地改变物体的几何表面。 3D纹理 球的内部也有纹理，表面的图案可以通过噪声函数生成，空间中的每一个点(x,y,z)都对应一个颜色。]]></content>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光栅化]]></title>
    <url>%2F2021%2F11%2F05%2F%E5%85%89%E6%A0%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[——将图形显示在屏幕上。 在屏幕上画出三角形为什么是三角形进行划分 最基本的多边形，可以组成其它多边形。 三角形一定在一个平面内。 三角形的内外定义清楚（可以通过向量叉积判断一个点是否在三角形内）。 方便进行插值运算（重心坐标） 对三角形进行采样（Sampling）采样：对函数进行离散化。 123for(int x = 0; x &lt; xmax; x++)&#123; output[x] = f(x);&#125; 基本图形： 如果像素中心(x+0.5,y+0.5)在三角形内部就进行采样： 定义采样函数： inside(t,x,y)=\begin{cases}&1&点(x,y)在三角形t内\\&0&其它\end{cases}判断一个点是否在三角形内部 对于点Q与$\triangle P_0P_1P_2$,按照三角形顶点的顺序与Q进行叉乘有: \overrightarrow{P_0P_1}\cross\overrightarrow{P_0Q}=\overrightarrow{z}>0\\ \overrightarrow{P_1P_2}\cross\overrightarrow{P_1Q}=\overrightarrow{z}>0\\ \overrightarrow{P_2P_0}\cross\overrightarrow{P_2Q}=\overrightarrow{z}]]></content>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变换]]></title>
    <url>%2F2021%2F10%2F31%2F%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[2D变换（2D transformation）缩放（Scale） 坐标(x,y)缩放至(x’,y’)，x轴缩放 s_x=0.5 ，y轴缩放s_y=1： x'=s_x*x+0*y\\ y'=0*x+s_y*y矩阵形式： \left[\begin{matrix} s_x&0\\ 0&s_y\\ \end{matrix}\right] * \left[\begin{matrix} x\\ y\\ \end{matrix}\right] = \left[\begin{matrix} x'\\ y'\\ \end{matrix}\right]错切（shear） 首先能观察到点的y坐标不会发生变化，只有x坐标进行变换： y'=yx轴的坐标变换会根据高度（即y值）进行变换。具体而言： 对于点A(x,y)变换到点B(x’,y’)有： \triangle OAB \sim \triangle ODC\\ \frac{AB}{DC}=\frac{OA}{OD}\\ \frac{AB}{DC} = \frac{AB}{a} = \frac{x'-x}{a}\\ \frac{OA}{OD} = \frac{y}{1}\\综上有： \frac{x'-x}{a} = \frac{y}{1}\\得： x'=x+a*y综上有： x'=x+ay\\ y'=0x+y矩阵形式： \left[\begin{matrix} 1&a\\ 0&1\\ \end{matrix}\right] * \left[\begin{matrix} x\\ y\\ \end{matrix}\right] = \left[\begin{matrix} x'\\ y'\\ \end{matrix}\right]旋转（Rotation）规定绕原点（0,0）逆时针进行旋转。 对于图上一点$(x_a,y_a)$ 有 x_a = r\cos\theta\tag{1}\\ y_a = r\sin\theta\tag{2}经旋转$\phi$角度至$(x_a’,y_a’)$有 x_a'=rcos(\theta+\phi)\\ y_a'=rsin(\theta+\phi)\\根据和角公式： \sin(\alpha+\beta)=\sin\alpha\cdot\cos\beta+\cos\alpha\cdot\sin\beta\\ \cos(\alpha+\beta)=\cos\alpha\cdot\cos\beta-\sin\alpha\cdot\sin\beta\\有： x_a'=rcos(\theta+\phi)=r\cos\theta\cdot\cos\phi-r\sin\theta\cdot\sin\phi\\ y_a'=rsin(\theta+\phi)=r\sin\theta\cdot\cos\phi+r\cos\theta\cdot\sin\phi\\将公式(1)(2)带入有 x_a'= x_a\cos\phi-y_a\sin\phi\\ y_a'= y_a\cos\phi+x_a\sin\phi写成矩阵形式有： \left[\begin{matrix} \cos\phi & -\sin\phi \\ \sin\phi & \cos\phi \\ \end{matrix}\right] * \left[\begin{matrix} x_a\\ y_a\\ \end{matrix}\right] = \left[\begin{matrix} x_a'\\ y_a'\\ \end{matrix}\right]旋转矩阵是正交矩阵考虑一个点旋转 $-\phi$ 角度。 有： R(-\phi)= \left[\begin{matrix} \cos-\phi & -\sin-\phi \\ \sin-\phi & \cos-\phi \\ \end{matrix}\right] = \left[\begin{matrix} \cos\phi & \sin\phi \\ -\sin\phi & \cos\phi \\ \end{matrix}\right]与旋转$\phi$ 角度互逆： R(\phi)= \left[\begin{matrix} \cos\phi & -\sin\phi \\ \sin\phi & \cos\phi \\ \end{matrix}\right] \\ R(\phi)^{-1}=R(-\phi)并且可以观察到这两个矩阵互为转置矩阵 R(\phi)^{T}=R(-\phi)因此有： R(\phi)^{-1}=R(\phi)^{T}综上，旋转矩阵为正交矩阵。 位移（Translation） 将点(x,y)平移$T_{tx}、T_{ty}$个单位得到$(x+T_{tx},y+T_{ty})$ 有变换： x'=x+t_x\\ y'=y+t_y矩阵形式： \left[\begin{matrix} 1&0\\ 0&1\\ \end{matrix}\right] * \left[\begin{matrix} x\\ y\\ \end{matrix}\right] + \left[\begin{matrix} t_x\\ t_y\\ \end{matrix}\right] = \left[\begin{matrix} x'\\ y'\\ \end{matrix}\right]但该变换不是线性变换，而是仿射变换。 仿射变换，又称仿射映射，是指在几何进行一次线性变换并接上一个平移，变换为另一个向量空间。 “仿射变换”就是：“线性变换”+“平移” 我们现在要通过高纬度的线性变换完成低纬度的仿射变换。将点进行生维到z=1的平面上、也就是(x,y)至(x,y,1)： 记$\overrightarrow{x}$为二维平面上的点坐标 \overrightarrow{x}=(x,y)^TA为在二维空间上的线性变换矩阵。 $\overrightarrow{b}$ 为位移尺度: \overrightarrow{b}=(T_x,T_y)^T 这样我就可以在三维空间下通过$\left[\begin{matrix}A&amp;\overrightarrow{b}\\0&amp;1\end{matrix}\right]$这个线性变换变换柱子来操作z=1平面上的二维正方形，完成仿射变换： 记$\overrightarrow{y}$为二维平面上的位移后得到的点坐标(x’,y’) \overrightarrow{y}=(x',y')^T 新加入的维度记为w，也称为齐次坐标。 矩阵形式： \left[\begin{matrix} 1&0&t_x\\ 0&1&t_y\\ 0&0&1\\ \end{matrix}\right] * \left[\begin{matrix} x\\ y\\ 1\\ \end{matrix}\right] = \left[\begin{matrix} x+t_x\\ y+t_y\\ 1\\ \end{matrix}\right] = \left[\begin{matrix} x'\\ y'\\ w'\\ \end{matrix}\right]把矩阵分解为向量更好理解： \left[\begin{matrix} 1\\ 0\\ 0\\ \end{matrix}\right] *x + \left[\begin{matrix} 0\\ 1\\ 0\\ \end{matrix}\right] *y + \left[\begin{matrix} t_x\\ t_y\\ 1\\ \end{matrix}\right] *1 = \left[\begin{matrix} x+t_x\\ y+t_y\\ 1\\ \end{matrix}\right] = \left[\begin{matrix} x'\\ y'\\ w'\\ \end{matrix}\right]齐次坐标（Homogenous Coordinates） 齐次坐标：就是将一个原本是n维的向量用一个n+1维向量来表示，是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般。” 齐次坐标可以看作一种记号，w为1记为点，为0记为向量。 在欧氏空间中，两条平行线永不相交，但是在投影几何中，两条平行线是可以相交的。我们用齐次坐标描述投影几何。 可以看到，虽然齐次坐标的表现形式不同，但都对应同一个欧氏空间中的点$(\frac{1}{3},\frac{2}{3})$。 两条平行线可以相交考虑： \begin{cases} Ax+By+C=0\\ Ax+By+D=0 \end{cases}由于C不等于D，所以上述两条直线平行，没有解。 在齐次坐标中： \begin{cases} A\frac{x}{w}+B\frac{y}{w}+C=0\\ A\frac{x}{w}+B\frac{y}{w}+D=0 \end{cases} \rightarrow \begin{cases} Ax+By+Cw=0\\ Ax+By+Dw=0 \end{cases}我们可以得到一个解（x,y,0）,这表示两条直线会在无穷远处相交。 齐次坐标下的点与向量齐次坐标系下的(x,y,w)就是2D坐标下的(x/w,y/w,1) 点表示：$(x,y,1)^T$ 向量表示：$(x,y,0)^T$ 向量的齐次坐标w为0是为了保护向量不会进行位移变换，向量的位移没有意义。 在齐次坐标下（着重注意w的值为0还是1）： 向量+向量=向量； 点-点=向量（点的两个w相减为0了）； 点+向量=点（相当于点按照向量进行了移动）； 点+点=中点； 比如有点A(1,2,1)、点B(1,6,1) 两个点相加有(2,8,2)，之后我们要把w化为1，所以所有坐标分量同时除2（w值），就得到 （1,4,1）就是点A与点B的中点。 组合变换（Composing Transforms） 从A变换至B的方案 显然不对，位移变换对旋转变换产生了影响。 先位移再缩放，位移的向量也会同样被缩放。 综上，变换顺序(右乘优先)： Matrix_{组合}=Matrix_{位移}*Matrix_{旋转}*Matrix_{缩放}*点比方说，通过变换希望获得的结果可能是： 将一个放在原点的物体（比方说可乐罐）移动到（30，50），让它自身倾斜 45 度，再放大 2 倍。 而不希望的结果是： 和本地坐标轴成角度的缩放（会导致扭曲，像踩扁的可乐罐）。 下图为旋转30度，x轴放大2倍，y轴缩小至0.5倍。 绕自己几何中心以外位置的原点的旋转 （地球公转式） 和缩放。 而颠倒了上述变换顺序就会得到这样不自然的结果。具体的说： 当缩放在旋转之后进行时，会发生现象1。 当缩放和旋转在平移之后进行时会发生现象2。 这时因为： 在物体刚刚放入世界坐标系的时候使用的是本地坐标，也就是本地和全局坐标系的原点和坐标轴都是重合的（当然两者分别使用了左右手坐标系时除外 - 那是BUG），此时所有物体都“把世界坐标系当做自己的本地坐标系”。 而经过了坐标变换之后： 缩放变换不改变坐标轴的走向，也不改变原点的位置，所以两个坐标系仍然重合。 旋转变换改变坐标轴的走向，但不改变原点的位置，所以两个坐标系坐标轴不再处于相同走向。 平移变换不改变坐标轴走向，但改变原点位置，两个坐标系原点不再重合。 这样就可以解释问什么缩放不能在旋转之后，而缩放和旋转都不能在平移之后了。 于是没有问题的顺序只能是 缩放 -&gt; 旋转 -&gt; 平移 。 3D变换（3D Transformations）缩放 位移 旋转缩放 Scale: \left[ \begin{matrix} S1&0&0&0\\ 0&S2&0&0\\ 0&0&S3&0\\ 0&0&0&1\\ \end{matrix} \right] · \left( \begin{matrix} x\\ y\\ z\\ 1\\ \end{matrix} \right) = \left( \begin{matrix} S1*x\\ S2*y\\ S3*z\\ 1\\ \end{matrix} \right)位移 Translation: \left[ \begin{matrix} 1&0&0&Tx\\ 0&1&0&Ty\\ 0&0&1&Tz\\ 0&0&0&1\\ \end{matrix} \right] · \left( \begin{matrix} x\\ y\\ z\\ 1\\ \end{matrix} \right) = \left( \begin{matrix} x+Tx\\ y+Ty\\ z+Tz\\ 1\\ \end{matrix} \right)旋转 Rotation: 沿x轴： \left[ \begin{matrix} 1&0&0&0\\ 0&\cos\theta&-\sin\theta&0\\ 0&\sin\theta&\cos\theta&0\\ 0&0&0&1\\ \end{matrix} \right] · \left( \begin{matrix} x\\ y\\ z\\ 1\\ \end{matrix} \right) = \left( \begin{matrix} x\\ \cos\theta·y-\sin\theta·z\\ \sin\theta·y +\cos\theta·z\\ 1\\ \end{matrix} \right)沿y轴： \left[ \begin{matrix} \cos\theta&0&\sin\theta&0\\ 0&1&0&0\\ -\sin\theta&0&\cos\theta&0\\ 0&0&0&1\\ \end{matrix} \right] · \left( \begin{matrix} x\\ y\\ z\\ 1\\ \end{matrix} \right) = \left( \begin{matrix} \cos\theta·x+\sin\theta·z\\ y\\ -\sin\theta·x +\cos\theta·z\\ 1\\ \end{matrix} \right)注意到沿y轴的旋转是其x,z轴的反方向的旋转（在2D旋转中，推导了旋转矩阵是正交矩阵） 沿z轴： \left[ \begin{matrix} \cos\theta&-\sin\theta&0&0\\ \sin\theta&\cos\theta&0&0\\ 0&0&1&0\\ 0&0&0&1\\ \end{matrix} \right] · \left( \begin{matrix} x\\ y\\ z\\ 1\\ \end{matrix} \right) = \left( \begin{matrix} \cos\theta·x-\sin\theta·y\\ \sin\theta·x +\cos\theta·y\\ z\\ 1\\ \end{matrix} \right)视图变换（Viewing transformation）上述所讲述的缩放、位移、旋转是Model变换，目的是将物体从局部空间（Local Space）变换至世界空间（World Space）中去。 摄像机变换（Camera Transformation） 确定一个摄像机我们需要定义好： 位置（position）: $\overrightarrow{e}$ 注视方向（Look-at/gaze direction）: $\overrightarrow{g}$ 上向量（Up direction）：$\overrightarrow{t}$ 摄像机变换的目的是得到所有可视物体与摄像机的相对位置，我们需要做的是将摄像机的位置$\overrightarrow{e}$变换至原点，注视方向 $\overrightarrow{g}$ 变换至-z方向，上向量$\overrightarrow{t}$变换至y方向。所有物体要与摄像机做相同的变换。 第一步：将摄像机的位置移动到原点，只需要将现在摄像机的位置$(x_e,y_e,z_e)$做$T_x(-x_e)、T_y(-y_e)、T_z(-z_e)、$的位移变换即可: T_{camera}= \left[ \begin{matrix} 1&0&0&-x_e\\ 0&1&0&-y_e\\ 0&0&1&-z_e\\ 0&0&0&1\\ \end{matrix} \right]第二步：将注视方向 $\overrightarrow{g}$ 旋转至-z方向，上向量$\overrightarrow{t}$旋转至y方向, $\overrightarrow{g}\cross\overrightarrow{t}$ 旋转至x方向。 这个变换并不好做，但是我们注意到将x,y,z基向量旋转至$\overrightarrow{g}\cross\overrightarrow{t}、\overrightarrow{t}、-\overrightarrow{g}、$ 是好做的。我们将基向量变换至摄像机向量的矩阵取逆，就是我们所求的矩阵。 x,y,z的向量矩阵： M_{xyz}= \left[ \begin{matrix} 1&0&0&0\\ 0&1&0&0\\ 0&0&1&0\\ 0&0&0&1\\ \end{matrix} \right]很容易的可以得到旋转矩阵： R^{-1}_{camera}= \left[ \begin{matrix} x_{\hat{g}\cross\hat{t}}&x_t&x_{-g}&0\\ y_{\hat{g}\cross\hat{t}}&y_t&y_{-g}&0\\ z_{\hat{g}\cross\hat{t}}&z_t&z_{-g}&0\\ 0&0&0&1\\ \end{matrix} \right]将旋转矩阵$R^{-1}_{camera}$乘x,y,z的向量矩阵$M_{xyz}$是可以得到摄像机向量矩阵的！ 因此将$R^{-1}_{camera}$ 取逆即可，我们又知道旋转矩阵是正交矩阵，其逆等于其转置，因此就有： R_{camera}= \left[ \begin{matrix} x_{\hat{g}\cross\hat{t}}&y_{\hat{g}\cross\hat{t}}&z_{\hat{g}\cross\hat{t}}&0\\ x_t&y_t&z_t&0\\ x_{-g}&y_{-g}&z_{-g}&0\\ 0&0&0&1\\ \end{matrix} \right]将上述两步结合，我们就得到了摄像机变换： M_{camera}= \left[ \begin{matrix} x_{\hat{g}\cross\hat{t}}&y_{\hat{g}\cross\hat{t}}&z_{\hat{g}\cross\hat{t}}&0\\ x_t&y_t&z_t&0\\ x_{-g}&y_{-g}&z_{-g}&0\\ 0&0&0&1\\ \end{matrix} \right] * \left[ \begin{matrix} 1&0&0&-x_e\\ 0&1&0&-y_e\\ 0&0&1&-z_e\\ 0&0&0&1\\ \end{matrix} \right]投影变换（Projection transformation）我们要获取摄像机所看到的内容，这就需要投影变换。将摄像机所看到的内容投影变换到$[-1,1]^3$ 正方体空间中，方便最后显示到屏幕上。 投影变换有两种，不带透视的正交投影，与带透视的透视投影。 正交投影（Orthographic Projection）假设一个摄像机所看到的内容被一个长方体所包含，做投影变换的目的是将这个长方体变换至标准正方体（“canonical” cube）（正方体为$[-1,1]^3$）。 定义这个长方体的 左平面l，右平面r，[l,r] 下平面b，上平面t，[b,t] 远平面f，近平面n，[f,n] 接下来将[l,r]、[f,n]、[b,t] 三个区间变换至[-1,1]上 第一步：将长方体的中心$(\frac{l+r}{2},\frac{b+t}{2},\frac{f+n}{2})$平移到坐标原点处。 T_{ortho}= \left[ \begin{matrix} 1&0&0&-\frac{l+r}{2}\\ 0&1&0&-\frac{b+t}{2}\\ 0&0&1&-\frac{f+n}{2}\\ 0&0&0&1\\ \end{matrix} \right]第二步：将长方体缩放为$[-1,1]^3$的标准正方体，会对长方体内的物体产生非等比缩放从而产生物体的变形，不过不用担心，我们会在视口变换中处理这个问题。 左右平面的距离为：$r-l$ 。想要变换至$[-1,1]$上，所需的操作为$(r-l)*\frac{2}{r-l}$。上下，前后面同理，因此缩放矩阵为： S_{ortho}= \left[ \begin{matrix} \frac{2}{r-l}&0&0&0\\ 0&\frac{2}{t-b}&0&0\\ 0&0&\frac{2}{n-f}&0\\ 0&0&0&1\\ \end{matrix} \right]综上，这个正交投影变换矩阵为： M_{ortho}= \left[ \begin{matrix} \frac{2}{r-l}&0&0&0\\ 0&\frac{2}{t-b}&0&0\\ 0&0&\frac{2}{n-f}&0\\ 0&0&0&1\\ \end{matrix} \right] * \left[ \begin{matrix} 1&0&0&-\frac{l+r}{2}\\ 0&1&0&-\frac{b+t}{2}\\ 0&0&1&-\frac{f+n}{2}\\ 0&0&0&1\\ \end{matrix} \right]透视投影（Perspective Projection）我们将平截头体远平面向里挤压，使其变成长方体，然后再对长方体使用正交投影变换。 我们规定“挤压”的规则： 近平面上的点坐标不会发生改变 远平面上的点z坐标不会发生改变。 远平面的中心坐标不会发生改变。 平截头体的侧视图（只展示了上半部分）如下： 近平面上的点为(x’,y’,z’)，远平面上的点为(x,y,z),最左边的点为摄像机的点，也是坐标原点。 根据相似三角形，很容易得到： \frac{n}{z}=\frac{y'}{y}\\ y'=\frac{n}{z}*yy’的对应规则并不特指在远平面上的点，在平截头体里的y坐标都符合这个规则。 同理，可以从上视图里推出x’与x的关系。性质与y’与y的关系一样。 x'=\frac{n}{z}*x因此对任意一点(x,y,z,1)，我们“挤压”后有如下变换（只关注上下如何变换，先不关注前后的变换）： \left[ \begin{matrix} x\\ y\\ z\\ 1\\ \end{matrix} \right] \rightarrow \left[ \begin{matrix} x'\\ y'\\ z'\\ 1\\ \end{matrix} \right] \rightarrow \left[ \begin{matrix} \frac{n*x}{z}\\ \frac{n*y}{z}\\ unknow\\ 1\\ \end{matrix} \right] = \left[ \begin{matrix} n*x\\ n*y\\ unknow\\ z\\ \end{matrix} \right] \tag{3}最后一个等号的成立，是根据齐次坐标的性质。两者表示3维空间中同一个点。 我们可以推算出从透视投影到正交投影变换的一部分： M_{persp\rightarrow ortho}= \left[ \begin{matrix} n&0&0&0\\ 0&n&0&0\\ ?&?&?&?\\ 0&0&1&0\\ \end{matrix} \right]接下来，开始推导z坐标的变换。我们不清楚平截头体内的点z坐标的变换（根据最后的结论会发现内部点的z坐标会发生改变），但是我们规定了近平面(x,y,n,1)与远平面(x,y,f,1)的z坐标不会发生改变。 对于近平面上的点(x,y,n,1),经过$M_{persp\rightarrow ortho}$变换后点坐标不会发生改变，仍然是(x,y,n,1)，有： M_{persp\rightarrow ortho}* \left[ \begin{matrix} x\\ y\\ n\\ 1\\ \end{matrix} \right] = \left[ \begin{matrix} x\\ y\\ unknow\\ 1\\ \end{matrix} \right] = \left[ \begin{matrix} x\\ y\\ n\\ 1\\ \end{matrix} \right] == \left[ \begin{matrix} n*x\\ n*y\\ n^2\\ n\\ \end{matrix} \right] \tag{4}==号的成立是因为齐次坐标的性质，两边仍然表示同一个点。同时乘以n是为了与（3）式表现形式一样，(3)式的x,y坐标与(4)式的x,y坐标的值都为nx,ny。w值都为点的z坐标。 我们现在可以推导$M_{persp\rightarrow ortho}$的第三行值满足： \left[ \begin{matrix} 0&0&A&B \end{matrix} \right] * \left[ \begin{matrix} x\\ y\\ n\\ 1\\ \end{matrix} \right] =n^2可以得到： A*n+B=n^2别忘了，我们还有规定远平面上的点z坐标变换前后不发生改变，我们取远平面上的中心点(0,0,f,1)进行变换。 M_{persp\rightarrow ortho}* \left[ \begin{matrix} 0\\ 0\\ f\\ 1\\ \end{matrix} \right] = \left[ \begin{matrix} 0\\ 0\\ unknow\\ 1\\ \end{matrix} \right] = \left[ \begin{matrix} 0\\ 0\\ f\\ 1\\ \end{matrix} \right] == \left[ \begin{matrix} 0\\ 0\\ f^2\\ f\\ \end{matrix} \right]道理与近平面上的点变换一样。 \left[ \begin{matrix} 0&0&A&B \end{matrix} \right] * \left[ \begin{matrix} 0\\ 0\\ f\\ 1\\ \end{matrix} \right] =f^2可以得到： A*f+B=f^2联立： \begin{cases} A*n+B=n^2\\ A*f+B=f^2 \end{cases}解得： \begin{cases} A=n+f\\ B=-n*f \end{cases}综上$M_{persp\rightarrow ortho}$为： M_{persp\rightarrow ortho}= \left[ \begin{matrix} n&0&0&0\\ 0&n&0&0\\ 0&0&n+f&-n*f\\ 0&0&1&0\\ \end{matrix} \right]之后，在将”挤压”后的平截头体做正交投影即可。 因此，透视投影变换为： M_{persp}=M_{ortho}*M_{persp\rightarrow ortho}= \left[ \begin{matrix} \frac{2}{r-l}&0&0&0\\ 0&\frac{2}{t-b}&0&0\\ 0&0&\frac{2}{n-f}&0\\ 0&0&0&1\\ \end{matrix} \right] * \left[ \begin{matrix} 1&0&0&-\frac{l+r}{2}\\ 0&1&0&-\frac{b+t}{2}\\ 0&0&1&-\frac{f+n}{2}\\ 0&0&0&1\\ \end{matrix} \right] * \left[ \begin{matrix} n&0&0&0\\ 0&n&0&0\\ 0&0&n+f&-n*f\\ 0&0&1&0\\ \end{matrix} \right] 可以发现内部点的z坐标会发生改变，近远面上的点z坐标不会发生改变。 对平截头体进行描述平截头体的前后面，near与far直接定义。 而左右与上下面通过宽高比(aspect)与竖直的可视角度(fovY)定义。 侧视图： 很显然： \tan{\frac{fovY}{2}}=\frac{t}{\left| n \right|}\\ t=\tan{\frac{fovY}{2}}*\left| n \right|这样就定义了上下面。 再根据宽高比定义左右面。有： aspect = \frac{r}{t}\\ r=t*aspect=\tan{\frac{fovY}{2}}*\left| n \right|*aspect视口变换（Viewport Transform）将投影变换得到标准正方体[-1,1]^3 变换到屏幕（screen）上。 屏幕（screen）图形学中定义屏幕是一个二维数组，元素为像素。像素的表示为rgb。 屏幕空间： 规定（可以有多种规定）： 屏幕的左下角为原点。 像素的坐标为（x,y）,为像素的左下角，比如蓝色的像素坐标为（2,1）。 像素坐标的范围为(0,0)到(width-1,height-1)。 像素的中心为（x+0.5,y+0.5）。 像素的覆盖范围(0,0)到(width,height)。 视口变化接下来就要把投影变换得到标准正方体[-1,1]^3 变换到屏幕上去了。 我们暂时忽略标准正方体的z坐标。 现在我们要把标准正方体（型）$[-1,1]^2$的坐标映射到屏幕上[0,width]*[0,hight]的空间中。 首先把标准正方型缩放到与屏幕一样大小： M_{view\_scale} = \left[ \begin{matrix} \frac{width}{2}&0&0&0\\ 0&\frac{height}{2}&0&0\\ 0&0&1&0\\ 0&0&0&1\\ \end{matrix} \right]再把正方形的左下角位移到屏幕原点(0,0)处: M_{view\_translation} \left[ \begin{matrix} 1&0&0&\frac{width}{2}\\ 0&1&0&\frac{height}{2}\\ 0&0&1&0\\ 0&0&0&1\\ \end{matrix} \right]综上，视口变换矩阵为： M_{view} = M_{view\_translation}*M_{view\_scale} = \left[ \begin{matrix} \frac{width}{2}&0&0&\frac{width}{2}\\ 0&\frac{height}{2}&0&\frac{height}{2}\\ 0&0&1&0\\ 0&0&0&1\\ \end{matrix} \right]总结将一个在局部空间定义好的物体，最终显示到屏幕上。 需要经过： 模型矩阵变换至世界空间。 将物体连同定义好的摄像机经过观察（摄像机）矩阵变换到观察空间，也就是摄像机所看到的内容。 摄像机所看到的内容经过投影矩阵变换将其变换至标准正方体中。 将标准正方体经过视口矩阵变换到屏幕上。 V_{screen}=M_{viewport}*M_{projection}*M_{view}*M_{model}*V_{local}]]></content>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫]]></title>
    <url>%2F2021%2F10%2F29%2F%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[获取单个页面信息获取HTML123from urllib.request import urlopenhtml = urlopen("http://pythonscraping.com/pages/page1.html")print(html.read()) urllib是自带库，不用安装 抓取HTML中的所有标签安装beautifulsoup4库。https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html 打印dom对象 12345from urllib.request import urlopenfrom bs4 import BeautifulSoup as bshtml = urlopen("http://pythonscraping.com/pages/page1.html")htmlObj = bs(html.read(),"html.parser")print(htmlObj) 捕捉错误123456try: html = urlopen("http://pythonscraping.com/pages/page.html") htmlObj = bs(html.read(), "html.parser") print(htmlObj)except HTTPError as e: print(e) 抓取HTML中的指定标签12345678try: html = urlopen("http://pythonscraping.com/pages/warandpeace.html") htmlObj = bs(html.read(), "html.parser") nameList = htmlObj.findAll("span",&#123;"class":"green"&#125;) #有class = "green" 的 span标签 for name in nameList: print(name.get_text())except HTTPError as e: print(e) get_text()会除去html文档中的所有标签，最好用在最里层标签，在外层标签使用会把内层标签删除掉。 findAll(tag, attributes, recursive, text, limit, keywords) tag: 一个标签的名称或多个标签名称组成的 Python 列表做标签参数。 1htmlObj.findAll(["h1","h2","span"]) attributes: 字典封装一个标签的若干属性和对应的属性值。 1htmlObj.findAll(["span"],&#123;"class":&#123;"green","red"&#125;&#125;) =&gt; 抓取&lt;span class=&quot;green&quot;&gt; 与 &lt;span class = &quot;red&quot;&gt; 的标签。 recursive: 递归参数 默认True 查找子标签以及子标签的子标签……；如果为False只查找文档的一级标签。 text: 用表签的文本内容查找。 1htmlObj.findAll(["span"],text="the prince") 查找全部span标签中有“the prince”（完全匹配）的标签。 limit: 查找几个标签。 keyword: 查找具有指定属性的标签。 1htmlObj.findAll(id=&quot;text&quot;) =&gt; 查找标签中有属性id=&quot;text&quot; 的标签。可以被第二个参数attributes替代。 处理树形结构获取第一个标签： bsObj.标签 获取第一个标签后代： bsObj.标签.findAll(“标签”) —- 下面这些都是属性 不是标签 查兄弟标签： next_siblings;获取的兄弟标签不含自身，而且只能查后面的标签。 previous_siblings;获取前面的兄弟标签。 可以去掉s只获取一个标签而不是生成器对象。 查父标签： parents。获取所有父级标签的生成器对象。 可以去掉s只获取一个父级标签。 正则表达式https://www.liaoxuefeng.com/wiki/1016959663602400/1017639890281664 直接用re.complie(regexp)当findAll的参数 抓取多页面获取页面中的超链接获取标签的属性12print(htmlObj.findAll("a")[1])print(htmlObj.findAll("a")[1].attrs) 抓取链接12345678try: html = urlopen("https://baike.baidu.com/item/%E5%90%B4%E4%BA%AC/8698?fr=aladdin") htmlObj = bs(html.read(), "html.parser") for link in htmlObj.findAll("a"): if 'href' in link.attrs: #判断link.attrs中有没有href键值 print(link.attrs["href"])except HTTPError as e: print(e) 分析外链定义规则 /item/ 开头 12345678try: html = urlopen("https://baike.baidu.com/item/%E5%90%B4%E4%BA%AC/8698?fr=aladdin") htmlObj = bs(html.read(), "html.parser") links = htmlObj.findAll("a",&#123;"href":re.compile("^(/item/)")&#125;) for link in links: print(link.attrs["href"])except HTTPError as e: print(e) 递归遍历网站获取链接 123456789101112131415161718pages = set()def getLinks(url): global pages print(url+"---") if not url.isalnum() : #对中文url进行url编码 if "%" not in url: url = urllib.parse.quote(url) print("https://baike.baidu.com"+url) html = urlopen("https://baike.baidu.com"+url) htmlobj = bs(html.read(),"html.parser") print(htmlobj.head.title.get_text()) for link in htmlobj.findAll("a",&#123;"href":re.compile("^(/item/)")&#125;): if "href" in link.attrs: if link.attrs["href"] not in pages: newPage = link.attrs["href"] pages.add(newPage) getLinks(newPage)getLinks("/item/python") url编码： 需要对符号和中文进行编码方便传输，英文和数字进行url编码还是其本身。 使用API1234from urllib.request import urlopen# bilibili up主粉丝数response = urlopen("https://api.bilibili.com/x/relation/stat?vmid=546195&amp;jsonp=jsonp")print(response.read()) response = b&#39;&lt;h1&gt;Hello World!&lt;/h1&gt;&#39; # b&#39; &#39; 表示这是一个 bytes 对象 作用： b” “前缀表示：后面字符串是bytes 类型。 用处： 网络编程中，服务器和浏览器只认bytes 类型数据。 12&gt; response.read().decode("utf-8") # 解析为utf-8编码&gt; 解析json对象json是默认库，不用安装。 12345from urllib.request import urlopenimport jsonresponse = urlopen("https://api.bilibili.com/x/relation/stat?vmid=546195&amp;jsonp=jsonp")jsonObj = json.loads(response.read().decode("utf-8"))print(jsonObj.get("data").get("follower")) json转换成字典，json数组转换成列表，json字符串转换成python字符串。 123456#不对json进行字符编码也可以from urllib.request import urlopenimport jsonresponse = urlopen("https://api.bilibili.com/x/relation/stat?vmid=546195&amp;jsonp=jsonp")jsonObj = json.loads(response.read())print(jsonObj.get("data")) 数据存储下载网站上的文件而不是其URL1234567891011121314151617181920212223# -- coding: utf-8 --from urllib.request import urlretrievefrom urllib.request import urlopenfrom bs4 import BeautifulSoup as bsimport rehtml = urlopen("https://www.bilibili.com/")bsObj = bs(html.read(),"html.parser").findAll("img",&#123;"src":re.compile("/")&#125;)print(os.path.abspath("."))print(bsObj)list = [x for x in range(100)]i=0for link in bsObj: print(link) flag = link.attrs["src"].endswith(".jpg") if flag: tail = "jpg" else: tail = "png" if "https:" in link.attrs["src"]: urlretrieve(link.attrs["src"],str(list[i])+"."+tail) else: urlretrieve("https:"+link.attrs["src"],str(list[i])+"."+tail) i=i+1 urlretrieve(arg1,arg2) arg1: 资源url地址 arg2: 文件要保存的位置 将数据保存至数据库中。PyMySQL 读取文档从页面的meta标签中查看编码格式 读取csv、pdf、docx 略 表单Request库负责处理复杂的http请求、cookie，header等内容。 发送post请求 123456import requestsparams= &#123;"firstname":"Ryan", "lastname":"Xzer"&#125;r = requests.post("http://pythonscraping.com/pages/files/processing.php",params)print(r.text) #响应的内容 上传文件 1234&lt;form action="processing2.php" method="post" enctype="multipart/form-data"&gt; Submit a jpg, png, or gif: &lt;input type="file" name="image"&gt;&lt;br&gt; &lt;input type="submit" value="Upload File"&gt;&lt;/form&gt; 12345import requestsfiles = &#123;'uploadFile': open('../files/Python-logo.png', 'rb')&#125;r = requests.post("http://pythonscraping.com/pages/processing2.php", files=files)print(r.text) 处理cookie123456789101112# -- coding: utf-8 --import requestsparams= &#123;"username":"12gg", "password":"password"&#125;# 在登录时获取cookier = requests.post("http://pythonscraping.com/pages/cookies/welcome.php",params)print(r.text)print(r.cookies.get_dict())# 之后的请求携带cookier=requests.get("http://pythonscraping.com/pages/cookies/profile.php", cookies = r.cookies)print(r.text) 第二次请求： 用session处理12345678910import requestssession = requests.Session()params= &#123;"username":"12gg", "password":"password"&#125;s =session.post("http://pythonscraping.com/pages/cookies/welcome.php",params)print(s.text)print(s.cookies.get_dict())s = session.get("http://pythonscraping.com/pages/cookies/profile.php")print(s.text) 会话（session）对象（调用 requests.Session() 获取）会持续跟踪会话信 息，像 cookie、header，甚至包括运行 HTTP 协议的信息，比如 HTTPAdapter（为 HTTP 和 HTTPS 的链接会话提供统一接口）。 采集JavaScript在使用JavaScript的网站中，有些dom内容是动态创建的，前面的技术并不能采集。 解决方案：直接从JavaScript代码中采集内容。 用python运行JavaScript，直接采集你在浏览器界面看到的内容。 使用Seleninum与 Chrome headlessSeleninum是个自动化测试脚本，可以模仿人的操作，比如点击按钮，输入表单等。需要与第三方浏览器配合使用。 Chrome headless 是一个浏览器，但是叫“无头浏览器”，没有用户界面，但是可以输出界面截图。会把网站加载到内存中执行JavaScript。就是一个没有用户界面的浏览器。 安装Chrome headless(win)在Chrome地址栏中输入chrome://version/ 查看版本（需要60以上） 去https://chromedriver.chromium.org/ 下载对应版本的无头浏览器。 pip 安装 Seleninum 使用将ChromeDriver.exe放在与脚本同一个目录下。 1234567891011121314from selenium import webdriverfrom bs4 import BeautifulSoup as bsimport time# 初始化无头浏览器参数chrome_options = webdriver.ChromeOptions()chrome_options.add_argument("--headless")chrome_options.add_argument("--disable-gpu")# 获取用户看到的界面driver = webdriver.Chrome(options=chrome_options)driver.get("http://pythonscraping.com/pages/javascript/ajaxDemo.html")time.sleep(10) # 等待一会儿让ajax加载完毕# 转换为beautifulsoup4对象htmlObj = bs(driver.page_source,"html.parser")print(htmlObj) #完整界面 关键在于第11行，等待的时间无法正确确认。 改进监听页面中出现某个元素之后，进行抓取。 123456789101112131415161718from selenium import webdriverfrom bs4 import BeautifulSoup as bsfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC# 初始化无头浏览器参数chrome_options = webdriver.ChromeOptions()chrome_options.add_argument("--headless")chrome_options.add_argument("--disable-gpu")# 获取用户看到的界面driver = webdriver.Chrome(options=chrome_options)driver.get("http://pythonscraping.com/pages/javascript/ajaxDemo.html")try: element = WebDriverWait(driver,10).until(EC.presence_of_element_located((By.ID,"loadedButton")))finally: # 转换为beautifulsoup4对象 htmlObj = bs(driver.page_source,"html.parser") print(htmlObj) #完整界面 关键在于第14行，监听页面上出现带有id=&quot;loadedButton&quot;的元素之后再执行后续代码，超时时间为10秒。此操作称之为隐式等待。 设定好明确等待时间的称之为显示等待。 Seleninum可以执行js脚本 12js = 'var action=document.documentElement.scrollTop=100000' #滑动滚动条driver.execute_script(js) 复杂元素使用Xpath定位等待。 https://zhuanlan.zhihu.com/p/29436838 1element = WebDriverWait(driver,60).until(EC.presence_of_element_located((By.XPATH,'//div[@class="loading-state]'))) 爬取B站评论区脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -- coding: utf-8 --from selenium import webdriverfrom bs4 import BeautifulSoup as bsfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC# 初始化无头浏览器参数chrome_options = webdriver.ChromeOptions()chrome_options.add_argument("--headless")chrome_options.add_argument("--disable-gpu")# 获取用户看到的界面driver = webdriver.Chrome(options=chrome_options)driver.get("https://www.bilibili.com/video/BV123411y74P")# js = 'var action=document.documentElement.scrollTop=100000'# driver.execute_script(js)driver.execute_script(""" (function () &#123; var y = document.body.scrollTop; var step = 100; window.scroll(0, y); function f() &#123; if (y &lt; document.body.scrollHeight) &#123; y += step; window.scroll(0, y); setTimeout(f, 50); &#125; else &#123; window.scroll(0, y); document.title += "scroll-done"; &#125; &#125; setTimeout(f, 1000); &#125;)(); """)try: element = WebDriverWait(driver,60).until(EC.presence_of_element_located((By.XPATH,'//div[@class="loading-state" and contains(text(),"没有更多评论")]'))) print(element)finally: # 转换为beautifulsoup4对象 htmlObj = bs(driver.page_source,"html.parser") # print(htmlObj.findAll("p",&#123;"class":"text"&#125;)) #完整界面 for t in htmlObj.findAll("p",&#123;"class":"text"&#125;): print(t.get_text()) driver.close()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决跨域请求session值变化的问题]]></title>
    <url>%2F2021%2F06%2F29%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82session%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[问题描述： 前端环境：vue-cli 本机8080端口 后端环境： tomcat 本机8079端口 前端ajax请求无法传达后端，浏览器关闭同源策略后，后端的sessionid在不同的控制器变化，提示无法建立会话，并且前端浏览器没有cookie存储， 原理:略。 解决方案： 前端配置 在main.js里设置 1axios.defaults.withCredentials=true, 后端配置： 控制器类加： 1@CrossOrigin(origins = &quot;*&quot;, maxAge = 3600) maven下下载插件 12345&lt;dependency&gt; &lt;groupId&gt;org.ebaysf.web&lt;/groupId&gt; &lt;artifactId&gt;cors-filter&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt; 在web.xml配置 1234567891011121314151617181920212223242526272829&lt;!-- CORS--&gt; &lt;filter&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;!--类位置一般要改--&gt; &lt;filter-class&gt;org.ebaysf.web.cors.CORSFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt; &lt;param-value&gt;GET, POST, HEAD, PUT, DELETE&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt; &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified, Access-Control-Allow-Origin&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt; &lt;param-value&gt;Set-Cookie&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CORS &lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2021%2F06%2F29%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表（sequence list）是最基本、最简单、也是最常用的一种数据结构。 定义123456789101112131415161718192021222324252627ADT List&#123; 数据对象：D=&#123;$a_i$|ai∈ElemSet,i=1,2,3...n&gt;=0&#125;\\n是表长，为0时为空表 数据关系：R1=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=1,2,3....n&#125; 常用基本操作： 初始化操作： InitList(&amp;L) 无--构造一个空线性表L 引用型操作： ListEmpty(L) 线性表L已存在--判断L是否为空表 ListLength(L) 线性表L已存在--返回L中数据的个数 GetElem(L,i,&amp;e) 线性表L已存在,0&lt;=i&lt;=ListLength(L)--用e返回第i个元素的值 LocateElem(L,e，compare()) 线性表L已存在,compare()时数据元素判定函数--返回L中第一个与e满足compare()关系的位序，若不存在返回0. 加工型操作： ListInsert(&amp;L,i,e) 线性表L已存在,0&lt;=i&lt;=ListLength(L)+1--在L中第i个位置插入新的元素e,L的长度加1 ListDelte(&amp;L,i,&amp;e) 线性表L已存在,0&lt;=i&lt;=ListLength(L)--删除L中的第i个元素，用e返回其值，L的长度减1. 线性表（顺序结构）的存储结构 12345678910111213#define List_Init_Size 100//线性表存储空间的初始分配量（也就是最多能存多少个的值，实际用时不一定会超过这个值，超过了就要报错或者增加最长值）#define ListIncrement 10 //线性表存储空间的分配增量（其实就是初始有几个值）typedef struct&#123; Element *elem;//存储空间的基地址（相当于数组名） int length; //当前长度 int listSize;//当前分配的存储容量（以sizeof(ElemeType)为单位）（就相当于数组的角标）&#125;SqList;//因此也可以这样定义typedef struct&#123; Element date[100]; int length;&#125; 线性表（链式结构—单向链表）的存储结构 12345typedef struct LNode&#123; ElemType data; struct Lnode *next;&#125;LNode,*LinkList;//LinkList 专门用来设置头节点，LinkList head == LNode *head 习题顺序表应用1：多余元素删除之移位算法Time Limit: 1000 ms Memory Limit: 650 KiB Problem Description 一个长度不超过10000数据的顺序表，可能存在着一些值相同的“多余”数据元素（类型为整型），编写一个程序将“多余”的数据元素从顺序表中删除，使该表由一个“非纯表”（值相同的元素在表中可能有多个）变成一个“纯表”（值相同的元素在表中只保留第一个）。要求： 1、必须先定义线性表的结构与操作函数，在主函数中借助该定义与操作函数调用实现问题功能； 2、本题的目标是熟悉顺序表的移位算法，因此题目必须要用元素的移位实现删除； nput 第一行输入整数n，代表下面有n行输入；之后输入n行，每行先输入整数m，之后输入m个数据，代表对应顺序表的每个元素。 Output 输出有n行，为每个顺序表删除多余元素后的结果 Sample Input 1234545 6 9 6 8 93 5 5 55 9 8 7 6 510 1 2 3 4 5 5 4 2 1 3 Sample Output 12346 9 859 8 7 6 51 2 3 4 5 Hint Source 主要考察数组的删除 （ListDelte），数组删除某个元素，要把其后的元素往前移动一位，要求a[i]=a[i+1] 思路：先固定住a[i]，从a[i+1]到a[length-1]分别与a[i]比较，相同的话，返回其角标，交给删除函数进行删除，然后指针前移一位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; int data[10001]; int length;&#125;SqList;void CreateSql(SqList *a,int n);void ShowSql(SqList *a);void DelSql(SqList *a, int i);int SearchSql(SqList *a, int j);int main()&#123; int n, m, i, j, q, f=-1; SqList a; scanf("%d", &amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;m); CreateSql(&amp;a,m); for(j=0;j&lt;a.length;j++)&#123; for(q=j+1;q&lt;a.length;q++)&#123; f=SearchSql(&amp;a,j); if(f==-1)&#123; break; &#125; else&#123; DelSql(&amp;a,f); q--;//注意这个q--的用法，删除完不前置q,就会把a[q]位置的元素漏掉 &#125; &#125; &#125; ShowSql(&amp;a); a.length=0; &#125; return 0;&#125;//创建线性表void CreateSql(SqList *a,int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;a-&gt;data[i]); &#125; a-&gt;length=n;&#125;//删除第j个元素void DelSql(SqList *a, int i)&#123; int j; for(j=i;j&lt;a-&gt;length-1;j++)&#123; a-&gt;data[j]=a-&gt;data[j+1]; &#125; a-&gt;length--;&#125;//查询J位置后的重复元素int SearchSql(SqList *a, int j)&#123; int i; for(i=j+1;i&lt;a-&gt;length;i++)&#123; if(a-&gt;data[i]==a-&gt;data[j])&#123; return i; &#125; &#125; return -1;&#125;//输出线性表void ShowSql (SqList *a)&#123; int i; for(i=0;i&lt;a-&gt;length;i++)&#123; printf("%d%c", a-&gt;data[i], i==a-&gt;length-1?'\n':' '); &#125;&#125; 值得注意的是，这里在函数里对线性表操作，必须把地址给传进去，单纯的结构体名不是地址，只代表一个变量。 顺序表应用2：多余元素删除之建表算法Time Limit: 3 ms Memory Limit: 600 KiB Problem Description 一个长度不超过10000数据的顺序表，可能存在着一些值相同的“多余”数据元素（类型为整型），编写一个程序将“多余”的数据元素从顺序表中删除，使该表由一个“非纯表”（值相同的元素在表中可能有多个）变成一个“纯表”（值相同的元素在表中只保留第一个）。要求： 1、必须先定义线性表的结构与操作函数，在主函数中借助该定义与操作函数调用实现问题功能； 2、本题的目标是熟悉在顺序表原表空间基础上建新表的算法，要在原顺序表空间的基础上完成完成删除，建表过程不得开辟新的表空间； 3、不得采用原表元素移位删除的方式。 Input 第一行输入整数n，代表下面有n行输入；之后输入n行，每行先输入整数m，之后输入m个数据，代表对应顺序表的每个元素。 Output 输出有n行，为每个顺序表删除多余元素后的结果 Sample Input 1234545 6 9 6 8 93 5 5 55 9 8 7 6 510 1 2 3 4 5 5 4 2 1 3 Sample Output 12346 9 859 8 7 6 51 2 3 4 5 Hint Source 注意到此题限时非常短，而顺序表的删除与增加元素，要移动很多元素，非常的消耗时间，因此应该采用的是非顺序结构域（链表）存储数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123; int data; struct Lnode *next;&#125;Lnode,*LinkList;LinkList InitList(int n);//构造长度为n的线性表void ListDelete(LinkList q,LinkList p);void LocateElem(LinkList head, int k, LinkList p);void ShowLnode(LinkList head);int main()&#123; int n,m; LinkList head, p; scanf("%d", &amp;m); while(m--)&#123; scanf("%d", &amp;n); head=InitList(n); p=head-&gt;next; while(p!=NULL)&#123; LocateElem(head,p-&gt;data,p); p=p-&gt;next;//不要忘了往后移动 &#125; ShowLnode(head); &#125; return 0;&#125;//尾叉法建立链表LinkList InitList(int n)&#123; LinkList head, p, tail; int m; head=(LinkList)malloc(sizeof(Lnode)); head-&gt;next=NULL; tail=head; while(n--)&#123; p=(LinkList)malloc(sizeof(Lnode)); scanf("%d", &amp;m); p-&gt;next=tail-&gt;next; tail-&gt;next=p; tail=p; p-&gt;data=m; &#125; return head;&#125;//遍历链表并删除void LocateElem(LinkList head, int k,LinkList p)&#123; LinkList q,m; m=p; q=p; p=p-&gt;next; while(p!=NULL)&#123; if(p-&gt;data==k)&#123; q-&gt;next=p-&gt;next; free(p); p=q-&gt;next; &#125; else&#123; q=p; p=p-&gt;next; &#125; &#125; p=m; &#125;//展示链表void ShowLnode(LinkList head)&#123; LinkList p; p=head-&gt;next; while(p!=NULL)&#123; if(p-&gt;next==NULL)&#123; printf("%d\n", p-&gt;data); &#125; else&#123; printf("%d ",p-&gt;data); &#125; p=p-&gt;next; &#125;&#125; 这道题我在函数传参数时犯了一个错误，记录在https://misakasister.github.io/2018/10/06/C%E8%AF%AD%E8%A8%80%20%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E7%90%86%E8%A7%A3/ 顺序表应用3：元素位置互换之移位算法Time Limit: 1000 ms Memory Limit: 570 KiB Problem Description 一个长度为len(1&lt;=len&lt;=1000000)的顺序表，数据元素的类型为整型，将该表分成两半，前一半有m个元素，后一半有len-m个元素（1&lt;=m&lt;=len)，借助元素移位的方式，设计一个空间复杂度为O(1)的算法，改变原来的顺序表，把顺序表中原来在前的m个元素放到表的后段，后len-m个元素放到表的前段。注意：先将顺序表元素调整为符合要求的内容后，再做输出，输出过程只能用一个循环语句实现，不能分成两个部分。 Input 第一行输入整数n，代表下面有n行输入；之后输入n行，每行先输入整数len与整数m(分别代表本表的元素总数与前半表的元素个数），之后输入len个整数，代表对应顺序表的每个元素。 Output 输出有n行，为每个顺序表前m个元素与后（len-m）个元素交换后的结果 Sample Input 123210 3 1 2 3 4 5 6 7 8 9 105 3 10 30 20 50 80 Sample Output 124 5 6 7 8 9 10 1 2 350 80 10 30 20 Hint 注意：先将顺序表元素调整为符合要求的内容后，再做输出，输出过程只能在一次循环中完成，不能分成两个部分输出。 思路：空间复杂度O(1)要求不能新开数组，因此把先第一个元素放最后，然后数组前移，把第一个元素覆盖，重复m次,就把m个元素放到最后了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data[10001]; int length;&#125;SqList;SqList list;void createList(int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list.data[i]); &#125; list.length=n;&#125;void tranList(SqList *list,int m)&#123; //保存第一个数，然后让其他元素向前移动一位 //再把第一个数放到末尾，就完成了，执行m次 int i, j; while(m--)&#123; j=list-&gt;data[0]; for(i=0;i&lt;list-&gt;length-1;i++)&#123; list-&gt;data[i]=list-&gt;data[i+1]; &#125; list-&gt;data[list-&gt;length-1]=j; &#125;&#125;void ShowList(SqList *list)&#123; int i; for(i=0;i&lt;list-&gt;length;i++)&#123; printf("%d%c", list-&gt;data[i],i==list-&gt;length-1?'\n':' '); &#125;&#125;int main()&#123; int n, m, p; scanf("%d", &amp;n); while(n--)&#123; scanf("%d", &amp;m); scanf("%d", &amp;p); createList(m); tranList(&amp;list, p); ShowList(&amp;list); &#125; return 0;&#125; 顺序表应用4-2：元素位置互换之逆置算法(数据改进）Time Limit: 80 ms Memory Limit: 600 KiB Problem Description 一个长度为len(1&lt;=len&lt;=1000000)的顺序表，数据元素的类型为整型，将该表分成两半，前一半有m个元素，后一半有len-m个元素（1&lt;=m&lt;=len)，设计一个时间复杂度为O(N)、空间复杂度为O(1)的算法，改变原来的顺序表，把顺序表中原来在前的m个元素放到表的后段，后len-m个元素放到表的前段。注意：交换操作会有多次，每次交换都是在上次交换完成后的顺序表中进行。 Input 第一行输入整数len(1&lt;=len&lt;=1000000)，表示顺序表元素的总数； 第二行输入len个整数，作为表里依次存放的数据元素； 第三行输入整数t(1&lt;=t&lt;=30)，表示之后要完成t次交换，每次均是在上次交换完成后的顺序表基础上实现新的交换； 之后t行，每行输入一个整数m(1&lt;=m&lt;=len)，代表本次交换要以上次交换完成后的顺序表为基础，实现前m个元素与后len-m个元素的交换； Output 输出一共t行，每行依次输出本次交换完成后顺序表里所有元素。 Sample Input 123456101 2 3 4 5 6 7 8 9 -13235 Sample Output 1233 4 5 6 7 8 9 -1 1 26 7 8 9 -1 1 2 3 4 51 2 3 4 5 6 7 8 9 -1 Hint Source 思路：整体逆置的思想，比如样例： 12341 2 3 4 5 6 7 8 9 -1 将前2个移动到最后-1 9 8 7 6 5 4 3 2 1 整体逆置9 -1 8 7 6 5 4 3 2 1 前2个逆置9 -1 1 2 3 4 5 6 7 8 剩下的逆置 因此要定义一个逆置数组的函数res，res具体就是遍历数组的一半，与另外一半进行交换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; int data[10000001]; int length;&#125;SqList;SqList list;void createList(int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list.data[i]); &#125; list.length=n;&#125;//逆置数组void res(int l, int r)&#123; int i, j, t; j=r; for(i=l;i&lt;=(l+r)/2;i++)&#123; t=list.data[i]; list.data[i]=list.data[j]; list.data[j]=t; j--; &#125;&#125;void show()&#123; int i; for(i=0;i&lt;list.length;i++)&#123; printf("%d%c", list.data[i], i==list.length-1?'\n':' '); &#125;&#125;int main()&#123; int l, t, m; scanf("%d", &amp;l); createList(l); scanf("%d", &amp;t); while(t--)&#123; scanf("%d", &amp;m); res(0,list.length-1); res(list.length-m,list.length-1); res(0,list.length-m-1); show(); &#125; return 0;&#125; 顺序表应用5：有序顺序表归并Time Limit: 100 ms Memory Limit: 880 KiB Problem Description 已知顺序表A与B是两个有序的顺序表，其中存放的数据元素皆为普通整型，将A与B表归并为C表，要求C表包含了A、B表里所有元素，并且C表仍然保持有序。 Input 输入分为三行：第一行输入m、n（1&lt;=m,n&lt;=10000）的值，即为表A、B的元素个数；第二行输入m个有序的整数，即为表A的每一个元素；第三行输入n个有序的整数，即为表B的每一个元素； Output 输出为一行，即将表A、B合并为表C后，依次输出表C所存放的元素。 Sample Input 1235 31 3 5 6 92 4 10 Sample Output 11 2 3 4 5 6 9 10 Hint Source 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *LinkList;LinkList createLnode(int n)&#123; Lnode *head, *p, *t; head=(LinkList)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(LinkList)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=NULL; t-&gt;next=p; t=p; &#125; return head;&#125;//归并链表 LinkList merge(LinkList l1, LinkList l2)&#123; LinkList p, q, t; p=l1-&gt;next; q=l2-&gt;next; t=l1; free(l2); while(p!=NULL&amp;&amp;q!=NULL)&#123; if(p-&gt;data&lt;q-&gt;data)&#123; t-&gt;next=p; t=p; p=p-&gt;next;//不要忘了往下移动 t-&gt;next=NULL; &#125; else&#123; t-&gt;next=q; t=q; q=q-&gt;next; t-&gt;next=NULL; &#125; &#125; if(p==NULL)&#123; t-&gt;next=q; &#125;else&#123; t-&gt;next=p; &#125; return l1; &#125; void show(LinkList head)&#123; LinkList p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data, p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125; &#125;int main()&#123; int n, m; LinkList h1, h2; scanf("%d %d", &amp;n, &amp;m); h1=createLnode(n); h2=createLnode(m); h1=merge(h1,h2); show(h1); return 0;&#125; 顺序表应用6：有序顺序表查询Time Limit: 1000 ms Memory Limit: 4096 KiB Problem Description 顺序表内按照由小到大的次序存放着n个互不相同的整数，任意输入一个整数，判断该整数在顺序表中是否存在。如果在顺序表中存在该整数，输出其在表中的序号；否则输出“No Found!”。 Input 第一行输入整数n (1 &lt;= n &lt;= 100000)，表示顺序表的元素个数；第二行依次输入n个各不相同的有序非负整数，代表表里的元素；第三行输入整数t (1 &lt;= t &lt;= 100000)，代表要查询的次数；第四行依次输入t个非负整数，代表每次要查询的数值。 保证所有输入的数都在 int 范围内。 Output 输出t行，代表t次查询的结果，如果找到在本行输出该元素在表中的位置，否则本行输出No Found! Sample Input 1234101 22 33 55 63 70 74 79 80 87455 10 2 87 Sample Output 12344No Found!No Found!10 Hint Source 思路：二分查找（不可能考遍历寻找的。。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; int data[100001]; int length;&#125;SqList;void initList(SqList *list,int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list-&gt;data[i]); &#125; list-&gt;length=n;&#125;//二分查找int midsearch(SqList *list, int k, int l, int r )&#123; int mid; mid=(l+r)/2; //相等的情况也能查找,所以不要写等于号 if(l&gt;r)&#123; return -1; &#125; else if(k==list-&gt;data[mid])&#123; return mid; &#125; else if(k&lt;list-&gt;data[mid])&#123; return midsearch(list,k,0,mid-1); &#125; else &#123; return midsearch(list,k,mid+1,r); &#125;&#125;int main()&#123; SqList list; int n, t, k, m; scanf("%d", &amp;n); initList(&amp;list,n); scanf("%d", &amp;t); while(t--)&#123; scanf("%d", &amp;k); m=midsearch(&amp;list, k,0,(list.length)-1); if(m!=-1)&#123; printf("%d", m+1); &#125;else&#123; printf("No Found!"); &#125; printf("\n"); &#125; return 0;&#125; 顺序表应用7：最大子段和之分治递归法Time Limit: 10 ms Memory Limit: 400 KiB Problem Description 给定n(1&lt;=n&lt;=50000)个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]},1&lt;=i&lt;=j&lt;=n。 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2)时，最大子段和为20。 注意：本题目要求用分治递归法求解，除了需要输出最大子段和的值之外，还需要输出求得该结果所需的递归调用总次数。 递归调用总次数的获得，可以参考以下求菲波那切数列的代码段中全局变量count的用法： 12345678910111213141516171819#includeint count=0;int main()&#123; int n,m; int fib(int n); scanf("%d",&amp;n); m=fib(n); printf("%d %d\n",m,count); return 0;&#125;int fib(int n)&#123; int s; count++; if((n==1)||(n==0)) return 1; else s=fib(n-1)+fib(n-2); return s;&#125; Input 第一行输入整数n(1&lt;=n&lt;=50000)，表示整数序列中的数据元素个数； 第二行依次输入n个整数，对应顺序表中存放的每个数据元素值。 Output 一行输出两个整数，之间以空格间隔输出： 第一个整数为所求的最大子段和； 第二个整数为用分治递归法求解最大子段和时，递归函数被调用的总次数。 Sample Input 126-2 11 -4 13 -5 -2 Sample Output 120 11 Hint Source 思路： 子段与子序列不一样 子段的定义：(a[i],a[i+1],…+a[j]) 是连续的, 相当于连续的子序列 子序列：一个序列(a1, a2, …, aN)，子序列(ai1, ai2, …, aiK)，这里1&lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。不一定是连续的 样例找的是a[2],a[3],a[4] (从1开始数) 三个数的和为20。 网上搜到了一个视频，但需要翻墙才能看。。 分治法的思路就是，将序列分为左右两半，中间点为mid 递归计算左边的最大和lsum和右边的最大和rsum 那么整个序列的最大子段可能在左边lsum（i和j都在左边）,或者右边rsum(i和j都在右边)，或者是i在左边，j在右边，而前两种情况是递归计算出来的，第三种情况需要算一下，左半边的最大值，即从a[mid]开始往左边一直加到a[0](如果是第三种情况，那么a[mid]一定在序列中),用一个lmax记录加的过程中的最大值，同理也要计算右半边的最大值，从a[mid+1]加到a[length-1] ，用rmax记录累加过程中的最大值，那么第三种情况最大和就是lmax+rmax，之后再与lsum，rsum中取一个最大的即可 递归的结束条件就是l==r 只有一个元素的时候，需要注意的是如果为负值要返回0 12345 lmax rmax &lt;-------|-------&gt;&lt;-------------------&gt;|&lt;-------------------&gt; lsum rsuma[0]...........a[mid]|a[mid+1].............a[length-1] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; int data[50001]; int length;&#125;Sqlist;int count=0;void createSqlist(Sqlist *list,int n);int sub(Sqlist *list, int l, int r);int main()&#123; Sqlist list; int n, k; scanf("%d", &amp;n); createSqlist(&amp;list,n); k=sub(&amp;list,0,(list.length)-1); printf("%d %d\n", k, count); return 0;&#125;void createSqlist(Sqlist *list,int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list-&gt;data[i]); &#125; list-&gt;length=n;&#125;int sub(Sqlist *list, int l, int r)&#123; int sum, lmax, rmax, lsum, rsum, i, mid; count++; if(l==r)&#123; return list-&gt;data[l]&gt;0?list-&gt;data[l]:0; &#125; mid=(l+r)/2; lsum=sub(list,l,mid); rsum=sub(list,mid+1,r); //i和j不在同一个区间 sum=0; lmax=0;//记录左边包含a[mid]的最大和 for(i=mid;i&gt;=l;i--)&#123; sum+=list-&gt;data[i]; if(sum&gt;=lmax)&#123; lmax=sum; &#125; &#125; sum=0; rmax=0;//记录右边包含a[mid+1]的最大和 for(i=mid+1;i&lt;=r;i++)&#123; sum+=list-&gt;data[i]; if(sum&gt;=rmax)&#123; rmax=sum; &#125; &#125; sum=rmax+lmax; if(lsum&gt;sum)&#123; sum=lsum; &#125; //这里不能使用elseif if(rsum&gt;sum)&#123; sum=rsum; &#125; return sum;&#125; 这里还犯了一个很低级的错误，那就是if与else if混用，以前没注意过233333 if...if 都要进行判断 if...else if 第一个判断成功就不判读第二个 https://zhidao.baidu.com/question/541324936.html 顺序表应用8：最大子段和之动态规划法Time Limit: 5 ms Memory Limit: 500 KiB Problem Description 给定n(1&lt;=n&lt;=100000)个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]},1&lt;=i&lt;=j&lt;=n。 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2)时，最大子段和为20。 注意：本题目要求用动态规划法求解，只需要输出最大子段和的值。 Input 第一行输入整数n(1&lt;=n&lt;=100000)，表示整数序列中的数据元素个数； 第二行依次输入n个整数，对应顺序表中存放的每个数据元素值。 Output 输出所求的最大子段和 Sample Input 126-2 11 -4 13 -5 -2 Sample Output 120 Hint Source 思路：动态规划法： 子问题的划分: C[i-1]对应截止到a[i-1] 的最大子段和，那么C[i]的最大子段和就是 如果C[i-1]+a[i]&gt;C[i],（就是C[i-1]&gt;0)，C[i]=C[i-1]+a[i] 如果C[i-1]+a[i]&lt;C[i],(就是C[i-1]&lt;0),C[i]=a[i] 然后我们找到的最大的C[i]就行了（有点像最长上升子序列，但是这是子串，必须连续，子序列不一定连续） 这题开两个数组会超内存，注意到我们只需要C[i]和C[i-1]，因此用两个变量存一下就行了 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; int data[100001]; int length;&#125;Sqlist; void createSqlist(Sqlist *list,int n);int main()&#123; Sqlist list; int n, before, after, max, i; scanf("%d", &amp;n); createSqlist(&amp;list, n); max=0; before=list.data[0]; for(i=1;i&lt;list.length;i++)&#123; if(before&gt;0)&#123; after=before+list.data[i]; &#125;else&#123; after=list.data[i]; &#125; if(after&gt;max)&#123; max=after; &#125; before=after; &#125; printf("%d\n", max&gt;0?max:0);//小于0的时候输出0 return 0;&#125;void createSqlist(Sqlist *list,int n)&#123; int i; for(i=0;i&lt;n;i++)&#123; scanf("%d", &amp;list-&gt;data[i]); &#125; list-&gt;length=n;&#125; 数据结构实验之链表一：顺序建立链表Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入N个整数，按照输入的顺序建立单链表存储，并遍历所建立的单链表，输出这些数据。 Input 第一行输入整数的个数N；第二行依次输入每个整数。 Output 输出这组整数。 Sample Input 12812 56 4 6 55 15 33 62 Sample Output 112 56 4 6 55 15 33 62 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void show(Linklist head);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(n); show(head); return 0;&#125;Linklist create(int n)&#123; Linklist p, head; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=head-&gt;next; head-&gt;next=p; &#125; return head;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表二：逆序建立链表Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入整数个数N，再输入N个整数，按照这些整数输入的相反顺序建立单链表，并依次遍历输出单链表的数据。 Input 第一行输入整数N;；第二行依次输入N个整数，逆序建立单链表。 Output 依次输出单链表所存放的数据。 Sample Input 121011 3 5 27 9 12 43 16 84 22 Sample Output 122 84 16 43 12 9 27 5 3 11 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void show(Linklist head);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(n); show(head); return 0;&#125;Linklist create(int n)&#123; Linklist p, head, t; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表三：链表的逆置Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入多个整数，以-1作为结束标志，顺序建立一个带头结点的单链表，之后对该单链表的数据进行逆置，并输出逆置后的单链表数据。 Input 输入多个整数，以-1作为结束标志。 Output 输出逆置后的单链表数据。 Sample Input 112 56 4 6 55 15 33 62 -1 Sample Output 162 33 15 55 6 4 56 12 Hint 不得使用数组。 就是逆序建立链表，不过元素不用输入，而是从原来的链表里拿 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create();void res(Linklist head);void show(Linklist head);int main()&#123; Linklist head; head=create(); res(head); show(head); return 0;&#125;Linklist create()&#123; int n; Linklist head, p, t; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(1)&#123; scanf("%d", &amp;n); if(n==-1)&#123; break; &#125; p=(Linklist)malloc(sizeof(Lnode)); p-&gt;data=n; p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;void res(Linklist head)&#123; Linklist p, q; p=head-&gt;next; q=p-&gt;next;//需要一个q防止断了，让p插在头指针后还能在找到原链表 head-&gt;next=NULL; while(p!=NULL)&#123; p-&gt;next=head-&gt;next; head-&gt;next=p; p=q; //注意这个判断条件，不是单纯的反向建立链表 if(q!=NULL)&#123;//后置指针为空的时候，不能在往后了 q=p-&gt;next; //NULL没有next值 &#125; &#125;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表四：有序链表的归并Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 分别输入两个有序的整数序列（分别包含M和N个数据），建立两个有序的单链表，将这两个有序单链表合并成为一个大的有序单链表，并依次输出合并后的单链表数据。 Input 第一行输入M与N的值；第二行依次输入M个有序的整数；第三行依次输入N个有序的整数。 Output 输出合并后的单链表所包含的M+N个有序的整数。 Sample Input 1236 51 23 26 45 66 9914 21 28 50 100 Sample Output 11 14 21 23 26 28 45 50 66 99 100 Hint 不得使用数组！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void merge(Linklist h1,Linklist h2);void show(Linklist head);int main()&#123; int n, m; Linklist h1, h2; scanf("%d %d", &amp;n, &amp;m); h1=create(n); h2=create(m); merge(h1,h2); show(h1); return 0;&#125;Linklist create(int n)&#123; Linklist head, p, t; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;void merge(Linklist h1,Linklist h2)&#123; Linklist p1, p2, t; p1=h1-&gt;next; p2=h2-&gt;next; t=h1; h1-&gt;next=NULL; free(h2); while(p1!=NULL&amp;&amp;p2!=NULL)&#123; if(p1-&gt;data&gt;p2-&gt;data)&#123; t-&gt;next=p2; t=p2; p2=p2-&gt;next;//记得下移 t-&gt;next=NULL;//记得断开 &#125;else&#123; t-&gt;next=p1; t=p1; p1=p1-&gt;next; t-&gt;next=NULL; &#125; &#125; if(p1==NULL)&#123; t-&gt;next=p2; &#125; if(p2==NULL)&#123; t-&gt;next=p1; &#125;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表五：单链表的拆分Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入N个整数顺序建立一个单链表，将该单链表拆分成两个子链表，第一个子链表存放了所有的偶数，第二个子链表存放了所有的奇数。两个子链表中数据的相对次序与原链表一致。 Input 第一行输入整数N;；第二行依次输入N个整数。 Output 第一行分别输出偶数链表与奇数链表的元素个数；第二行依次输出偶数子链表的所有数据；第三行依次输出奇数子链表的所有数据。 Sample Input 12101 3 22 8 15 999 9 44 6 1001 Sample Output 1234 622 8 44 6 1 3 15 999 9 1001 Hint 不得使用数组！ Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void split(Linklist head);void show(Linklist head);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(n); split(head); return 0;&#125;Linklist create(int n)&#123; Linklist head, p, t; head =(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;void split(Linklist head)&#123; int odd=0, even=0; Linklist h1, h2, r, t1, t2; r=head-&gt;next; h1=(Linklist)malloc(sizeof(Lnode)); h2=(Linklist)malloc(sizeof(Lnode)); h1-&gt;next=NULL; h2-&gt;next=NULL; t1=h1; t2=h2; while(r!=NULL)&#123; if(r-&gt;data%2!=0)&#123; t1-&gt;next=r; t1=r; r=r-&gt;next; t1-&gt;next=NULL; odd++; &#125; else&#123; t2-&gt;next=r; t2=r; r=r-&gt;next; t2-&gt;next=NULL; even++; &#125; &#125; printf("%d %d\n", even, odd); show(h2); show(h1);&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data, p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表六：有序链表的建立Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 输入N个无序的整数，建立一个有序链表，链表中的结点按照数值非降序排列，输出该有序链表。 Input 第一行输入整数个数N；第二行输入N个无序的整数。 Output 依次输出有序链表的结点值。 Sample Input 12633 6 22 9 44 5 Sample Output 15 6 9 22 33 44 Hint 不得使用数组！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void s(Linklist head);void show(Linklist head);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(n); s(head); show(head); return 0;&#125;Linklist create(int n)&#123; Linklist head, t, p; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=t-&gt;next; t-&gt;next=p; t=p; &#125; return head;&#125;//选择排序 找到最小的放第一个void s(Linklist head)&#123; int t; Linklist p, q; p=head-&gt;next; while(p!=NULL)&#123; q=p-&gt;next; while(q!=NULL)&#123; if(p-&gt;data&gt;q-&gt;data)&#123; t=p-&gt;data; p-&gt;data=q-&gt;data; q-&gt;data=t; &#125; q=q-&gt;next; &#125; p=p-&gt;next; &#125;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data, p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125; 数据结构实验之链表七：单链表中重复元素的删除Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 按照数据输入的相反顺序（逆位序）建立一个单链表，并将单链表中重复的元素删除（值相同的元素只保留最后输入的一个）。 Input 第一行输入元素个数 n (1 &lt;= n &lt;= 15)；第二行输入 n 个整数，保证在 int 范围内。 Output 第一行输出初始链表元素个数；第二行输出按照逆位序所建立的初始链表；第三行输出删除重复元素后的单链表元素个数；第四行输出删除重复元素后的单链表。 Sample Input 121021 30 14 55 32 63 11 30 55 30 Sample Output 12341030 55 30 11 63 32 55 14 30 21730 55 11 63 32 14 21 Hint Source 不得使用数组！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Lnode, *Linklist;Linklist create(int n);void show(Linklist head);void del(Linklist head, int n);int main()&#123; int n; Linklist head; scanf("%d", &amp;n); head=create(n); printf("%d\n", n); show(head); del(head, n); return 0;&#125;Linklist create(int n)&#123; Linklist head, p; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=head-&gt;next; head-&gt;next=p; &#125; return head;&#125;void show(Linklist head)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; printf("%d%c", p-&gt;data,p-&gt;next==NULL?'\n':' '); p=p-&gt;next; &#125;&#125;void del(Linklist head, int n)&#123; int count=0; Linklist p, q, r; p=head-&gt;next; while(p!=NULL)&#123; r=p; q=r-&gt;next; while(q!=NULL)&#123; if(p-&gt;data==q-&gt;data)&#123; r-&gt;next=q-&gt;next; free(q); q=r-&gt;next; count++; &#125;else&#123; q=q-&gt;next; r=r-&gt;next; &#125; &#125; p=p-&gt;next; &#125; printf("%d\n", n-count); show(head);&#125; 数据结构实验之链表八：Farey序列Time Limit: 10 ms Memory Limit: 600 KiB Problem Description Farey序列是一个这样的序列：其第一级序列定义为（0/1，1/1），这一序列扩展到第二级形成序列（0/1，1/2，1/1），扩展到第三极形成序列（0/1，1/3，1/2，2/3，1/1），扩展到第四级则形成序列（0/1，1/4，1/3，1/2，2/3，3/4，1/1）。以后在每一级n，如果上一级的任何两个相邻分数a/c与b/d满足（c+d）&lt;=n，就将一个新的分数(a+b)/(c+d)插入在两个分数之间。对于给定的n值，依次输出其第n级序列所包含的每一个分数。 Input 输入一个整数n(0&lt;n&lt;=100) Output 依次输出第n级序列所包含的每一个分数，每行输出10个分数，同一行的两个相邻分数间隔一个制表符的距离。 Sample Input 16 Sample Output 120/1 1/6 1/5 1/4 1/3 2/5 1/2 3/5 2/3 3/44/5 5/6 1/1 Hint Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; struct node *next; int top, bottom;&#125;Lnode, *Linklist;void show(Linklist head);Linklist create();Linklist farey(Linklist head, int n);void simple(int *bottom, int *top);int main()&#123; Linklist head; int n; scanf("%d", &amp;n); head=create(); if(n==1)&#123; show(head); &#125;else&#123; head=farey(head, n); show(head); &#125; return 0;&#125;Linklist create()&#123;//初始化一级序列 Linklist head, p; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; p=(Linklist)malloc(sizeof(Lnode)); p-&gt;next=head-&gt;next; head-&gt;next=p; p-&gt;top=1; p-&gt;bottom=1; p=(Linklist)malloc(sizeof(Lnode)); p-&gt;next=head-&gt;next; head-&gt;next=p; p-&gt;top=0; p-&gt;bottom=1; return head;&#125;Linklist farey(Linklist head, int n)&#123; Linklist p, q, r; int i; n--;//一的时候处理了 i=1; while(n--)&#123; i++; q=head-&gt;next; p=q-&gt;next; while(p!=NULL)&#123; //如果直接插入的话会影响下一次的操作，两个相邻的就不是原链表的了，有一个是插入的 if(p-&gt;bottom+q-&gt;bottom&lt;=i)&#123; r=(Linklist)malloc(sizeof(Lnode)); r-&gt;top=p-&gt;top+q-&gt;top; r-&gt;bottom=p-&gt;bottom+q-&gt;bottom; //化简 simple(&amp;(r-&gt;bottom), &amp;(r-&gt;top)); q-&gt;next=r; r-&gt;next=p; //处理操作，保证下次操作的时候不把新插入的元素用来判断 q=r-&gt;next; p=q-&gt;next; &#125;else&#123; p=p-&gt;next; q=q-&gt;next; &#125; &#125; &#125; return head;&#125;void show(Linklist head)&#123; Linklist p; int c=1; p=head-&gt;next; while(p!=NULL)&#123; if(c==10||p-&gt;next==NULL)&#123; printf("%d/%d", p-&gt;top, p-&gt;bottom); printf("\n"); c=0; &#125;else&#123; //制表符是/t printf("%d/%d\t", p-&gt;top, p-&gt;bottom); &#125; p=p-&gt;next; c++; &#125;&#125;void simple(int *bottom, int *top)&#123; //分数化简，找出分子，分母的最大公约数，除以它即可 int t,a,b; a=*bottom; b=*top; //辗转相除法 if(a&lt;b)&#123; t=a; a=b; b=t; &#125; //余数t，让第二个数b去b%t（a对应b，b对应t）,直到a*b==0,b就是最大公约数 while(a%b!=0)&#123; t=a%b; a=b; b=t; &#125; *bottom=*bottom/b; *top=*top/b;&#125; 数据结构实验之链表九：双向链表Time Limit: 1000 ms Memory Limit: 65536 KiB Problem Description 学会了单向链表，我们又多了一种解决问题的能力，单链表利用一个指针就能在内存中找到下一个位置，这是一个不会轻易断裂的链。但单链表有一个弱点——不能回指。比如在链表中有两个节点A,B，他们的关系是B是A的后继，A指向了B，便能轻易经A找到B,但从B却不能找到A。一个简单的想法便能轻易解决这个问题——建立双向链表。在双向链表中，A有一个指针指向了节点B，同时，B又有一个指向A的指针。这样不仅能从链表头节点的位置遍历整个链表所有节点，也能从链表尾节点开始遍历所有节点。对于给定的一列数据，按照给定的顺序建立双向链表，按照关键字找到相应节点，输出此节点的前驱节点关键字及后继节点关键字。 Input 第一行两个正整数n（代表节点个数），m（代表要找的关键字的个数）。第二行是n个数（n个数没有重复），利用这n个数建立双向链表。接下来有m个关键字，每个占一行。 Output 对给定的每个关键字，输出此关键字前驱节点关键字和后继节点关键字。如果给定的关键字没有前驱或者后继，则不输出。注意：每个给定关键字的输出占一行。 一行输出的数据之间有一个空格，行首、行末无空格。 Sample Input 1234510 31 2 3 4 5 6 7 8 9 0350 Sample Output 1232 44 69 Hint Source 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next, *pre;&#125;Lnode, *Linklist;Linklist create(int n);void locate(Linklist head, int k);int main(void) &#123; int n, m, k; Linklist head; scanf("%d", &amp;n); scanf("%d", &amp;m); head=create(n); while(m--)&#123; scanf("%d", &amp;k); locate(head,k); &#125; return 0;&#125;Linklist create(int n)&#123; Linklist head, t, p; head=(Linklist)malloc(sizeof(Lnode)); head-&gt;next=NULL; head-&gt;pre=NULL; t=head; while(n--)&#123; p=(Linklist)malloc(sizeof(Lnode)); scanf("%d", &amp;p-&gt;data); p-&gt;next=NULL; t-&gt;next=p; p-&gt;pre=t; t=p; &#125; return head;&#125;void locate(Linklist head, int k)&#123; Linklist p; p=head-&gt;next; while(p!=NULL)&#123; if(p-&gt;data==k)&#123; if(p-&gt;pre!=head)&#123; //注意这条输出语句，而且前置指针除了head为NULL,p-&gt;pre不可能为空 printf("%d%s", p-&gt;pre-&gt;data,p-&gt;next==NULL?"\n":" "); &#125; if(p-&gt;next!=NULL)&#123; printf("%d\n", p-&gt;next-&gt;data); &#125; &#125; p=p-&gt;next; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2021%2F06%2F29%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[12345var str=/abc/i; i==ignoreCase//忽略大小写 没引号 //就代表正则匹配字符串中是否有abc 忽略大小写g global 全局匹配m 多行匹配^abc ^代表必须开头，匹配开头有abc的字符 方括号方括号用于查找某个范围内的字符， 一个[]代表一个字符，[]里的内容代表这个字符可以有的内容 []里的^代表非 表达式 描述 [abc] 查找方括号之间的任何字符。 abc 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 adgk 查找给定集合外的任何字符。 (red\ blue\ green) 查找任何指定的选项。 (red|blue|green) 代表字符串中要有red或blue或green整体（） | 代表或者 也可以用于[]; 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 [.] 查找单个字符，除了换行和行结束符。[^\r\n] [\w] 查找单词字符。 w==world 相当于 [0-9A-z_] /\w/ [\W] 查找非单词字符。 [^\w] [\d] 查找数字。 [0-9] [\D] 查找非数字字符。[^\d] [\s] 查找空白字符。 \s相当于[\n\f\r\t\v ] //还有一个空格 [\S] 查找非空白字符。[^\s] [\b] 匹配单词边界。 reg=/\bcde\b/ str=”acb cde acde” 会匹配中间的cde /b代表单词的边界 [\B] 匹配非单词边界。 \0 查找 NUL 字符。 [\n] 查找换行符。 \f 查找换页符。 \r 查找回车符。 \t 查找制表符。必须是字符串中有\t str=”\ts”，不能是str=” s” \v 查找垂直制表符。 [\xxx] 查找以八进制数 xxx 规定的字符。 [\xdd] 查找以十六进制数 dd 规定的字符。 [\uxxxx] 查找以十六进制数 xxxx 规定的 Unicode 字符。 可以用来匹配汉字 [\s\S] 代表所有的字符，同理[\w\W]也行… 量词将元字符乘以一个数 量词 描述 [n+] 匹配任何包含至少一个 n 的字符串。 匹配1 到 正无穷 个 n [n*] 匹配任何包含零个或多个 n 的字符串。 [n?] 匹配任何包含零个或一个 n 的字符串。 [n{X}] 匹配包含 X 个 n 的序列的字符串。 [n{X,Y}] 匹配包含 X 至 Y 个 n 的序列的字符串。 [n{X,}] 匹配包含至少 X 个 n 的序列的字符串。 [n$] 匹配任何结尾为 n 的字符串。 n 匹配任何开头为 n 的字符串。 [?=n] 匹配任何其后紧接指定字符串 n 的字符串。 [?!n] 匹配任何其后没有紧接指定字符串 n 的字符串。 带不带量词的区别， 匹配1 至 多个： 匹配 0 至 多个 匹配的n{X}里的数字是指n*X，即连续匹配X个n, 如果是区间，先匹配多的，n{3，5}，优先得到连续5个符合n的字符串，例如： 123var reg = \^abc$\; //匹配以abc开头，以abc结尾的字符串var st1 = "abcabc"; //falsevar str2 = "abc";//true http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 配合 axios 上传文件（图片）]]></title>
    <url>%2F2021%2F06%2F29%2FVue%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%EF%BC%88%E5%9B%BE%E7%89%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基础起步上传文件要用到input标签 &lt;input type=&quot;file&quot; /&gt; 文件选择是只读的,不能使用v-model 数据双向绑定,只能用change监控值的变化。 所以就用change来代替v-model来处理文件。 &lt;input type=&quot;file&quot; v-on:change=&quot;upFile&quot; /&gt; 在methods里处理文件 12345methods: &#123; upFile(e)&#123; console.log(e.target.files); &#125;&#125; e.target.files就是点击上传的文件对象了 如果在input标签中加入 multiple 属性，可以在一个输入框中选择多个文件进行上传，此时e.target.files就是一个数组，用下标去寻找文件。 如何在前端预览我搜索到的方法是将图片转换成base64的编码，之后用img的src等与图片的base64编码即可展示。 img 的 src 等于图片的URL可以展示，等于base64也可以展示。 将图片转换成base64需要用到内置对象FileReader 当 FileReader 读取文件的方式为 readAsArrayBuffer, readAsBinaryString, readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件。从而可以使用 FileReader.onload 属性对该事件进行处理。 读取图片的base64需要用到readAsDataURL这个方法是异步的，也就是说，只有当执行完成后才能够查看到结果，如果直接查看是无结果的，并返回undefined，也就是说必须要挂载 实例下的 onload 或 onloadend 的方法处理转化后的结果。 代码如下： 12&lt;input type="file" v-on:change="upFile"/&gt;&lt;img src ref="showImg"&gt; 123456789methods: &#123; upFile(e)&#123; let reader=new FileReader(); reader.onload= (evt)=&gt;&#123; this.$refs.showImg.src=evt.target.result; &#125; reader.readAsDataURL(e.target.files[0]); &#125;&#125; evt.target.result 就是reader.readAsDataURL(e.target.files[0]) 的结果。 效果如下： 配合axios 上传至后台如果直接传base64编码的话，可以按照普通的字符传值处理，存入数据库时可以在后台将base64转换成图片存放在某处，数据库直接存放生成的图片的URL即可。再往前端传图片时可以传base64也可以传URL。 现在说明的是如何将文件直接传到后台（PHP用$_FILES接受）。 FormData 接口提供了一种表示表单数据的键值对的构造方式，经过它的数据可以使用 XMLHttpRequest.send() 方法送出，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 &quot;multipart/form-data&quot;，它会使用和表单一样的格式。 代码解释如下 123456789101112131415upFile(e) &#123; let file = e.target.files[0]; let param = new FormData(); // 创建form对象 param.append(&quot;file&quot;, file, file.name); // 通过append向form对象添加数据 param.append(&quot;chunk&quot;, &quot;0&quot;); // 添加form表单中其他数据 console.log(param.get(&quot;file&quot;)); // FormData私有类对象，访问不到，可以通过get判断值是否传进去 let config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart/form-data&quot; &#125; &#125;; this.axios .post(apiURL, param, config) .then(function(response) &#123; console.log(response); &#125;); &#125; 后台即可用$_FILES接受。其它值用$_POST 接受。 后台如何处理文件，参考 https://misakasister.github.io/2018/09/30/PHP%20%E5%BA%94%E7%94%A8/ 中的文件上传部分。 全部代码1234&lt;div id="app"&gt; &lt;input type="file" v-on:change="upFile"/&gt; &lt;img src ref="showImg" /&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526upFile(e) &#123; //图片预览部分 let reader = new FileReader(); let file = e.target.files[0]; reader.onload = evt =&gt; &#123; this.$refs.showImg.src = evt.target.result; &#125;; reader.readAsDataURL(file); //图片上传部分，可以用公共变量保存param，在别的事件里上传。 let param = new FormData(); param.append(&quot;file&quot;, file, file.name); param.append(&quot;chunk&quot;, &quot;0&quot;); let config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart/form-data&quot; &#125; &#125;; axios .post( &quot; http://localhost:8088/sql/CodeIgniter-3.1.10/index.php/file/upload&quot;, param, config ) .then(function(response) &#123; console.log(response); &#125;); &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 应用]]></title>
    <url>%2F2021%2F06%2F29%2FPHP%20%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[表单传值表单传值即浏览器通过表单元素将用户的选择或者输入的数据交给后台服务器 传值的方式GET传值1 from 表单 &lt;form method=&quot;GET&quot; action=&quot;url&quot;&gt; 表单元素&lt;/form&gt; 2 a标签 &lt;a href=&quot;../index.php?data=&quot;php&quot;&gt; 3 location 对象的href 属性 location.href=&quot;&quot; 4 location 对象的assign()方法 location.assign(&quot;...&quot;) 提交要放到html结构的最后面 post 传值1 post表单传值 &lt;form method=&quot;POST&quot;&gt; 表单元素&lt;/form&gt; 2 post与get的区别 get主要用来获取数据，不改变服务器上的资源，get只是用来获取内容 post传输的数据主要用来增加数据，改变服务器上的资源：post会改变服务器上数据内容 3 post必须使用form表单，get可以使用form和url 4 get 传输的数据在url中可见，post不可见，get传值显示 ?数据名=数据值&amp;数据名=数据值 5 get能传2k（浏览器限制,并非本身的属性），post理论上无限制 6get 传递简单的数据（数值/字符串）post传递复杂数据（二进制等）。 接收数据$_GET 接受get方式提交的数据 $_POST 接收post方式提交的数据 $_REQUEST 接收post方式或者get方式提交的数据 这三个方法都是php超全局，没有范围的限制，预定义数组，表单元素的“name”属性的值作为数组的下标，value属性对应的值就是数组元素的值。点击提交后，$_…就会接受表单的值。 因此表单必须要有name值作为角标，value值作为数组值 1234&lt;form action="echo.php" method="GET"&gt; &lt;input type="text" name="text"&gt; &lt;input type="submit" name="sub"&gt; &lt;/form&gt; 1234&lt;?php $a = $_GET; var_dump($a);?&gt; 复选框处理单选框的处理:radio 可以出现多个选项，但是只能选择一个 表单使用name 属性，使用同名即可：只能选择一个 12&lt;input type="radio" name="gender" value="1"&gt;男&lt;input type="radio" name="gender" value="2"&gt;女 php拿到数据后，组织sql直接存到数据表里即可 多选框的处理： 1表单中name 属性使用数组格式:名字[] name值必须加中括号 //一类复选框数据使用一个 1234&lt;input type="checkbox" name="hobby[]" value="1"&gt;足球&lt;input type="checkbox" name="hobby[]" value="2"&gt;蓝球&lt;input type="checkbox" name="hobby[]" value="3"&gt;排球&lt;input type="checkbox" name="hobby[]" value="4"&gt;球 123&lt;?php $a=$_GET[hobby]；//数组a就接受了被选选项的value值 ?&gt; 2后台接收数据之后，是一个数组（数组不能存储到数据库中） 3php 需要使用分隔符讲数组分解为字符串 implode(分割符，数组) 反向操作：expload 可以把字符串变成数组 文件上传处理表单写法 1) method 的提交方式必须为Post 2）enctype 属性 form表单属性，主要是规范表单数据的编码方式。 http://www.w3school.com.cn/tags/att_form_enctype.asp 属性值 值 描述 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 3）上传表单：file表单 1234&lt;form action="echo.php" method="POSTenctype="multipart/form-data"&gt;&lt;input type="file" value="img" name="loimg"&gt;&lt;input type="submit" value="true" name="t"&gt;&lt;/form&gt; $_FILES预定义变量$_FILES 是专门用来存储用户上传文件的 123456&lt;?php $a = $_POST; $b = $_FILES; var_dump($a); var_dump($b);?&gt; 上图是b数组的内容，可以看到角标name=img对应的元素为一个数组，其数组内容又包含： name: 文件在客户机上的实际名字 （实际用来保存后缀） type:MIME(多功能互联网邮件扩展)类型，用来在计算机中识别文件类型，比如识别到doc就可以用word打开 tmp_name: 文件在服务器端临时存储的地址和名字（等待脚本被加工，不处理则被删除。） error:文件上传的代号，用来告知php文件接受过程中出现了什么错误 size: 文件大小 移动临时文件1）判断是否为上传的文件 is_uploaded_file() 判断文件是否为http post 上传，参数是tmp_name 2）移动文件：move_uploaded_file() 参数1：源文件在哪里（tep_name) 参数2：想要保存的url，url需要有文件的新名字（name) 文件上传后会保存到$_file中，那么访问文件信息的形式就是$_file[“name值”][“属性值”] 12345&lt;?php $a = $_FILES['loimg']; if (is_uploaded_file($a['tmp_name'])) &#123; move_uploaded_file($a['tmp_name'], '..\\'.$a['name']);\\第一个反斜杠是转义的意思 或者写错../也行 &#125; 多文件上传结构同名表单1234567 &lt;form action="echo.php" method="POST" enctype="multipart/form-data"&gt;&lt;input type="file" name="hobby[]" value="1"&gt;&lt;input type="file" name="hobby[]" value="2"&gt;&lt;input type="file" name="hobby[]" value="3"&gt;&lt;input type="file" name="hobby[]" value="4"&gt;&lt;input type="submit"&gt; &lt;/form&gt; 会将表单名形成一个数组，而且将文件对应的五元素（name, tmp_name等）再形成一个数组，每个文件对应元素下标所对应的文件是一样的，name[0]与tmp_name[0]对应是用一个文件 不同名表单每个文件都会形参一个下标为name的数组 123456&lt;form action="echo.php" method="POST" enctype="multipart/form-data"&gt;&lt;input type="file" name="h1" value="1"&gt;&lt;input type="file" name="h2" value="2"&gt;&lt;input type="file" name="h3" value="3"&gt;&lt;input type="file" name="h4" value="4"&gt;&lt;input type="submit"&gt; 多文件的遍历与读取不同名文件直接$files[name]就可以取出来 如果文件的个数不确定，就要用到foreach去遍历 1234567&lt;?php foreach($FILES as $key)&#123; //$key就是一个完整的上传文件信息 if(is_uploaded_file($key['tmp_name']))&#123; move_uploaded_file($key['tmp_name'],'url'); &#125; &#125; 同名多文件上传：想办法得到一个文件对应的五个元素。从$_FILES中把对应元素取出来，之后存放在一个数组中。 12345678910&lt;?php if(isset($_FILES['form-name']['name'])&amp;&amp;is_array($_FILES['form-name']['name']))&#123; $arr=array(); foreach($FILES['form-name']['name'] as $key =&gt; $value)&#123; $arr[]=array( 'name'=&gt;$value, 'tmp_name'=&gt;$_FILES['form-name']['tmp_name'][$key], ) &#125; &#125; 文件处理当上传一个文件，我们需要判断 文件类型是否合适（mime类型）？文件存储到的位置？文件格式的限制（后缀名）？大小的限制？还需要将文件的路径和文件名字返回。 如果上传失败的时候还要告诉用户的错误原因 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?php// 文件上传（单文件）/*array $file 需要上传的文件信息，一位五元数组array $allow_type 允许上传的mime类型string $path 存储的路径string &amp;$error 出现错误的原因array $allow_format=array() 允许上传的文件格式int max_size 允许上传的最大值*/function upload_single($file, $allow_type, $path, &amp;$error, $allow_formate, $max_size)&#123; // 判断文件是否有效 if (!is_array($file) || !isset($file['error'])) &#123; //文件无效 $error = '文件无效'; return false; &#125; // 判断文件存储路径是否有效 // is_dir() 函数检查指定的文件是否是一个目录。 if (!is_dir($path)) &#123; $error = '路径错误'; return false; &#125; // 判断文件是否上传过程中出错 // 值为0的时候代表上传成功，而且没有5 switch ($file['error']) &#123; case 1: case 2: $error = '文件超过服务器允许的大小'; return false; case 3: $error = '文件只上传了一部分，检查网络'; return false; case 4: $error = '没有选中文件'; return false; case 6: case 7: $error = '文件保存失败'; return false; &#125; // 文件类型处理 //in_array()判断一个元素是否在数组里存在 if (!in_array($file['type'], $allow_type)) &#123; $error = '当前文件不允许上传'; return false; &#125; // 判断后缀名 // 取出后缀名 // strstr — 查找字符串的首次出现 stringstrip // ltrim从字符串左侧移除字符： $ext = ltrim(strstr($file['name'], '.'), '.'); if (!empty($allow_formate) &amp;&amp; !in_array($ext, $allow_formate)) &#123; $error = '当前文件不允许上传'; return false; &#125; // 判断文件大小 if ($file['size'] &gt; $max_size) &#123; $error = '文件超出大小,最大可传'.$max_size.'字节'; return false; &#125; // 构造文件的名字 $fullname = strstr($file['type'], '/', true).date('Y - m - d'); for ($i = 0; $i &lt; 4; ++$i) &#123; //char(ascii)) $fullname .= chr(mt_rand(65, 90)); &#125; $fullname .= '.'.$ext; // 移动到指定目录 if (!is_uploaded_file($file['tmp_name'])) &#123; $error = '上传失败'; return false; &#125; echo $fullname; if (move_uploaded_file($file['tmp_name'], $path.$fullname)) &#123; return true; &#125; else &#123; $error = '上传失败'; return false; &#125;&#125;$file = $_FILES['h1'];$path = '../';$allow_type = array('image/png');$allow_format = array('png', 'jpg');if (upload_single($file, $allow_type, $path, $error, $allow_format, 200000)) &#123; echo 'yes';&#125; else &#123; echo $error;&#125; MySql 扩展php 针对 MySql 数据库提供的扩展，允许php当作mysql的一个客户端连接服务器进行操作。 连接数据库建立连接： 主机地址，默认自动连接3306 $link=mysqli_connect(&#39;服务器地址&#39;，&#39;用户名&#39;，&#39;密码&#39;) 连接资源默认超全局，任何地方都可以调用 设置连接编码 mysqli_query($link,&#39;set names utf8&#39;) mysqli_set_charset(&#39;字符集&#39;) 确定编码：客户端当前所用脚本界面的字符集 执行SQL指令mysqli_query($link,&#39;sql&#39;) 增：mysqli_query($link,&#39;inset...&#39;) insert into 表名[(字段名列表)] values (对应的字段值) 删：mysqli_query($link,&#39;delete...&#39;) delete from 表名 where 字段属性值=值 改：mysqli_query($link,&#39;update...&#39;) update 表名 set 字段属性值 = 新值 [where 条件] 查：mysqli_query($link,&#39;select...&#39;) select 字段名列表 from 表名 执行语句时如果变量的字符串有引号，一定要进行替换处理，展示的时候也要在换回来 也不一定是查询语句，show和desc都可以，只要是将数据展示的语句就可以 查的返回值有true和false 这并不能说明有没有查到数据（都会返回true)，只有语句写错了会返回false。本身是一个结果集，转化为bool用为true 解析结果集获取结果的行数 mysqli_num_rows(结果集) 可以得到结果集中到底有多少行记录 将一种结果资源（php不能直接使用）,转换成一种php能够解析的数据格式：通过从结果集中（结果集指针：类似与数组指针）按照结果集指针所在位置取出对应的一条记录（一行）,返回一个数组，同时指针下移，直到指针移出结果集。 mysqli_fetch_assoc() 获取关联数组，数组的键是字段，值是记录 mysqli_fetch_row() 获取索引数组，键是数字，值是记录 mysqli_fetch_array() 获取关联数组或索引数组，也就是一个数据取两次，通过字段或者数字作为下标都可以得到数据。可以通过第二个参数MYSQL_ASSOC,MYSQL_NUM,MYSQL_BOTH来调整 所有的fetch语句共用一个数据源指针 一些其它函数 mysqli_num_fields($res) 获取结果集中的字段数 mysqli_field_name($res,0) 获取结果集中指定位置的字段 关闭资源主动释放连接,脚本执行结束也会自动释放 mysql_close(&#39;资源&#39;) http协议概念HTTP协议：即超文本传输协议（Hypertext transfer protocol)。是一种详细规定浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传输协议。 http协议是用于www服务器传输超文本到本地浏览器的传送协议。它可以是浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档的拿一部分，以及哪部分首先显示等。 特点客户/服务器模式 简单快速：只需传送请求方式和路径 灵活：允许传送任意类型的数据对象（mime类型） 无连接：每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接 无状态：对于事务处理没有记忆能力。如果后续处理需要前面的信息必须重传。 分类请求协议：浏览器向服务器发起请求的时候需要遵循的协议。 响应协议：服务器向浏览器发起响应的时候需要遵循的协议。 http请求开发者工具-&gt;network中查看 请求行 形式：请求方式 资源路径 协议版本号 GET/index.php http/1.1 请求头： 各项协议内容：具体的协议内容不会每次都使用全部 host：请求的主机地址（必须） accept: 当前请求能够接受服务器返回的类型（mime) accept-language: 接收内容 user-agent:客户浏览器所在点的信息 请求体 请求数据：只有post请求会有请求体。get请求所有的数据都是跟在url之后，会在请求行中的资源路径上体现。 http响应 响应行 形式：协议版本 状态码 状态消息（独占一行） http/1.1 200 ok 200 ok 成功 403 forbidden 没有权限访问 404 not found 未找到页面 500 server internal error 服务器内部错误 响应头 时间 服务器 内容长度 内容类型 常见http响应设置php针对http协议（响应）进行了底层设计，可以通过函数header来实现修改响应头。 header可以设计http响应，因为http协议特点是：响应行，响应头（空行结尾）响应体。认为通过header设计响应头的时候，不应该有任何内容的输出，所以一旦产生内容输出，系统都会认为响应头结束了，响应体开始了，所以如果先输出内容后设置响应头（header使用），理论设置无效。 在php5以后，增加程序内容缓存内容：允许通过服务器在输出内容的时候，不直接返回浏览器而是先在服务器端使用程序缓存保留，有了该内容后，在程序缓存内会自动调整响应头和响应体（允许响应头在已经输出的内容之后在设置），但是会进行警告。 因此header设置响应体之前不要有任何输出 location 重定向 立即跳转（响应体不用解析） 浏览器在解析服务器响应的时候，先判定响应行，继续响应头，最后响应体，location在响应头中，所以浏览器一旦看见该协议便不再向下解析。 refresh 延迟重定向 定时跳转（响应体会解析） content-type 内容类型 mime类型 通过内容告知（mime)，浏览器正确解析内容 content-disposition 内容类型，mime类型扩展，激活浏览器文件下载对话框，浏览器在解析内容的时候，默认是直接解析的，那么有时候需要浏览器不解析，当作内容下载成文件。 12&lt;?php header('content-disposition:attachment;filename=名字'); php模拟http请求浏览器发送http请求向我们的服务器，而我们可以利用php脚本(curl)在我们的服务器里模拟http请求去访问另外一台服务器(也可以自我访问服务器) 原理： curl是一个开源库，支持很多协议，包含http,ftp等。 前提条件：http协议的客户端、服务器模式，http协议不一定局限于浏览器访问，自己访问自己。 curl 扩展库使用： 建立连接 curl_init() 激活curl 连接功能 设置请求选项 curl_setopt() 设定选项 http://php.net/manual/zh/function.curl-setopt.php 执行请求 curl_exec() 执行选项（与服务器发送请求），得到服务器的返回内容 关闭连接 curl_close() 关闭资源 1234567&lt;?php $ch=curl_init()//建立资源 //链接选项 curl_setopt($ch,CURLOPT_URL.'127.0.0.1/index.php')//连接选项 访问另外一台服务器 curl_setopt($ch,CURLOPT_RETURNTRANSFER,TRUE);//文件流形式返回 $c=curl_exec($ch);//执行 curl_close($ch);//关闭 文件编程文件编程指利用php对文件（文件夹）进行增删改查的操作。 目录操作创建目录结构(文件夹) mkdir(url) 创建成功返回true,失败返回false。 错误忽视符号：@ 如果文件夹已经存在了，mkDir(url) 会报错，但是我们不想要他报错（只需要文件夹存在）那么 @mkDir(url) 就可以了 删除 rmdir(url) 读取 将文件夹（路径）按资源方式打开 1 opendir() 打开资源，返回一个路径资源，包含指定目录下的所有文件（文件夹） 2 readdir() 从资源中读取指针所在位置的文件名字，然后指针下移，知道指针移出资源 关闭资源：closedir() 任何目录都包含. 自己的目录 和 .. 上级目录 读取所有内容： 12345678&lt;?php $arr=array(); $r=opendir(url); while($f=readdir($r))&#123;//类似于数据库的操作，全部拿出来 $arr[]=$f; &#125; var_dump($arr); closedir($r); 其它函数 dirname(url) 得到上一层目录,就是把文件夹名或者文件名在url中去掉 realpath(url) 得到真实路径（目录路径），如果是文件那么得到false is_dir(url) 判断是否为路径 scandir(url) 获取一个指定路径下的所有文件，以数组的形式返回，相当于opendir/readdir/closedir 递归遍历目录指定一个目录，将其下的所有文件和目录，及目录下的所有内容输出。 设计思路： 设计一个能够遍历一层文件的函数 如果遍历到的文件是目录，应该调用当前函数，注意. 和 .. 递归出口：该目录没有任何子文件夹。 1234567891011121314151617181920212223242526&lt;?php $dir = '../'; function my_scandir($dir, $lv = 0) &#123; // 不是路径 if (!is_dir($dir)) &#123; dir($dir.'&lt;br/&gt;'); &#125; // 遍历目录 $file = scandir($dir); foreach ($file as $value) &#123; // 排除'.' 和'.. if ($value == '.' || $value == '..') &#123; continue; &#125; echo $value.'&lt;br&gt;'; for ($i = 0; $i &lt; $lv * 4; ++$i) &#123; echo '&amp;nbsp'; &#125; $file_dir = $dir.'/'.$value; //构造目录，$value是一个文件名字 if (is_dir($file_dir)) &#123; my_scandir($file_dir, ++$lv); //一定要传路径 &#125; &#125; &#125; my_scandir($dir); 文件操作php5 常见文件操作函数 1） file_get_contents(url) 获取指定文件的所有内容， 返回布尔值 2） file_put_contents(url，content) 将指定内容写入指定文件内 返回的结果是字符串长度（字节）如果当前路径下不存在该文件，该函数会自动创建，但是目录不存在不行。 php4 文件操作函数 php4 中是将文件操作用资源的形式处理，不论是读还是写都依赖于资源指针。 1）fopen(url, 打开模式) 打开一个文件资源，限定打开模式 http://www.php.net/manual/zh/function.fopen.php 2）fread($res,长度) 从打开的资源读取一定长度 3）fclose(url) 关闭资源 其它文件操作： 1) is_file() 判断文件，不识别路径 2）filesize() 获取文件大小 3）file_exists() 判断文件，识别路径 4）unlink() 取消文件名字与磁盘地址的链接（删除文件） 5）filemtime() 获取文件最后一次修改时间 6 ）fseek() 设定fopen打开的文件指针位置 文件下载从服务器将文件通过http协议传输到浏览器，浏览器不解析保存成相应的文件。 提供下载方式可以通过a标签， &lt;a href=&quot;互联网绝对路径&quot;&gt;&lt;/a&gt; 但是a标签只能下载无法解析的文件（比如不能下载.html)，而且这样会暴露服务器存储数据的位置 通过php下载 设定响应头： 文件返回类型 image/jpg || application/octet-stream （以流的形式下载文件,这样可以实现任意格式的文件下载。） 文件的计算方式：accept-ranges:bytes 设定下载提示：content-disposition:attachment;filename=’文件名字’ 设定文件大小：accept-length： 会话技术用户打开一个浏览器，访问某个web站点，在这个站点点击多个超链接，访问多个web资源，整个过程称之为一个会话。 http协议的特点是无状态/无连接，当一个浏览器连续多次访问一个服务器时，服务器是无法区分多个操作系统是否来自同一个浏览器(用户)。会话技术就是通过http协议想办法让服务器能够识别来自同一个浏览器的多次请求，从而方便浏览器（用户）在访问同一个网站的多次操作中，能够持续进行而不需要进行额外的身份验证。 分类cookie技术 是在http协议下，服务器或脚本可以维护客户工作站上信息的一种方式。cookie 是由web服务器保存在用户浏览器（客户端）上的小文本文件（http响应头），他可以包含有关用户的信息，无论何时用户链接到服务器,站点都可以访问cookie信息。 session技术 时域：指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间经过的时间，以及如果需要的话，可能还有一定的操作空间，session技术是将数据保存到服务器端,无论用户何时连接到服务器，站点都可以访问session信息。 session技术的实现依赖于cookie技术 区别： — cookie session 安全性 存储浏览器端，安全性低 存储服务器端，安全性高 数据大小 数量大小都有限制（20个/4k） 不限 数据类型 简单数据，数值 字符串 复杂数据 自动序列化 保存位置 浏览器 服务器 cookie服务器将数据通过http响应存储到浏览器上,浏览器可以在以后携带对应的cookie数据访问服务器。 1 第一次请求时，php通过setcookie 函数将数据通过http协议响应头传输浏览器 2 浏览器在第一次响应时将cookie数据保存到浏览器 3 浏览器后续请求同一个网站的时候，会自动检测是否存在cookie数据，如果存在将在请求头中将数据携带到服务器。 4 php 执行的时候会自动判断浏览器是否携带cookie，如果携带，就自动保存到$_COOKIE中 5 利用$_COOKIE访问Cookie数据 基本使用创建cookie setcookie(名字，值) 名字为字符串 ，值必须时简单类型字符串或者整数 具体的cookie内容在谷歌浏览器中的设置-&gt;内容设置-&gt;cookie中可以查看 访问cookie值 $_COOKIE 预定义变量 得到的是数组 cookie可以实现跨脚本共享数据 生命周期cookie在浏览器生存时间（浏览器在下次访问服务器的时候是否携带cookie） 默认（不设定）时的生命周期：关闭浏览器（会话结束） 设定一个常规时间戳的周期，通过setcookie的第三个参数确定，setcookie(‘a’,’a’,time()+时间)，一定要加时间戳。 设定为0的周期，第三个参数如果为0的话就是默认设置 删除一个cookie的做法：服务器没有权限没有去操作浏览器上的内容，可以通过设定生命周期让浏览器自动判定cookie是否有效，无效就清除 123&lt;?php setcookie('a1','');//清空内容 setcookie('a2','a2',time());//过期 作用范围默认（不设定）的范围 不同的文件夹层级中，设定的cookie默认是在不同的文件夹下有访问限制。上层文件夹中设定的cookie可以在下层（子文件夹）中访问，而子文件夹中设定的cookie不能在上层文件夹中访问。 设定为/ 告知浏览器当前的cookie的作用范围时网站根目录,setcookie的第四个参数 跨子域 在同一级别域名下，可以有多个子域名 不同的域名（主机）之间不能共享cookie 可以通过setcookie的第五个参数控制—有效域名 在设定域名访问的时候设定上级域名即可：we.com 所有以we.com结尾的域名都可以访问该cookie 数组的使用设置形式setcookie(&#39;c[k1]&#39;,&#39;value&#39;) 读取形式 $_COOKIE[&#39;c&#39;][k1] session php碰到session_start() 时开启session会话，会自动检测sessionID 如果cookie中存在，使用现成的。 如果cookie不存在，创建一个sessionID，并通过响应头以cookie的形式保存到浏览器上。 初始化超全局变量$_SESSION 为一个空数组 php通过sessionID去指定位置（session文件存储的位置）匹配对应的文件 不存在该文件，创建一个sessionID 命名文件 存在该文件，读取文件内容（反序列化），将数据存储到$_SESSION中 脚本执行结束,将$_SESSION中保存所有数据序列化存储到sessionID 对应的文件中 基本使用启用session，任何时候都要开启session（脚本使用到$_SESSION就开启一次） 12345&lt;?php session_start();//开启session //设置sessions数据 $_SESSION['name']='mark'; $_SESSION['hobby']=array("footbal","basktbal"); 可以跨脚本访问，实现数据的共享。（两个脚本都要有session_start()） 删除一个session信息使用unset() 删除全部的数据：$_SESSION=array() 基础配置在php.ini中 session.name 保存到cookie中sessionID对应的名字 session.auto_start 是否自动开启session（无需手动session_start()) session.save_handler session数据的保存方式，默认是文件形式 session.save_path session文件存储到的位置（需要修改，默认系统的临时文件存储） session.cookie_lifetime sessionID对应cookie的生命周期，默认是会话结束 session.cookie_path sessionID在浏览器存储之后允许服务器访问的路径 session.cookie_domain 允许访问的子域 全局配置，直接在php.ini中修改 脚本中配置，ini_set(名称，值) 函数在运行中设定某些配置项（只会对当前运行的脚本有效） 销毁session删除session对应的session文件 session_destroy() 垃圾回收机制给session文件指定生命周期，通过文件最后的修改时间与生命周期进行结合判断，过期了就可以把对应的session文件删除 123任何一次session开启（seesion_start)，session都会尝试读取session文件读取session文夹后，有几率触发垃圾回收机制垃圾回收机制会自动读取所有的seesion文件的最后编辑时间与生命周期进行判断。 垃圾回收的配置 session.gc_maxlifetime= 1440 session文件的最大生命周期是1440秒 session.gc_probability= 1 垃圾回收概率分子 session.gc_divisor=1000 垃圾回收概率分母 禁用cookie后的使用session技术的使用需要利用cookie技术来保存sessionID,从而使php能够得到相同的seesionID,从而访问相同的session文件。 没有cookie，脚本执行到 session_start 就会产生一个新的sessionID 和session文件。 解决方案：session_id 和session_name 来获得sessionID 或者 name 从而解决session_start产生新的sessionID 123456789101112&lt;?php session_start();//开启 //获取sessionID和名字 $id= session_id(); $name=session_name();//默认phpsessid //设置内容 $_SESSION['NAME']='MARK'; //传递给另外一个脚本 echo "&lt;a href = 'tmp.php?&#123;$name&#125;=&#123;$id&#125;'&gt;click&lt;/a&gt;"; 另外一个脚本接受 123456789&lt;?php $name=session_name(); $id=$GET['name']; //设定sessionID session_id($id); //访问 session_start();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的基本程序设计结构]]></title>
    <url>%2F2021%2F06%2F29%2FJava%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[-&gt; 源代码的文件名必须与公共类的名字相同。 数据类型在Java中共有8种基本类型，其中有4种整型，2种浮点类型，1种表示Unicode编码字符类型的char，1种表示真值的boolean类型。 整型整型用于表示没有小数部分的数值， 它允许是负数。Java 提供了 4 种整型。 类型 存储需求 取值范围 int 4字节 -2 147 483 648 - 2 147483647 (正好超过 20亿) short 2字节 -32768 - 32767 long 8字节 -9 223372 036 854 775 B08 - 9 223372 036854 775 807 byte 1字节 -128-127 在 Java 中， 整型的范围与运行 Java代码的机器无关。 长整型数值有一个后缀 L 或 1 (如 4000000000L)。十六进制数值有一个前缀 0x 或 0X (如 0xCAFE 八进制有一个前缀 0, 例如， 010 对应八进制中的 8。很显然， 八进制表示法比较 容易混淆， 所以建议最好不要使用八进制常数。 从 Java7 开始， 加上前缀 0b 或 0B 就可以写二进制数。例如，0b1001就是 9。另外，同样是 从 Java7开始，还可以为数字字面量加下划线，如用 1_000_000(或者0b1111_0100_0010_0100_0000) 表示一百万。这些下划线只是为丫让人更易读。Java 编译器会去除这些下划线。 浮点类型 类型 存储需求 取值范围 float 4字节 大约 ± 3.402 82347E+38F (有效位数为 6 ~ 7 位） double 8字节 大约 ± 1.797693 134862315 70E+308 (有效位数为 15 位&gt; float类型的数值有一个后缀 F 或 f (例如，3.14F)。没有后缀 F 的浮点数值（如 3.14 ) 默 认为double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。 所有的浮点数值计算都遵循 IEEE 754规范。具体来说，下面是用于表示溢出和出错情况 的三个特殊的浮点数值： •正无穷大 常量 Double_POSITIVE_INFINITY •负无穷大 常量 Double.NEGATIVE_INFINITY •NaN (不是一个数字）常量 Double.NaN 一 正整数除以 0 的结果为正无穷大。计算 0/0 或者负数的平方根结果为 NaN。 如果想检测一个特定值x是否等于 Double.NaN，请使用Double.isNaN(x),不要使用x==Double.NaN char类型char 类型原本用于表示单个字符。不过，现在情况已经有所变化。 如今，有些 Unicode 字符可以用一个 char值描述，另外一些 Unicode 字符则需要两个char 值。 Unicode中的坑Unicode 转义序列会在解析代码之前得到处理。 例如，”\u0022+\u0022”并不是一 个由引号（U+0022) 包围加号构成的字符串。 实际上， \u0022 会在解析之前转换为””+””， 这会得到也就是一个空串。 更隐秘地， 一定要当心注释中的 \u。注释 // \u00A0 is a newline 会产生一个语法错误， 因为读程序时 \u00A0 会替换为一个换行符类似地， 下面这 个注释 // Look inside c:\users 也会产生一个语法错误， 因为 \u 后面并未跟着 4 个十六进制数。 码点与代码单元在设计 Java 时决定采用 16 位的 Unicode 字符集。 码点（code point)： 是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中， 码点采用十六进制书写，并加上前缀 U+, 例如 U+0041 就是拉丁字母 A 的码点。 Unicode 的 码点可以分成 17 个代码级别（code plane)。第一个代码级别称为基本的多语言级别（basic multilingual plane), 码点从 U+0000 到 U+FFFF, 其中包括经典的 Unicode 代码；其余的 16 个级别码点从 U+10000 到 U+10FFFF, 其中包括一些辅助字符（supplementary character)。 代码单元（code unit)：在基本的多语言级别中，每个字符用 16 位表示，通常被称为代码单元（code unit）; 而辅助字符采用一对连续的代码单元 进行编码。这样构成的编码值落人基本的多语言级别中空闲的 2048字节内， 通常被称为替 代区域（surrogate area) [ U+D800 ~ U+DBFF 用于第一个代码单元，U+DC00 ~ U+DFFF 用 于第二个代码单元]。 char代表一个代码单元，不代表一个码点，一个码点可能由两个代码单元组成。 boolean 类型boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间 不能进行相互转换。 变量变量名必须是一个以字母开头并由字母或数字构成的序列。需要注意，与大多数程序设 计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括’A’ ~ ’Z’、 ’a‘ ~ ’z’、 或在某种语言中表示字母的任何 Unicode 字符。 尽管 $ 是一个合法的 Java 字符， 但不要在你自己的代码中使用这个字符。它只用 在 Java 编译器或其他工具生成的名字中。 1) 局部变量初始化（局部变量：函数、语句中的变量，只在所属区域内有效） 局部变量声明后，Java虚拟机不会自动给它初始化为默认值。 因此对于局部变量，必须经过显示的初始化，才能使用它。 如果使用一个没有被初始化的局部变量，编译器会报错。 2) 对于类的成员变量，不管程序有没有显示的初始化，Java虚拟机都会先自动给它初始化为默认值。 3)对于数组，数组引用类型的变量的默认值为null。当数组变量实例化后，如果没有显式地为每个元素赋值，Java会把该数组的所有元素初始化为相应类型的默认值。 C 和C++ 区分变量的声明与定义。 例如： int i = 10; 是一个定义。 定义：给i分配了空间。 而 extern int i; 是一个声明，外部变量。声明：只是有这个变量（可能在该文件之外），但是没有给其分配空间。 在 Java 中， 不区分变量的声明与定义。 （因为java没有外部变量） 常量在 Java中， 利用关键字 final指示常量。关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上, 常量名使用全大写。 final double CM_PER_INCH = 2.54; 运算符strictfp可移植性是 Java 语言的设计目标之一 ， 无论在哪个虚拟机上运行，同一运算应该 得到同样的结果3 对于浮点数的算术运算， 实现这样的可移植性是相当困难的。double 类型使用 64 位存储一个数值， 而有些处理器使用 80 位浮点寄存器这些寄存器增加了 中间过程的计算精度. 例如， 以下运算： double w = x * y / z; 很多Intel处理器计算 x * y，并且将结果存储在 80 位的寄存器中， 再除以 z 并将结 果截断为 64 位„ 这样可以得到一个更加精确的计算结果， 并且还能够避免产生指数溢出但是，这个结果可能与始终在 64 位机器上计算的结果不一样。 因此，Java 虚拟机 的最初规范规定所有的中间计算都必须进行截断这种行为遭到了数值计算团体的反对。 截断计算不仅可能导致溢出， 而且由于截断操作需要消耗时间， 所以在计算速度上实际 上要比精确计算慢。 为此，Java 程序设计语言承认了最优性能与理想结果之间存在的冲 突，并给予了改进。在默认情况下， 虚拟机设计者允许对中间计算结果采用扩展的精度。 但是， 对于使用 strictfp 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。例如，可以把 main 方法标记为 public static strictfp void main(String[] args) 于是， 在 main 方法中的所有指令都将使用严格的浮点计算。如果将一个类标记为 strictfp, 这个类中的所有方法都要使用严格的浮点计算。 实际的计算方式将取决于 Intel 处理器的行为。在默认情况下，中间结果允许使用扩展 的指数， 但不允许使用扩展的尾数（Intel 芯片在截断尾数时并不损失性能） 。因此，这两种 方式的区别仅仅在于采用默认的方式不会产生溢出， 而采用严格的计算有可能产生溢出。 如果没有仔细阅读这个注释， 也没有什么关系。对大多数程序来说， 浮点溢出不属 于大向题。 数值类型之间的转换在下图中有 6 个实心箭头，表示无信息丢失的转换；有 3 个虚箭头， 表示可能有精度损失的转换。 例如，123 456 789 是一个大整数， 它所包含的位数比 float 类型所能够表达的位数多。 当将这个整型数值转换为 float 类型时，将会得到同样大小的结果，但却失去了一定 的精度。 int n = 123456789; float f= n;//f is 1.23456792E8 当使用上面两个数值进行二元操作时（例如 n + f，n 是整数，f 是浮点数)， 先要将两个操作数转换为同一种类型，然后再进行计算。 •如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 •否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 •否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 •否则， 两个操作数都将被转换为 int 类型。 12345byte b1 = 11;byte b2 = 12;byte b3 = 0;b3=b1+b2;//错误，两个操作数会被转换成int类型b3=(byte)(b1+b2);//正确，int需要强制类型转换 强制类型转换在必要的时候， int类型的值将会自动地转换为 double 类型。但另 一方面，有时也需要将 double转换成 int。 在 Java中， 允许进行这种数值之间的类型转换。 当然， 有可能会丢失一些信息。 例如： double x * 9.997; int nx = (int) x; 这样， 变量 nx 的值为 9。强制类型转换通过截断小数部分将浮点值转换为整型。 可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如， X += 4; 等价于： x = x + 4; 如果运算符得到一个值， 其类型与左侧操作数的类型不同， 就会发生强制类型转换。 例如，如果 x 是一个 int, 则以下语句 x += 3.5; 是合法的， 将把 X 设置为（int)(x+ 3.5)。 字符串从概念上讲， Java 字符串就是 Unicode 字符序列。 例如， 串“ Java\u2122” 由 5 个 Unicode 字符 J、a、v、a 和™。Java 没有内置的字符串类型， 而是在标准 Java类库中提供了 一个预定义类，很自然地叫做 String。 与绝大多数的程序设计语言一样，Java语言允许使用 + 号连接（拼接）两个字符串。 当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。 不可变字符串String greeting = “Hello”; String类没有提供用于修改字符串的方法6 如果希望将 greeting 的内容修改为“ Help!”， 不能直接地将 greeting的最后两个位置的字符修改为 ‘ p’ 和 ‘ ！ 、这对于 C 程序员来说，将会感到无从下手 。如何修改这个字符串呢？ 在 Java中实现这项操作非常容易。首先提取需 要的字符， 然后再拼接上替换的字符串： greeting = greeting.substring(0, 3) + “p!”; 上面这条语句将 greeting 当前值修改为“ Help !”。 由于不能修改 Java 字符串中的字符， 所以在 Java 文档中将 String类对象称为不可变字 符串， 如同数字 3 永远是数字 3—样，字符串“ Hello” 永远包含字符 H、 e、1、1 和 o 的代 码单元序列， 而不能修改其中的任何一个字符。 当然， 可以修改字符串变量 greeting，让它 引用另外一个字符串， 这就如同可以将存放 3 的数值变量改成存放 4一样。 为了弄清具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量 指向存储池中相应的位置。如果复制一个字符串变量， 原始字符串与复制的字符串共享相同 的字符。 字符串是否相等可以使用 equals方法检测两个字符串是否相等。 对于表达式： s.equals(t) 如果字符串 s 与字符串 t 相等， 则返回 true ; 否则， 返回 false。 一定不要使用 == 运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串是否放置在同一个位置上。当然， 如果字符串放置在同一个位置上， 它们必然相等。但是， 完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。 如果虚拟机始终将相同的字符串共享， 就可以使用==运算符检测是否相等。但实际上 只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。因此，千万不 要使甩 == 运算符测试字符串的相等性， 以免在程序中出现糟糕的 bug。 码点与代码单元length（） 方法将返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。不是码点数量，所以有可能一个字符的length()值是2。 要想得到实际的长度，即码点数量，可以调用： int cpCount = greeting.codePointCount(0, greeting.length()); 如果想要遍历一个字符串，并且依次査看每一个码点， 可以使用下列语句： 12 int cp = sentence.codePointAt(i); if (Character.isSupplementaryCodePoint(cp)) i += 2; else i++; 可以使用下列语句实现回退操作： 123i-- ； if (CharacterssSurrogate(sentence.charAt(i))) i-- ; int cp = sentence.codePointAt(i); 显然， 这很麻烦。更容易的办法是使用 codePoints 方法， 它会生成一个 int 值的“ 流”， 每个 int 值对应一个码点。（流将在卷 II 的第 2 章中讨论〉 可以将它转换为一个数组，再完成遍历。intD codePoints = str.codePoints（）.toArray（）;反之，要把一个码点数组转换为一个字符串， 可以使用构造函数。String str = new String(codePoints, 0, codePoints.length); 输入与输出格式化输出可以使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出： String message = String.format(“Hello, %s. Next year, you’ll be %d”, name, age); 文件输入输出要想对文件进行读取，就需要一个用 File 对象构造一个 Scanner 对象，如下所示： Scanner in = new Scanner(Paths.get(&quot;niyflle.txt&quot;), &quot;UTF-8&quot;); 如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠： “ c:\\mydirectory\\myfile.txt” 现在，就可以利用任何一个 Scanner方法对文件进行读取。 要想写入文件， 就需要构造一个 PrintWriter 对象。在构造器中，只需要提供文件名： PrintWriter out = new PrintWriter(“myfile.txt”, “UTF-8”); 如果文件不存在，创建该文件。可以像输出到 System.out—样使用 print、 println 以及 printf 命令。 12345678910111213public class FileFormat &#123;private static PrintWriter pw;private static Scanner sc;public static void main(String[] args) throws IOException &#123; pw = new PrintWriter("src/test.txt"); pw.println("321"); pw.close();//不关闭就读文件会报错 sc = new Scanner(Paths.get("src/test.txt")); String str = sc.next(); System.out.println(str);//321 sc.close();&#125;&#125; 数组在声明数组变量时， 需要指出数组类型 （数据元素类型紧跟 []) 和数组变量的名字。下面声明了整型数组 a: int[] a; 不过， 这条语句只声明了变量 a， 并没有将 a 初始化为一个真正的数组。应该使用 new 运算 符创建数组。 int[ ] a = new int[100]; 这条语句创建了一个可以存储 100 个整数的数组。数组长度不要求是常量： newint[n] 会创建 一个长度为 n 的数组。 for each 循环这种增强的 for 循环的语句格式为： for (variable : collection) statement 定义一个变量用于暂存集合中的每一个元素， 并执行相应的语句（当然，也可以是语句块)。 collection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象（例如 ArrayList)。 数组初始化以及匿名数组在 Java中，提供了一种创建数组对象并同时赋予初始值的简化书写形式。下面是一 例子： int[] smallPrimes = { 2, 3, 5, 7, 11, 13 }; 请注意， 在使用这种语句时，不需要调用 new。 甚至还可以初始化一个匿名的数组： new int[] { 17, 19, 23, 29, 31, 37} 这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的 个数。使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。例如： smallPrimes = new int[] { 17, 19, 23, 29, 31, 37}; 命令行参数每一个 Java应用程序都有一个带 String arg[]参数的 main方法。这个参数表明 main方法将接收一个字符串数组， 也就是命令行参数 如果使用下面这种形式运行这个程序： java Message -g cruel worldargs 数组将包含下列内容: args[0]:”-g” args[1] :”cruel” args[2]:”world” 不规则数组Java 实际上没有多维数组，只有一维数组。多维数组被解释为“ 数组的数组。 由于可以单独地存取数组的某一行， 所以可以让两行交换。 123double[] temp = balances[i];balances[i] = balances[i + 1 ]; balances[i + 1 ] = temp; 可以方便地构造一个“ 不规则” 数组， 即数组的每一行有不同的长度。 int[][] odds = new int[MAX + 1 ][]; 接下来， 分配这些行。 for (int n = 0; n &lt;= MAX; n++) odds[n] = new int[n + 1]; 高精度运算如果基本的整数和浮点数精度不能够满足需求， 那么可以使用jaVa.math 包中的两个 很有用的类：Biglnteger 和 BigDecimal 这两个类可以处理包含任意长度数字序列的数值。 Biglnteger类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。 使用静态的 valueOf方法可以将普通的数值转换为大数值： Biglnteger a = Biglnteger.valueOf(100); 遗憾的是，不能使用人们熟悉的算术运算符（如：+ 和 *) 处理大数值。 而需要使用大数 值类中的 add 和 multiply 方法。 Biglnteger c = a.add(b); // c = a + b Biglnteger d = c.nultipiy(b.add(Biglnteger.valueOf(2))); // d = c * (b + 2)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术卷1读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 闭包]]></title>
    <url>%2F2021%2F06%2F29%2FJavaScript%20%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[我研究了两天，终于把闭包啃下来了… 函数 声明 表达式首先我们要区分下函数的声明与函数表达式 1234567声明：function test ()&#123;&#125;表达式：var test = function() abc()&#123;&#125; //test.name=abcvar demo = function() &#123;&#125;//匿名函数 demo.name=demo 这两个概念理解清楚会在后面经常出现，注意进行区分，函数声明与函数表达式不一样。 预编译理解JS代码的执行顺序：首先会扫一遍代码有没有语法错误，有错误的话就报错就不执行了，没错误就会进行预编译。 首先说明函数的预编译，然后再说明全局的预编译。说明的顺序与执行的顺序是相反的，两者很相似。 函数 预编译首先需要区分的是变量声明与赋值 var a=100 var a 是声明 a=100 是赋值，注意区分 预编译发生在函数执行的前一刻 分为4步： 12345671 创建AO对象（Activation Object) 也就是作用域 专业名称叫做执行期上下文2 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined3 将实参值和形参值统一4 在函数体里面找函数声明 （函数表达式不行），值赋予函数体 接下来我们举个例子来理解这4步 123456789101112function fn(a) &#123; console.log(a); var a = 123; console.log(a); function a() &#123; &#125; console.log(a); var b = function () &#123; &#125; console.log(b); function d() &#123; &#125; &#125; fn(1); 试问控制台的输出。我们按着预编译的步骤进行分析 在系统刚要执行fn(1)时 1 创建AO对象（Activation Object) 系统内部创建了一个AO对象 123AO&#123; &#125; 2 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined 函数的形参为a 变量声明有 a b, 因此 1234AO&#123; a:undefined, b:undefined&#125; 3 将实参值和形参值统一 1234AO&#123; a:1, b:undefined&#125; 4 在函数体里面找函数声明 （函数表达式不行），值赋予函数体 12345AO&#123; a: function a() &#123; &#125;, b: undefined, d：function d() &#123; &#125;&#125; 到此，预编译过程完毕了。 接下来开始运行fn(1) AO相当于一个仓库，变量的值就从里面拿 所以第一个控制台输出function a() { } 第二个控制台输出时a被赋值为123，因此输出123 第三个同上 第四个b被赋值了一个函数，因此输出函数。 全局 预编译全局预编译与函数预编译的主要不同是全局预编译没有形参，产生GO对象 因此只有三步： 123451 创建GO对象（Global Object) GO对象就是window对象2 找变量声明，将变量和形参名作为GO属性名，值为undefined3 在全局里面找函数声明 ，值赋予函数体 系统的全局预编译要比函数预编译先，可以看下面的例子： 12345678910global =100; function fn()&#123; console.log(global); global = 200; console.log(global); var global = 300; &#125; fn(); var global; 还是说出控制台的输出 1 类似的，系统产生的GO对象为 1234GO&#123; global:undefined, fn:function fn()&#123;&#125;&#125; 2 当fn执行前期有 12345678GO&#123; global:100, fn:function fn()&#123;&#125;&#125;AO&#123; global:undefined&#125; fn开始执行。 因此第一个输出undefined， 第二个输出200. 补充上述操作可以简单的理解为 123函数声明整体提升变量 声明提升 这也是函数体写在函数调用下面可以运行的原因 另外 1 imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量为全局对象所有。（window） 123456789a=10;--&gt;window.afunction test()&#123; var b=c=123;&#125;//AO识别不了c变量，因为c没有进行声明，直接进行赋值//c被GO识别console.log(c);//window.c-&gt;123console.log(b);//undefined 2 一切声明的全局变量，都是window的属性 1var b=11;--&gt;window.b 作用域链根据我们以前的经验，函数是可以访问外部变量的，这就与作用域有关 123[[scope]]:每个JS函数都是一个对象，对象中有些属性我们可以访问，但是有些不可以，这些属性仅供JS引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域，其中存取了运行期上下文的集合。作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。 接下来我们进行解释： 前面我们知道了JS文件运行前系统创建GO对象，函数运行前创建AO对象。 产生的对象会放在作用域链的首位。 比如： 123456function a()&#123; function b()&#123; &#125; b();&#125;a(); a执行时，会产生作用域链，如图： 作用域链的第一位是a的AO，第二位是GO 当b函数执行时，会在a的基础上增加自己的AO b作用域链的第一位是自己产生的AO，后两位与a的作用域链一样。（类似于站在巨人的肩膀上那样…) 两个链指向的a AO是同一个，如果b将某一变量值改变，在a里面调用时，变量值也会变。 scope chain 就是作用域链，js执行时会在链的首端找变量，如果AO里没有该变量的话就会依次往后寻找。 当a的函数执行完毕后，会剪断作用域链与a AO的联系。但是a AO里存着b函数，现在，a AO失去了联系，也就是可以说b函数可以说是”消失“了。 下次a函数执行时，会产生一个新的a AO。 观察这个例子，控制台会输出什么。 12345678910 function a()&#123; var num=0; function b()&#123; num++; console.log(num); &#125; b(); &#125;a();a(); 这个很简单，会输出1 1 下面这个呢 1234567891011function a()&#123; var num=0; function b()&#123; num++; console.log(num); &#125; return b;&#125;var t=a();t();t(); 答案是 1 2 其也可以作用域链解释 在var t=a()执行后，a函数已经执行完毕，剪断了a AO，然后t()开始执行。如图 输出1 虽然a函数a AO失去了联系，但是b函数还连着a AO,b执行完毕后，剪断与b AO的联系。这样的话，a的AO与b函数就绑定了。 第二次调用时，会在上图的基础上num=1时加1，因此输出2。 这两个例子的不同就是第二个例子在b函数被销毁前（也就是a函数与a AO剪断关系前）将b函数当作返回值返回到了全局中。 这就涉及到了本篇文章的主角—闭包 闭包当内部函数被保存到外部时，将会生产闭包。闭包会导致原有作用域链不释放，造成内存泄漏。 先说明一下内存泄漏，上面那个例子，本来a函数执行完，应该剪断与a AO的联系，但是b函数却保存下来，如果函数嵌套的比较深，就会造成函数的作用域链很长，被电脑保存起来，这就时内存泄漏（反向理解）。 闭包可以简单理解为内部函数保存了外部函数的劳动。 接下来是最常遇见的闭包情况： 12345678910111213function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; arr[i]=function()&#123; console.log(i); &#125; &#125; return arr;&#125;var t=test();for(var j =0; j&lt; 10;j++)&#123; t[j]();&#125; 控制台会输出10个10,而并不是0，1，2，….9。 需要注意的是，arr[i]=function(){}，赋值时，函数体并不执行。只有当调用时，函数才会执行（函数名后面跟着个小括号），如果改成这样arr[i]=function(){}() 这是函数就会立即执行了，输出的也是0 ，1，2，….9了，当然，返回值数组里放的就不是函数体了。（会报错，但是会输出） 在t=test()时，test()运行完毕，将10个函数存在arr里面 也就是说t[j]执行时，arr[j]里保存的函数作用域链有一个位置保存了test AO，此时test AO里面的i=10。arr[j] AO里没有i变量，因此在test AO里那了 i 值，所以输出了10。（10个arr[j]的作用域共同连着一个test AO） 这不是我们想要的结果，我们想让控制台输出0 1 2 3…9,因此就有解决方案。 立即执行函数一般函数被声明后,会一直等待函数被执行。直到js文件运行完毕，才会被销毁。 立即执行函数，顾名思义，就是该函数被读到时会立即执行，执行完毕后被销毁。 形式为: 12(function ()&#123;&#125;())；W3C 建议（function ()&#123;&#125;)(); 上面闭包的举的粗略解决方案，就用了类似于立即执行函数，在后面添加() (执行符号)，立即执行后，函数名会被销毁。 12var t = function ()&#123;&#125;();console.log(t)；//undefined 只有表达式才能被执行符号执行() 12function a()&#123;&#125;();//不行，这是声明+function a()&#123;&#125;();//可以，这是表达式 知道了立即执行函数可以解决这个问题，因此我们可以把代码改成： 123456789101112131415function test() &#123; var arr = []; for(var i =0; i&lt; 10; i++)&#123; (function(i)&#123; arr[i]=function()&#123; console.log(i); &#125; &#125;(i)) &#125; return arr; &#125; var t = test(); for (var j = 0; j &lt; 10; j++) &#123; t[j](); &#125; 这样控制台就输出0，1， 2，…9了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 对象]]></title>
    <url>%2F2021%2F06%2F29%2FJavaScript%20%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概念对象是JavaScript的一个基本数据类型，是一种复合值，它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。即属性的无序集合。 创建方法1 对象字面量/对象直接量 （字面量就是指这个量本身，比如字面量3。也就是指3. 再比如 string类型的字面量”ABC”, 这个”ABC” 通过字来描述。 所以就是字面量，虽然很难下定义。 你就理解成一眼就能知道的量。） 1234567var obj =&#123; name:"xiaoming", age: 12, eat : function()&#123; console.log("food"); &#125;,&#125; 2 构造函数 2.1 自定义构造函数 类似于创建了一个工厂，可以批量生产对象，比如： 123456789101112function Car(color)&#123;//相当于一个工厂模板 this.color = color; this.name="BMW"; this.height = "1400"; this.weight = 1000; this.run = function()&#123; this.health --; &#125;&#125;var car1 = new Car("red");var car2 = new Car("blue"); 构造函数内部原理（有new)//用来区分构造函数与函数 1） 在函数体最前面隐式的加上 this={} 2） 执行 this.xxx=xxx; 3） 隐式的返回this 2.2 系统自带的构造函数 比如 new Object() //不常用 new String() new Number() 等等，相当于系统把“工厂模板写好了” 3 Object.create(原型) 123456Person.prototype.name="xiao";function Person()&#123; &#125;var person=Object.create(Person.prototype) 包装对象js里有原始值和对象。 对象可以随便的增加属性和方法。或删除属性和方法 {用delelte(对象.属性) }。 原始值应该是不能调用属性和方法的，但是js“可以调用”，这就是因为js在后台创建了包装对象。 1234var s="hello";s.index=1;var t=s.index;console.log(t)//undefined 这里给s设置了index属性，但是却无法访问，是因为包装对象在后台创建完成并返回值后会立即销毁。 细节如下： 12345var s="hello";s.index=1;//此时会创建一个new String("hello"),//并增加一个index属性=1，之后销毁var t=s.index;//该对象被销毁了，所以并不能访问console.log(t)//undefined 这就很好的解释了原始值调用属性的问题。比如： 123var str="123456";//创建new String("123456"),得到length返回后，销毁console.log(str.length);//6 原型定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 12345function Person()&#123;&#125;//在函数"出生时"，Person.prototype(原型)就被定义好了//Person.prototype是个对象，相当于Person生产出的对象的共同祖先var person = new Person(); 利用原型特点和概念，可以提取公用属性。 比如，Person.prototype.LastName=”li” 那么。通过Person()函数构造出的函数都会有这个LastName属性。值为”li”,当然，个体也可以更改LastName的值。 对象查看自己的构造函数 —&gt; constructor（构造器） 1234function Person()&#123;&#125;var person = new Person();person.constructor//functoion Person()&#123;&#125; constructor可以改变。 原型链对象查看原型：__proto__ （隐式属性） __proto__ 属性里面放的是原型 （__proto__ 前后有两个_） 例子： 12345function Person()&#123; //会有一个隐藏属性 //this =&#123;__proto__: Person.prototype&#125;当new时创建。参考上面的构造函数原理 //这里是一个钩子，当this里没有调用的属性是，会去__proto__指向的地址寻找&#125; __proto__ 的值可以修改,也就是说明自己可以更改自己的祖先。 12345678910111213141516function Grand()&#123; this.lastName="xiao";&#125;var grand = new Grand();function Father()&#123;&#125;var father =new Father();father.__proto__=grand;function Son()&#123;&#125;var son= new Son();son.__proto__=father;console.log(son.lastName);//xiao 这就构成了一个原型链，son没有lastName会按着原型链往上寻找，直到找到输出。 区分prototype 和 __proto__prototype是函数属性，代表该构造函数所产生的对象的”爹“，也是函数创建对象的__proto__ 所指 __proto__ 是一个对象的属性，它指向该对象的原型 12JS中每个对象都会有__proto__属性，默认为Object，例如：var a=&#123;&#125;;//这里对象a的__proto__属性就是Object 原型链的终端是Object.prototype, 而Object有toString方法，所以大部分对象都能调用toString()方法。 obj.toString()会输出[Object Object],输出的格式是[object 对象的类型] call/apply call/apply作用的是改变this指向 方法.call(this的指向，参数) 12345678910111213function Person(name, age, sex)&#123; this.name=name; this.age=age; this.sex=sex;&#125;function Student(name, age, sex, tel, grade)&#123; Person.call(this,name,age,sex); this.tel=tel; this.grade=grade;&#125;var student=New Student(...); 这样Student就包含了Person的属性 Person中的this指向了student apply的作用域call一样。 不同的是，call 需要把实参按照形参个数传进去。 apply 需要传一个argument，（就是在参数两边加[]) 继承传统方式： 原型链 过多的继承了没用的方法。 共享原型： 12345678910111213Father.prototyper=&#123; &#125;function Father()&#123; &#125;function Son()&#123;&#125;Son.prototype = Father.prototype 这样Father于Son就公用继承了一个原型。但是想要给Son单独增加原型属性，就会影响Father的属性，所以需要改进。 圣杯模式：找一个中间层 123456789101112131415161718Father.prototyper=&#123; &#125;function Father()&#123; &#125;function Son()&#123;&#125;function F()&#123; &#125;F.prototype = Father.prototypeSon.ptototype=New F() 这样只给F增加属性，不会影响到Father了。 对象枚举for…in 123456789101112var obj =&#123; name:"dfasdf", sex:"male", weight:123, eat: function()&#123; console.log("apple"); &#125;&#125;for(var prop in obj)&#123; console.log(prop);&#125; 会把对象的属性名和方法名赋给prop obj.prop系统内部会转换成obj[“prop”],寻找prop属性 所以用for…in输出对象，要用obj[prop] 属性就是字符串 hasOwnProperty() 可以用来判断是否是自己的属性（是自己的返回真，原型链上的返回假） in ”属性“ in obj 用来判断该属性是否是obj的属性，（包括原型链上的属性） instranceof 用来判断 A对象 是否是B函数构造出来的 A对象 instranceof B函数 看A对象的原型链 有没有B的原型 this函数预编译过程 this —&gt; window 全局作用域里 this—&gt;window call//apply 改变函数运行时this的指向 obj.func(),fun()里面的this指向obj 类数组对于一个普通的对象来说，有相应的length属性，（最好加上push) 那么虽然该对象并不是由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为“类数组对象”。 比如 1234567var obj=&#123; 0:"a", 1:"b", 2:"c", length:3, push:Array.prototype.push&#125; 特点： 可以利用属性名模拟数组的特性 可以动态的增长length属性 如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充。 push的原理： 1234Array.prototype.push=function(target)&#123; obj[obj.length]=target; obj.length++;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript DOM]]></title>
    <url>%2F2021%2F06%2F29%2FJavaScript%20DOM%2F</url>
    <content type="text"><![CDATA[概念DOM：文档对象模型 DOM—&gt; Document Object Model DOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml（没有CSS样式表）功能的一类对象的集合。 获取元素注意：节点与元素节点不一样，节点包含元素节点，注释节点，文本节点等等。 获取元素节点 名称 解释 document.getElementById() 元素id getElementsByTagName() 标签名 返回类数组 实时的选择，包括后面增加的 getElementsByName() 只有部分标签name可生效(表单 表单元素 img iframe) 返回类数组 getElementsByClassName() 类名 ie8(含)以下版本没有 querySelector() CSS选择器 ie7(含) 以下没有 非实时的选择（后面新加的无法选择） querySelectorAll() CSS选择器 ie7(含) 以下没有 非实时的选择（后面新加的无法选择） 基于元素节点的遍历 名称 解释 parentElement 返回当前元素的父节点（ie9（含）以下 不兼容） children 只返回当前元素元素子节点 node.childElementCount ===node.children.length 当前元素节点的子元素个数 ie9（含）以下 不兼容） firstElementChild 返回第一个元素节点 ie9（含）以下 不兼容） lastElementChild 返回的是最后一个元素节点 nextElementSibling/previousElementSlibing 返回后一个/前一个兄弟元素 节点属性通过节点.属性访问 名称 解释 nodeName 元素的标签名，以大写表示，只读 nodeValue Text节点或Comment节点的文本内容，可读写 nodeType 该节点类型 ，只读 attributes Element 节点的属性集合 attributes[0].value可以获得属性值 hasChildNodes() 判断有没有子节点 基本操作增 名称 解释 document.createElement() 创建元素节点 document.createTextNode() 创建文本节点 document.createComment() 创建注释节点 document.createDocumentFragment() 创建文档片段对象 插增加后插入才能在html中显示 名称 解释 parentNode.appendChild() 最后一位插入，相当于push() 把页面已有部分插入，相当于剪贴 parentNode.insertBefore(a,b) a在b之前插入 删 名称 解释 parent.removeChild() 父节点删除子节点 chid.remove() 子节点将自己删除 替换 名称 解释 parent.replaceChild(new,origin) 节点 对属性的修改Element 节点的一些属性 名称 解释 innerHTML 改变html内容 innerText 改变文字内容（老版本火狐不兼容） textContent(IE不好使) Element 节点的一些方法 名称 解释 ele.setAttribute(a，b) a属性名 b属性值 else.getAttribute(a) a属性名 date对象 与 定时器Date 对象Date 对象用于处理日期和时间。 创建 Date 对象的语法： 1var myDate=new Date() 注释：Date 对象会自动把当前日期和时间保存为其初始值。（时间戳） 自定义时间： new Date(year, month, day，hour, minute, second) month从零开始计数 date所用的方法：http://www.w3school.com.cn/jsref/jsref_obj_date.asp 循环定时器setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数， 两个参数： 函数体 时间（毫秒） 使用时注意事项：与事件绑定时，为了防止重复触发，首先要清除定时器，使用 clearInterval() ，参数为setInterval的返回值（可以用变量接收一下） 延迟定时器当方法执行完成定时器停止(但是定时器还在,只不过没用了); var tmid = window.setTimeout(“方法名或方法”, “延时”); window.clearTimeout(tmid); 获得窗口尺寸获取滚动条滚动距离scrollTop 网页被卷去的高 兼容问题： ie9+ window.pageOffset; 火狐和其它浏览器 doucument.documentElement.scrollTop 谷歌和没有声明 DTD\ document.body.scrollTop scrollTo(x,y) 把内容滚动到指定的坐标，一般只使用y值 兼容问题实在是太复杂了，因此封装为一个方法 1234567891011121314151617181920212223/** * 获取滚动的头部距离和左边距离 * scroll().top scroll().left * @returns &#123;*&#125; */function scroll() &#123; if(window.pageYOffset !== null)&#123; return &#123; top: window.pageYOffset, left: window.pageXOffset &#125; &#125;else if(document.compatMode === "CSS1Compat")&#123; // W3C return &#123; top: document.documentElement.scrollTop, left: document.documentElement.scrollLeft &#125; &#125; return &#123; top: document.body.scrollTop, left: document.body.scrollLeft &#125;&#125; 获取可视区域的宽高client clientWidth clientHeight 网页的可见区域宽高 document.body.clientWidth clientLeft clientTop 返回的是元素边框的Boderwidth 如果不指定边框，返回0 获取网页的可视区域 兼容处理 12345678910111213141516171819202122/** * 获取屏幕的宽度和高度 * @returns &#123;*&#125; */function client() &#123; if(window.innerWidth)&#123; // ie9+ 最新的浏览器 return &#123; width: window.innerWidth, height: window.innerHeight &#125; &#125;else if(document.compatMode === "CSS1Compat")&#123; // W3C return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125; &#125; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125;&#125; onresize当窗口或框架的大小发生改变的时候会被调用 调用：window.onresize=function(){} 结合获得网页的宽高使用 获取自身的宽高和位置offsetWidth和offsetHeight 获取对象自身的宽度和高度，包括内容，边框，内边距 offsetLeft和offsetTop 距离第一个有定位的父级盒子的左边和上边的距离。可以追踪到body 从父元素的内padding开始计算，到子元素的border外 offsetParent 获得当前有定位的父元素 offsetXXX和style.XXX的区别 a) style.left只能获取行内的，而offsetLeft则可以获取到所有的；b) offsetLeft 可以返回没有定位盒子距离左侧的位置；而style.left不可以，其只能返回有定位盒子的left;c) offsetLeft 返回的是数字，而 style.left 返回的是字符串，除了数字外还带有单位：px; 注意：可以用parseInt进行转化；比如：styleLeft=’300px’ —-&gt; parseInt(styleLft) —-&gt; 300d) offsetLeft是只读的，而style.left是可读写；e) 如果没有给 当前 元素指定过 top 样式，则 style.top 返回的是空字符串。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 继承]]></title>
    <url>%2F2021%2F06%2F29%2FJava%20%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[类、超类和子类定义子类在java中所有继承都是共有继承。 12public class Manager extends Employee｛｝ 关键字 extends 表明正在构造的新类派生于一个已存在的类。 已存在的类称为超类 ( superclass)、 基类（base class) 或父类（parent class); 新类称为子类（subclass)、 派生类 (derived class) 或孩子（child class)。 前缀“ 超” 和“ 子” 来源于计算机科学和数学理论中的集合语言的术语。所有雇 员组成的集合包含所有经理组成的集合。可以这样说， 雇员集合是经理集合的超集， 也 可以说，经理集合是雇员集合的子集。 覆盖方法超类Employee的有一个私有域salary，子类Manager有一个私有域bonus，超类和子类都有一个同名方法getSalary()。Employee的薪水只有薪水，Manager的薪水是薪水+奖金。那么子类Manager的薪水为： 123public double getSalary()&#123; return salary+bouns;//错误&#125; 因为 Manager 类的 getSalary() 方法不能够直接地访问超类的私有域。 只有 Employee 类的方法才能够访问私有部 分。如果 Manager 类的方法一定要访问私有域， 就必须借助于公有的接口， Employee类中的 公有方法 getSalary 正是这样一个接口。 现在，再试一下。将对 salary 域的访问替换成调用超类的getSalary方法： 123public double getSalary()&#123; return super.getSalaty()+bouns;//正确&#125; 有些人认为 super 与 this 引用是类似的概念， 实际上，这样比较并不太恰当。这是 因为 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编 译器调用超类方法的特殊关键字。 在子类中可以增加域、 增加方法或覆盖超类的方法，然而绝对 不能删除继承的任何域和方法。 子类构造器给Manager提供一个构造器: 1234public Manager(String name, double salary, int year, int month, int day) &#123; super(name, salary, year, month, day); bonus = 0; &#125; 这里的关键字 super 具有不同的含义。语句 super(n, s, year, month, day); 是“ 调用超类 Employee 中含有 n、s、year month 和 day 参数的构造器” 的简写形式。 由于 Manager 类的构造器不能访问 Employee 类的私有域， 所以必须利用 Employee 类 的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用。使用 super 调用构造器的语句必须是子类构造器的第一条语句。 如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数) 的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类 的其他构造器 ，则 Java 编译器将报告错误。 回忆一下， 关键字 this 有两个用途： 一是引用隐式参数，二是调用该类其他的构造器 ， 同样，super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。 在调用构造器的时候， 这两个关键字的使用方式很相似。调用构造器的语句只能作为另一个构造器的第一条语句出现。构造参数既可以传递给本类（this) 的其他构造器，也可以传递给超类（super) 的构造器。 123Manager boss = new Manager("Carl Cracker", 80000，1987, 12, 15);Emplyee e = boss;//父类指向子类对象e.getSalary();//调用子类的方法 当e引用 Employee 对象时，e.getSalary( ) 调用的是 Employee 类中的 getSalary 方法；当 e 引用 Manager 对象时，e.getSalary( ) 调用的是 Manager类中的 getSalary 方法。虚拟机知道 e 实际引用的对象类型，因此能够正确地调用相应的方法。 一个对象变量（例如， 变量 e) 可以指示多种实际类型的现象被称为多态（polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding)。 多态有一个用来判断是否应该设计为继承关系的简单规则， 这就是“ is-a” 规则，它表明子类的每个对象也是超类的对象。例如，每个经理都是雇员。 因此，将 Manager 类设计为 Employee 类的子类是显而易见的，反之不然，并不是每一名雇员都是经理。 “is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以 用子类对象置换。 123Employee e; e = new Employee(. . .); // Employee object expected e =new Manager(. . .); // OK, Manager can be used as well 在 Java程序设计语言中，对象变量是多态的。 一个 Employee 变量既可以引用一个 Employee 类对象， 也可以引用一个 Employee 类的任何一个子类的对象。 然而，不能将一个超类的引用赋给子类变量。例如，下面的赋值是非法的 Manager m = new Employee(); // Error 原因很清楚：不是所有的雇员都是经理。 如果赋值成功，m 有可能引用了一个不是经理的 Employee 对象， 当在后面调用 m.setBonus(…) 时就有可能发生运行时错误。 理解方法调用弄清楚如何在对象上应用方法调用非常重要。下面假设要调用 x.f(args)，隐式参数 x声 明为类 C 的一个对象。下面是调用过程的详细描述： 1 ) 编译器査看对象的声明类型和方法名。假设调用 x.f(param)，且隐式参数 x声明为 C 类的对象。需要注意的是有可能存在多个名字为 f, 但参数类型不一样的方法。。编译器将会一一列举所有 C 类中名为 f 的方法和其超类中 访问属性为 public 且名为 f 的方法（超类的私有方法不可访问） 。 至此， 编译器已获得所有可能被调用的候选方法。 2 ) 接下来，编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在 一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析（overloading resolution)。 由于允许类型转换（int 可以转换成double, Manager 可以转换成 Employee, 等等)， 所以这 个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后 有多个方法与之匹配， 就会报告一个错误。 至此， 编译器已获得需要调用的方法名字和参数类型。 前面曾经说过，方法的名字和参数列表称为方法的签名。例如，f(int) 和 f(String) 是两个具有相同名字， 不同签名的方法。如果在子类中定义了一个与超类签名相同的方法， 那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。 不过，返回类型不是签名的一部分， 因此，在覆盖方法时， 一定要保证返回类型 的兼容性。 允许子类将覆盖方法的返回类型定义为原返回类型的子类型或者相同。 3 ) 如果是 private 方法、 static 方法、final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（static binding)。与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。在我们列举的示例中， 编译器采用动态绑定的方式生成一条调用 f (String) 的指令。 4 ) 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。假设 x 的实际类型是 D，它是C类的子类。如果 D类定义了 方法 f(String)，就直接调用它；否则，将在 D类的超类中寻找 f(String)， 以此类推。 每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个 方法表（method table), 其中列出了所有方法的签名和实际调用的方法。这样一来，在真正 调用方法的时候， 虚拟机仅查找这个表就行了。 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类方法是 public, 子类方法一定要声明为 public。经常会发生这类错误：在声明子类方法的时 候， 遗漏了 public 修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。 阻止继承：final 类和方法有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。 123public final class Executive extends Manager&#123; ...&#125; 类中的特定方法也可以被声明为 final。如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动成为final 方法，但不包括域，final域是构造后不可改变值）。 强制类型转换正像有时候需要将浮点型数值转换成整型数值一样，有时候也可能需要将某个类的对象 引用转换成另外一个类的对象引用。对象引用的转换语法与数值表达式的类型转换类似， 仅 需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。 12Employee e = new Manager();//子类对象声明为父类类型后，可强制转型Manager boss = (Manager) e;//下转型 进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。 比如我们让boss访问Manager新增的变量和方法。(e 是不能访问 Manager 新增的方法和变量的) 将一个值存入变量时， 编译器将检查是否允许该操作。将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量， 必须进行类型转换， 这样 才能够通过运行时的检査。 如果试图在继承链上进行向下的类型转换，并且“ 谎报” 有关对象包含的内容， Java运行时系统将报告这个错误，并产生一个 ClassCastException 异常。 12Emplyee e = new Employee();//根本没有子类的事情Manager boss = (Manager) e;//错误 应该养成这样一个良好的程序设计习惯： 在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用 instanceof操作符(A instanceof B A是B的实例或子类？)就可以实现。 例如： 123if(e instanceof Manager)&#123; boss = (Manager) e;&#125; 实际上，通过类型转换调整对象的类型并不是一种好的做法。在我们列举的示例中， 大 多数情况并不需要将 Employee 对象转换成 Manager 对象， 两个类的对象都能够正确地调用 getSalary方法，这是因为实现多态性的动态绑定机制能够自动地找到相应的方法。 只有在使用 Manager 中特有的方法时才需要进行类型转换， 例如， setBonus 方法 如果 鉴于某种原因，发现需要通过 Employee 对象调用 setBonus方法， 那么就应该检查一下超类 的设计是否合理。重新设计一下超类，并添加 setBonus法才是正确的选择。请记住，只要 没有捕获 ClassCastException异常，程序就会终止执行。 在一般情况下，应该尽量少用类型转换和 instanceof 运算符。 多态与继承及instanceof的一个例子1234567891011121314151617181920212223242526272829303132333435class Animal&#123;//父类 public void eat() &#123; System.out.println("animal eat"); &#125; public void eatAnimal() &#123; System.out.println("animal eatAnimal"); &#125;&#125;class Cat extends Animal&#123;//子类 public void eat() &#123; System.out.println("cat eat"); &#125; public void eatFish() &#123; System.out.println("cat eatFish"); &#125;&#125;public class DT &#123;public static void main(String[] args) &#123; Ainmal a = new Cat(); Cat b = new Cat(); a.eat();//cat eat Cat子类重写了eat方法，调用子类的方法,是多态 ((Cat)a).eatFish();//cat eatFish 直接a.eatFish会报错，需要强制类型转换，Animal类没有eatFish方法 a.eatAnimal();//animal eatAnimal Animal类里的eatAnimal方法被调用 b.eatFish();//cat Fish Cat类的eatFish方法被调用 b.eatAnimal();//animal eatAnimal Cat类继承的eatAnimal方法被调用 //instanceof Animal c = new Animal(); System.out.println(a instanceof Animal);//true System.out.println(a instanceof Cat);//true System.out.println(b instanceof Animal);//true System.out.println(c instanceof Cat); //false&#125;&#125; 抽象类使用 abstract 关键字，这样就完全不需要实现这个方法。 1public abstract String getDescription()&#123;&#125; 为了提高程序的清晰度， 包含一个或多个抽象方法的类本身必须被声明为抽象的。 1public abstract class Test&#123;&#125; 抽象类可以包含普通方法。 抽象方法充当着占位的角色， 它们的具体实现在子类中。扩展抽象类可以有两种选择。 一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽 象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。 类即使不含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化。 受保护访问然而，在有些时候，人们希望超类中的某些方法允许被子类访问， 或允许子类的方法访 问超类的某个域。为此， 需要将这些方法或域声明为 protected。 下面归纳一下 Java 用于控制可见性的 4 个访问修饰符： 1 ) 仅对本类可见 private。 2 ) 对所有类可见 public。 3 ) 对本包和所有子类可见 protected。 4 ) 对本包可见 默认， 不需要修饰符。 Object： 所有类的超类Object 类是 Java 中所有类的始祖。 在 Java 中每个类都是由它扩展而来的。但是并不需 要这样写： 1public class Test extends Object&#123;&#125; 如果没有明确地指出超类，Object 就被认为是这个类的超类。 在 Java 中，只有基本类型（primitive types) 不是对象， 例如，数值、 字符和布尔类型的 值都不是对象。 所有的数组类塱，不管是对象数组还是基本类型的数组都扩展了 Object 类。 equals 方法Object 类中的 equals方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用， 它们一定是相等的。不过我们一般比较值是否相同，所以一般需要重写该方法。 下面给出编写一个完美的 equals方法的建议： 1 ) 显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。 2 ) 检测 this 与 otherObject 是否引用同一个对象： if (this = otherObject) return true; 这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一 个一个地比较类中的域所付出的代价小得多。 3 ) 检测 otherObject 是否为 null, 如果为 null, 返 回 false。这项检测是很必要的。 if (otherObject = null) return false; 4 ) 比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变（父类与子类比较），就使用 getClass 检测： if (getClass() != otherObject.getCIassO) return false; 如果所有的子类都拥有统一的语义（对象统一），就使用 instanceof检测： if (!(otherObject instanceof ClassName)) return false; 5 ) 将 otherObject 转换为相应的类类型变量： ClassName other = (ClassName) otherObject 6 ) 现在开始对所有需要比较的域进行比较了。使用 == 比较基本类型域，使用 equals 比 较对象域。如果所有的域都匹配， 就返回 true; 否则返 回 false。 如果在子类中重新定义 equals, 就要在其中包含调用super.equals(other)。 hashCode 方法散列码（ hash code) 是由对象导出的一个整型值。散列码是没有规律的。如果 x 和 y 是 两个不同的对象， x.hashCode( ) 与 y.hashCode( ) 基本上不会相同。 如果重新定义 equals方法，就必须重新定义 hashCode方法， 以便用户可以将对象插人到散列表中（第一行比较this==otherObject）。 需要组合多个散列值时，可以调用 ObjeCtS.hash 并提供多个参数。这 个方法会对各个参数调用 Objects.hashCode， 并组合这些散列值。 123public int hashCode()&#123; return Object.hash(name,salary,hireDay);&#125; Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必 须与 y.hashCode( ) 具有相同的值。 toString 方法在 Object 中还有一个重要的方法， 就是 toString方法， 它用于返回表示对象值的字符 串。 绝大多数（但不是全部）的 toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。 123public String toString()&#123; return getClass().getName()+"[name="+name+",salary"=salary+"]";&#125; 最好通过调用getClass( ).getName( ) 获得类名的字符串,而不要将类名硬加到toString()方法中。 Object 类定义了 toString方法， 用来打印输出对象所属的类名和散列码。 泛型数组列表ArrayList 是一个采用类型参数（type parameter) 的泛型类（generic class)。为了指定数 组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面， 例如，ArrayList \。 下面声明和构造一个保存 Employee 对象的数组列表： ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;; 两边都使用类型参数 Employee， 这有些繁琐。Java SE 7中， 可以省去右边的类型参数： ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;； 使用add 方法可以将元素添加到数组列表中。 如果已经清楚或能够估计出数组可能存储的元素数量， 就可以在填充数组之前调用 ensureCapacity方法： staff.ensureCapacity(lOO); 另外，还可以把初始容量传递给 ArrayList 构造器： ArrayList&lt;Employee&gt; staff = new ArrayList(100); size方法将返回数组列表中包含的实际元素数目。 一旦能够确认数组列表的大小不再发生变化，就可以调用 trimToSize方法。这个方法将 存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储 空间。 一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确 认不会添加任何元素时， 再调用 trimToSize。 访问数组列表元素 使用 get 和 set 方法实现访问或改变数组元素的操作，而不使用人们喜爱的 [ ]语法格式。 只有 i 小于或等于数组列表的大小时， 才能够调用 list.set(i, x)。 使用 add 方法为数组添加新元素， 而不要使用 set 方法， 它只能替换数组中已经存在 的元素内容。 使用下列格式获得数组列表的元素: Employee e = staff.get(i); 对象包装器与自动装箱有时， 需要将 int 这样的基本类型转换为对象。所有的基本类型都冇一个与之对应的类。 例如Integer 类对应基本类型 int。通常， 这些类称为包装器 （ wrapper) 这些对象包装器类 拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character、Void 和 Boolean (前 6 个类派生于公共的超类 Number)。对象包装器类是不可变的，即一旦构造了包装器，就不 允许更改包装在其中的值。同时， 对象包装器类还是 final, 因此不能定义它们的子类。 假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说， 不允许写成 ArrayList\。这里就用到了 Integer 对象包装器类。我们可以声明一个 Integer 对象的数组列表。 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;() 由于每个值分别包装在对象中， 所以 ArrayList\ 的效率远远低于 int[ ] 数组。 因此， 应该用它构造小型集合，其原因是此时程序员操作的方便性要比执行效率更加重要。 幸运的是， 有一个很有用的特性，从而更加便于添加 int类型的元素到 ArrayLisKlntegeP 中。下面这个调用 list.add(3) 将会自动转变为： list.add(Integer.Valueof(3)) 这种变换被称为自动装箱（autoboxing)。 相反地， 当将一个 Integer 对象赋给一个 int 值时， 将会自动地拆箱。也就是说， 编译器将下列语句： int n = list. get(i); 翻译成 int n = list.get(i).intValue(); 大多数情况下，容易有一种假象， 即基本类型与它们的对象包装器是一样的，只是它们 的相等性不同。大家知道， == 运算符也可以应用于对象包装器对象， 只不过检测的是对象是 否指向同一个存储区域， 因此，下面的比较通常不会成立： 123Integer a = 1000; Integer b = 1000; if (a = b) ... 然而，Java 实现却有可能（may) 让它成立。如果将经常出现的值包装到同一个对象中， 这种比较就有可能成立。这种不确定的结果并不是我们所希望的。解决这个问题的办法是在 两个包装器对象比较时调用 equals方法。 自动装箱规范要求 boolean、byte、char&lt;=127， 介于 -128 ~ 127 之间的 short 和 int 被包装到固定的对象中。例如，如果在前面的例子中将 a 和 b 初始化为 100，对它们进行比较的结果一定成立。 有些人认为包装器类可以用来实现修改数值参数的方法， 然而这是错误的。由于 Java 方法都是值传递， 所以不可能编写一个下面这样的能够增加 整型参数值的 Java 方法: 123public static void triple(int x) // won't work &#123; x = 3 * x; // modifies local variable &#125; 将 int 替换成 Integer : 123public static void triple(Integer x) // won't work&#123; x = 3 *x;&#125; 问题是 Integer 对象是不可变的： 包含在包装器中的内容不会改变: 不能使用这些包 装器类创建修改数值参数的方法。 如果想编写一个修改数值参数值的方法， 就需要使用在 org.omg.CORBA 包中定义的 持有者（ holder) 类型， 包括 IntHolder、BooleanHolder 等。每个持有者类型都包含’一个 公有（！）域值，通过它可以访问存储在其中的值。 123public static void triple(IntHolder x) &#123; x.value = 3 * x.value; &#125; 参数数量可变的方法在 Java SE 5.0 以前的版本中，每个 Java方法都有固定数量的参数。然而，现在的版本 提供了可以用可变的参数数量调用的方（有时称为“ 变参” 方法)。 123456public static double max(double... values) &#123; double largest = Double.NECATIVEJNFINITY; for (double v : values) if (v &gt; largest) largest = v; return largest; &#125; 这里的省略号 . . . 是 Java 代码的一部分，它表明这个方法可以接收任意数量的double 类型，存放在values[]数组中。 可以像下面这样调用这个方法： double m = max(3.1 , 40.4, -5); 编译器将 new double[ ] {3.1, 40.4,-5} 传递给 max方法。 枚举类在定义枚举类型时我们使用的关键字是enum，与class关键字类似，： public enum Size { SMALL, MEDIUM, LARGE, EXTRAJARGE }; 实际上， 这个声明定义的类型是一个类， 它刚好有 4 个实例， 在此尽量不要构造新对象。 因此， 在比较两个枚举类型的值时， 永远不需要调用 equals, 而直接使用“ = =” 就 可以了。 定义一个枚举类： 123456789101112enum Size&#123; SMAll("s",1),MEDIUM("M",2);//会调用第5行的构造函数，补充信息 private String desc; private int id; private Size(String desc,int id) &#123;//构造函数 this.desc=desc; this.id = id; &#125; public String getDesc() &#123;//通过Size.SMAll.getDesc()调用，获得信息 return desc+" "+id; &#125;&#125; 所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。其中最有用的一 个是 toString， 这个方法能够返回枚举常量名。例如， Size.SMALL.toString( ) 将返回字符串 “ SMALL”。 反射能够分析类能力的程序称为反射（reflective)。 反射机制可以用来： •在运行时分析类的能力。 •在运行时查看对象， 例如， 编写一个 toString方法供所有类使用。 •实现通用的数组操作代码。 •利用 Method 对象， 这个对象很像中的函数指针。 Class 类在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。 这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。 在java语言中，万事万物皆对象，但是静态成员不是对象（静态成员属于类），普通数据类型不是对象。 类也是对象，类是java.lang.Class 类的实例对象。 这个对象称为类类型（class type） 三种实例化Class的实例对象的方法1、可以通过专门的 Java 类访问这些信息。保存这些信息的类被称为 Class, 这个名 字很容易让人混淆。Object 类中的 getClass( ) 方法将会返回一个 Class 类型的实例。 123Manage m = new Manager();Class c = m.getClass();syso(c.getName());//输出 class 包名.Manager; 2、还可以调用静态方法 forName(String classname) 获得类名对应的 Class 对象。 classname 要带上包名。 1Class c1 = Class.forName(c.getName()); 如果类名保存在字符串中，并可在运行中改变， 就可以使用这个方法。当然， 这个方法 只有在 classname 是类名或接口名时才能够执行。否则，forName 方法将抛出一个 checked exception (已检查异常） 。无论何时使用这个方法， 都应该提供一个异常处理器（exception handler)。 3、第三种方法时通过T.class 获得Class类型，例如： 123Class cl1 = Random.class;//引入Random包-》class 是隐形的静态成员变量Class cl2 = int.class;Class cl3 = Double[].class; 请注意，一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如， int 不是类，但 int.class 是一个 Class 类型的对象。 虚拟机为每个类型管理一个 Class 对象。因此， 可以利用==运算符实现两个类对象比较的操作。 1if(m.getClass()==Manager.class) 一个类只可能是Class 类的一个实例对象。 通过类类型创建对象有一个很有用的方法 newlnstance( )， 可以用来动态地创建一个类的实例： 1m.getClass0.newlnstance(); 创建了一个与 e具有相同类类型的实例。newlnstance方法调用默认的构造器（没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。 将 forName 与 newlnstance 配合起来使用， 可以根据存储在字符串中的类名创建一个对象 。 利用反射分析类的能力在java.lang.reflect 包中有三个类 Field、Method 和 Constructor 分别用于描述类的域、 方法和构造器。（域是Field类的对象，方法是Method的对象，构造器是Constructor的对象）。 例子，Method类获得类的方法。 123Class e = Manager.class;Method m = e.getMethods();syso(m[0]);//获得Manager类的一个方法名字 想获得类的其它信息同理，查阅API手册。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术卷1读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 对象 与 类]]></title>
    <url>%2F2021%2F06%2F29%2FJava%20%E5%AF%B9%E8%B1%A1%20%E4%B8%8E%20%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类类（class) 是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的切割机，将对 象想象为小甜饼。由类构造（construct) 对象的过程称为创建类的实例 （instance). 封装（encapsulation, 有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看， 封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。对象 中的数据称为实例域（ instance field), 操纵数据的过程称为方法（method )。对于每个特定的 类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state)。 无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。 实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对 象的方法与对象数据进行交互。封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性 的关键。 对 象要想使用 OOP, —定要清楚对象的三个主要特性： •对象的行为（behavior)— —可以对对象施加哪些操作，或可以对对象施加哪些方法？ •对象的状态（state)— —当施加那些方法时，对象如何响应？ •对象标识（identity)— —如何辨别具有相同行为与状态的不同对象？ 使用预定义类对象与对象变量要想使用对象，就必须首先构造对象， 并指定其初始状态。然后，对对象应用方法。 在 Java 程序设计语言中， 使用构造器（constructor) 构造新实例。构造器是一种特殊的方法， 用来构造并初始化对象。 在对象与对象变量之间存在着一个重要的区别。例如， 语句 Date deadline; // deadline doesn’t refer to any object 定义了一个对象变量 deadline, 它可以引用 Date 类型的对象。但是，一定要认识到： 变量 deadline 不是一个对象， 实际上也没有引用对象。此时，不能将任何 Date 方法应用于这个变 量上。 语句 s = deadline.toString(); // not yet 将产生编译错误。 必须首先初始化变量 deadline, 这里有两个选择。当然，可以用新构造的对象初始化这 个变量： deadline = new Date(); 也让这个变量引用一个已存在的对象： deadline = birthday; 现在，这两个变量引用同一个对象 一定要认识到： 一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new 操作 符的返回值也是一个引用。 只 访 问 对 象 而 不 修 改 对 象 的 方 法 有 时 称 为 访 问 器 方 法 Java 类库中的 LocalDate 类类库设计者决定将保存时间与给时间点命名分开。所以标准 Java 类库分别包含了两个类：一个是用来表示时间点的 Date 类；另一个是用来表示大家熟悉的日历表示法的 LocalDate 类。 用 LocalDate 类打印一个日历： 123456789101112131415161718192021222324252627public class Calendar &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub LocalDate now = LocalDate.now();//当前时间 System.out.println("Mon\tTue\tWed\tThu\tFri\tSat\tSun"); int month = now.getMonthValue(); LocalDate temp = now.minusDays(now.getDayOfMonth()-1);//本月第一天 //本月第一天对应的星期几 int nowMonthFristWeek = temp.getDayOfWeek().getValue(); //本月第一天前都是空格 for(int i = 1; i &lt; nowMonthFristWeek; i++) &#123; System.out.print("\t"); &#125; //输出日历主体部分-&gt;只要在本月就打印 while(temp.getMonthValue()==month) &#123; if(temp.getDayOfMonth()==now.getDayOfMonth()) &#123; System.out.printf("%d*\t",temp.getDayOfMonth()); &#125;else &#123; System.out.printf("%d\t",temp.getDayOfMonth()); &#125; if(temp.getDayOfWeek().getValue()==7) &#123; System.out.println(); &#125; temp = temp.plusDays(1); &#125; &#125;&#125; final 实例域final 修饰符大都应用于基本（primitive) 类型域，或不可变（immutable) 类的域（如果类 中的每个方法都不会改变其对象， 这种类就是不可变的类。例如，String类就是一个不可变 的类)。 1private final String name;//这个值不会被修改。即没有setName方法 setName()方法比把name设置为public的好处是可以在setName()中添加对name限定条件。 对于可变的类， 使用 final 修饰符可能会对读者造成混乱。例如： private final StringBuiIcier evaluations;在 构造器中会初始化为 evaluations = new StringBuilder(); final 关键字只是表示存储在 evaluations 变量中的对象引用不会再指示其他 StringBuilder 对象。不过这个对象可以更改： 静态域与静态方法静态域如果将域定义为 static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域 却都有自己的一份拷贝。 1234class Employee &#123; private static int nextld = 1 ;private int id;&#125; 现在， 每一个雇员对象都有一个自己的 id 域， 但这个类的所有实例将共享一个 nextId 域。换句话说， 如果有 1000 个 Employee类的对象， 则有 1000 个实例域 id。但是，只有一 个静态域 nextld。即使没有一个雇员对象， 静态域 nextld 也存在。它属于类，而不属于任何 独立的对象。 静态常量 在 Math类中定义了一个 静态常量： 123public class Hath &#123;public static final double PI=3.14159265358979323846;&#125; 在程序中，可以采用 Math.PI 的形式获得这个常量。 如果关键字 static 被省略， PI 就变成了 Math 类的一个实例域。需要通过 Math类的对象 访问 PI，并且每一个 Math 对象都有它自己的一份 PI 拷贝。 静态方法静态方法是一种不能向对象实施操作的方法。例如， Math的 pow 方法就是一静态方法。表达式 Math.pow(x, a) 计算幂x^a。在运算时，不使用任何Math对象。换句话说，没有隐式参数。 可以认为静态方法是没有this参数的方法。 静态方法不能访问对象的实例域，可以访问自身类的静态域。 在下面两种情况下使用静态方法： •一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如:Math.pow) •一个方法只需要访问类的静态域 工厂方法静态方法还有另外一种常见的用途。类似 LocalDate 和 NumberFormat 的类使用静态工厂方法 (factory method） 来构造对象。 12345NumberFormat currencyFormatter = NumberFormat.getCurrencylnstance(); NumberFormat percentFormatter = NumberFormat.getPercentlnstance()； double x = 0.1 ; System.out.println(currencyFormatter.format(x)); // prints SO.10 System.out.println(percentFomatter.format(x)); // prints 10% 为什么 NumberFormat 类不利用构造器完成这些操作呢？ 这主要有两个原因： •无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例 和百分比实例采用不用的名字。 •当使用构造器时，无法改变所构造的对象类型。而 Factory方法将返回一个 DecimalFormat 类对象，这是 NumberFormat 的子类。 main 方法main方法是一个静态方法。 main方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的 main方法将执行并创建程序所需要的对象。 每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。 如果想单独测试某个类，则执行： java 测试类名 如果A类有main方法且是一个更大应用程序B类的一部分，就可以使用： java B 这样A类的main方法就会被忽略。 对象构造重载如果多个方法（比如， StringBuilder 构造器方法）有相同的名字、不同的参数，便产生了重载。 不能有两个名字相同、 参数类型也相 同却返回不同类型值的方法。 默认域初始化如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、 布尔值为 false、 对象引用为null。 这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量。 但是， 如果没有初始化类中的域， 将会被自动初始化为默认值（0、false 或 null)。 无参数的构造器很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时， 其状态会设置为 适当的默认值。 12345public Employee0 &#123; name =""; salary = 0; hireDay = LocalDate,now(); &#125; 如果希望所有域被赋予默认值， 可以采用下列格式： 1public ClassName()&#123;&#125; 显示域初始化可以在类定义中， 直接将一个值赋给任何域。例如： 123class Employee&#123; private String name = "";&#125; 在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某 个特定的实例域时，这种方式特别有用。 调用另一个构造器关键字 this 引用方法的隐式参数。然而，这个关键字还有另外一个含义。 如果构造器的第一个语句形如 this(…)， 这个构造器将调用同一个类的另一个构造器。下 面是一个典型的例子： 1234public Employee(double s) &#123; // calls Employee(String, double) this("Employee #" + nextld, s); nextld++; &#125; 当调用 new Employee(60000) 时， Employee(double) 构造器将调用 Employee(String，double) 构造器。 初始化块前面已经讲过两种初始化数据域的方法： •在构造器中设置值 •在声明中赋值 实际上，Java 还有第三种机制， 称为初始化块（initialization block)。在一个类的声明中， 可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如： 12345678public Employee&#123; private static int nextId; private int id; &#123; id=nextId; nextId++; &#125;&#125; 在这个示例中，无论使用哪个构造器构造对象，id 域都在对象初始化块中被初始化。首 先运行初始化块，然后才运行构造器的主体部分。 下面是调 用构造器的具体处理步骤： 1 ) 所有数据域被初始化为默认值（0、false 或 null)。 2 ) 按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块。3 ) 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体 4 ) 执行这个构造器的主体. 如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。 将代码放在一个块中，并标记关键字 static。 123static&#123; //...&#125; 在类第一次加载的时候， 将会进行静态域的初始化。 对象析构与 finalize 方法有些面向对象的程序设计语言，特别是 C++, 有显式的析构器方法，其中放置一些当对 象不再使用时需要执行的清理代码。在析构器中， 最常见的操作是回收分配给对象的存储空 间。由于 Java 有自动的垃圾回收器，不需要人工回收内存， 所以 Java 不支持析构器。 当然，某些对象使用了内存之外的其他资源， 例如，文件或使用了系统资源的另一个对 象的句柄。在这种情况下，当资源不再需要时， 将其回收和再利用将显得十分重要。 可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。 在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为很难知道这个 方法什么时候才能够调用。 如果某个资源需要在使用完毕后立刻被关闭， 那么就需要由人工来管理。对象用完时， 可以应用一个 close方法来完成相应的清理操作。 包Java 允许使用包（package）将类组织起来。借助于包可以方便地组织自己的代码，并将 自己的代码与别人提供的代码库分开管理。 使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了 Employee 类。只要将这些类放置在不同的包中， 就不会产生冲突。事实上，为了保证包名的绝对 唯一性， Sun 公司建议将公司的因特网域名（这显然是独一无二的）以逆序的形式作为包 名，并且对于不同的项目使用不同的子包。 从编译器的角度来看， 嵌套的包之间没有任何关系。例如，java.util 包与java.util.jar 包 毫无关系。每一个都拥有独立的类集合。 类的导入 一个类可以使用所属包中的所有类， 以及其他包中的公有类（public class)。(一个包可以有很多公有类（.java 文件）)我们可以 采用两种方式访问另一个包中的公有类。第一种方式是在每个类名之前添加完整的包名。 例如： java.time.LocalDate today = java.time.LocalDate.now(); 这显然很繁琐。更简单且更常用的方式是使用 import 语句。import 语句是一种引用包含 在包中的类的简明描述。一旦使用了 import 语句，在使用类时，就不必写出包的全名了。 java.time.* 的语法比较简单，对代码的大小也没有任何负面影响。当然， 如果能够明确地指出所导的类， 将会使代码的读者更加准确地知道加载了哪些类。 但是， 需要注意的是， 只能使用星号（) 导入一个包， 而不能使用 import java.\ 或 import java.*.*导入以 java 为前缀的所有包。 要想使用Entry类，必须import java.util.Map.Entry 只有import java.util.*是不可以的,.是代表导入该文件夹下的所有*类，而java.util跟java.util.Map 不是同一个文件夹。 从编译器的角度来看， 嵌套的包之间没有任何关系。 在大多数情况下， 只导入所需的包， 并不必过多地理睬它们。但在发生命名冲突的时 候，就不能不注意包的名字了。例如，java.util 和java.sql 包都有日期（ Date) 类。如果在程 序中导入了这两个包。 在程序使用 Date 类的时候， 就会出现一个编译错误。 此时编译器无法确定程序使用的是哪一个 Date 类。可以采用增加一个特定的 import 语句来 解决这个问题： 123import java.util.*;import java.sql.*;import java.util.Date; 如果这两个 Date 类都需要使用，又该怎么办呢？ 答案是，在每个类名的前面加上完整的包名。 静态导入 import 语句不仅可以导入类，还增加了导入静态方法和静态域的功能。 例如，如果在源文件的顶部， 添加一条指令： import static java.lang.System.*; 就可以使用 System类的静态方法和静态域，而不必加类名前缀： out.println(&quot;Goodbye, World!&quot;); //i.e., System.out 将类放入包中要想将一个类放人包中， 就必须将包的名字放在源文件的开头，包中定义类的代码之前。 package ... 如果没有在源文件中放置 package语句， 这个源文件中的类就被放置在一个默认包 ( default package) 中。默认包是一个没有名字的包。 将包中的文件放到与完整的包名匹配的子目录中。例如，com.horstmann.corejava 包 中的所有源文件应该被放置在子目录 com/horstmann/corejava中。编译器将类文件也放在相同的目录结构中。 类路径 类文件也可以存储在JAR(Java归档）文件中。在一个 JAR 文件中， 可以包含 多个压缩形式的类文件和子目录， 这样既可以节省又可以改善性能。 JAR 文件使用 ZIP 格式组织文件和子目录。可以使用所有 ZIP 实用程序查看内部 的 rt.jar 以及其他的 JAR 文件。 为了使类能够被多个程序共享，需要做到下面几点： 1 ) 把类放到一个目录中， 例如 /home/user/classdir。需要注意， 这个目录是包树状结构 的基目录。如果希望将 com.horstmann.corejava.Employee类添加到其中，这个 Employee.class 类文件就必须位于子目录 /home/user/classdir/com/horstmann/corejava中。 2 ) 将 JAR 文件放在一个目录中，例如：/home/user/archives。 3) 设置类路径（class path)。类路径是所有包含类文件的路径的集合。 在UNIX 环境中， 类路径中的不同项目之间采用冒号（:）分隔： /home/user/classdir:.:/home/user/archives/archive.jar 而在 Windows 环境中，则以分号（;）分隔： c:\classdir;.;c:\archives\archive.jar 类路径包括： •基目录/home/user/classdir(类UNIX环境) 或 c:\classdir(Windows环境)； •当前目录 (.)； •JAR 文件 /home/user/archives/archive.jar或c:\archives\archive.jar 由于运行时库文件（rt.jar 和在jre/lib 与jre/lib/ext 目录下的一些其他的 JAR 文件）会被 自动地搜索， 所以不必将它们显式地列在类路径中。 类路径所列出的目录和归档文件是搜寻类的起始点。下面看一个类路径示例： /home/user/classdir:.:/home/user/archives/archive.jar 假定虚拟机要搜寻 com.horstmann.corejava.Employee 类文件。它首先要查看存储在jre/ lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。显然，在那里找不到相应的类文 件，然后再查看类路径。然后查找以下文件： /home/user/classdir/com/horstmann/corejava/Employee.class com/horstmann/corejava/Employee.class 从当前目录开始 com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar 仅可以导人其他包中的公有类。当然，也可以从当前包中导入非公有类。（非共有类默认访问权限为friend，当前包可以访问） 综上所述，class path 拼接上 import 的路径就代表要寻找的类的绝对路径。 文档注释JDK 包含一个很有用的工具，叫做javadoc, 它可以由源文件生成一个 HTML 文档。 如果在源代码中添加以专用的定界符 /**开始的注释， 那么可以很容易地生成一个看上 去具有专业水准的文档。这是一种很好的方式，因为这种方式可以将代码与注释保存在一个地方。在修改源代码的同时， 重新运行javadoc 就可以轻而易举地保持两者的一致性。 注释的插入每个 /* . . . / 文档注释在标记之后紧跟着自由格式文本（free-form text)。标记由@开 始， 如@author 或@param。 自由格式文本的第一句应该是一个概要性的句子。javadoc 实用程序自动地将这些句子抽 取出来形成概要页。 在自由格式文本中，可以使用 HTML 修饰符， 例如，用于强调的 \…\、 用于 着重强调的 \…\ 以及包含图像的 \ 等。不过，一定不要使用 \ 或 \, 因为它们会与文档的格式产生冲突。 若要键入等宽代码，需要使用{@code…}而不是\…\ ，因为这样不同担心代码中的’&lt;‘字符转义。（比如代码中有&lt;或者&gt;就要进行转义，防止javadoc识别成html标签，而{@code}就没有这个问题） 类注释类注释必须放在 import 语句之后，类定义之前。 生成的文档默认不显示出来比如 @author XXX 。如果显示的话需要额外在添加参数 例子： 12345678/** * 这是注释 * &lt;em&gt;作者&lt;/em&gt; * @author XXXX -&gt;//这个默认不显示 */public class Test&#123; &#125; 方法注释每一个方法注释必须放在所描述的方法之前。除了通用标记之外， 还可以使用下面的标记： @param 变量描述 这个标记将对当前方法的“ param” （参数）部分添加一个条目。这个描述可以占据多 行， 并可以使用 HTML 标记。一个方法的所有@param 标记必须放在一起。 @return 描述 这个标记将对当前方法添加“ return” （返回）部分。这个描述可以跨越多行， 并可以 使用 HTML 标记。 @throws 类描述 这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。 域注释只需要对公有域（通常指的是静态常量）建立文档。 1234/*** 这是一个静态变量*/public static int flag = 1; 通用注释下面的注释有一些不显示在javadoc生成的文档中。 可以用在类文档的注释： @author 姓名 产生一个（作者）条目 @version 文本 产生一个（版本）条目 可以用在所有文档中的注释中： @since 文本 产生一个（始于）条目。这里的文本可以是引入特性的版本的描述 @since version 1.7.1 @deprecated 文本 对类或方法，变量添加一个不在使用的注释，提出取代建议。如：@deprecated Use {@code setVisible(true)} instead 通过@see 和 @link 链接到文档相关部分或外部。 @see 增加一个超链接，可以用于类也可以用于方法中。引用可选择： package.class#feature label \label\ “text” 第一种情况是最常见的。只要提供类、方法或变量的名字，javadoc 就在文档中插入 一个超链接。例如， @see com.horstraann.corejava.Employee#raiseSalary(double) 建立一个链接到 com.horstmann.corejava.Employee 类的 raiseSalary(double) 方法的超 链接。 可以省略包名， 甚至把包名和类名都省去，此时，链接将定位于当前包或当前类。 需要注意，一定要使用井号（#)，而不要使用句号（.）分隔类名与方法名，或类 名与变量名。Java 编译器本身可以熟练地断定句点在分隔包、 子包、类、内部类与方 法和变量时的不同含义。但是javadoc 实用程序就没有这么聪明了，因此必须对它提 供帮助。 如果@see 标记后面有一个双引号（”）字符，文本就会显示在 “ 另请参阅” 部分。 包与概述注释可以直接将类、方法和变量的注释放置在 Java 源文件中，只要用 / . . . */ 文档注释界 定就可以了。但是， 要想产生包注释**，就需要在每一个包目录中添加一个单独的文件。可以 有如下两个选择： 1 ) 提供一个以 package.html 命名的 HTML 文件。在标记 \—\ 之间的所有 文本都会被抽取出来。 2 ) 提供一个以 package-info.java命名的 Java 文件。这个文件必须包含一个初始的以 /* 和 / 界定的 Javadoc 注释， 跟随在一个包语句之后。它不应该包含更多的代码或注释。 还可以为所有的源文件提供一个概述性的注释。这个注释将被放置在一个名为 overview, html 的文件中，这个文件位于包含所有源文件的父目录中。标记 \... \ 2间的所 有文本将被抽取出来。当用户从导航栏中选择“ Overview” 时，就会显示出这些注释内容。 注释的抽取这里，假设 HTML 文件将被存放在目录 docDirectory 下。执行以下步骤： 1 ) 切换到包含想要生成文档的源文件目录。如果有嵌套的包要生成文档， 例如 com. horstmann.corejava, 就必须切换到包含子目录 com 的目录（如果存在 overview.html 文件的 话， 这也是它的所在目录)。 2 ) 如果是一个包，应该运行命令: javadoc -d docDirectory nameOfPackage 或对于多个包生成文档，运行: javadoc -d docDirectory nameOfPackage1 nameOfPackage2... 如果文件在默认包中，运行： javadoc -d docDirectory *.java 如果省略了 -d docDirectory 选项， 那 HTML 文件就会被提取到当前目录下。这样有可能 会带来混乱，因此不提倡这种做法。 可以使用多种形式的命令行选项对javadoc 程序进行调整。例如， 可以使用-author 和 -version选项在文档中包含@author 和@version标记（默认情况下，这些标记会被省 略)。另一个很有用的选项是-link, 用来为标准类添加超链接。例如， 如果使用命令 javadoc -link http://docs.oracle.eom/:javase/8/docs/api *.java 那么，所有的标准类库类都会自动地链接到 Oracle 网站的文档。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java核心技术卷1读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2021%2F06%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言 函数形参理解]]></title>
    <url>%2F2021%2F06%2F29%2FC%E8%AF%AD%E8%A8%80%20%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[C语言中的形参只有传值，传址本质上也是传值，只不过传的是地址，我们可以通过访问地址的方式进行修改原来的值。 比如 123456789void add(int a)&#123; a++;&#125;int main()&#123; int a=5; add(a); printf("%d", a);//a=5而不是6&#125; 而我们可以通过传指针的方式在add中访问main中的a，去修改main中a的值 123456789void add(int *a)&#123; (*a)++;&#125;int main()&#123; int a=5; add(&amp;a); printf("%d", a);//a=6&#125; 上面的例子比较简单，下面这个是最近做题遇到的问题，困扰了我很久。 这个问题大概内容就是在链表把重复元素删除掉，只保留一个 我的思路就是先用一个指针固定一个元素，然后在用一个指针往后遍历，遇见和固定到的一样就删除掉就行了 12345678910111213141516171819202122232425262728293031323334353637383940void LocateElem(LinkList head, int k,LinkList p)&#123; LinkList q,m; m=p; q=p; p=p-&gt;next; while(p!=NULL)&#123; if(p-&gt;data==k)&#123; ListDelete(q,p); &#125; else&#123; q=p; p=p-&gt;next; &#125; &#125; p=m; &#125;void ListDelete(LinkList q,LinkList p)&#123; q-&gt;next=p-&gt;next; free(p); p=q-&gt;next;&#125;int main()&#123; int n,m; LinkList head, p; scanf("%d", &amp;m); while(m--)&#123; scanf("%d", &amp;n); head=InitList(n);//构造长度为n的线性表并返回 p=head-&gt;next; while(p!=NULL)&#123; LocateElem(head,p-&gt;data,p); p=p-&gt;next; &#125; ShowLnode(head);//展示线性表 &#125; return 0;&#125; LocateElem的作用是遍历链表，而ListDelete删除某个节点，看样子并没有问题，我传的是一个指针，应该可以删除吧，但其实这个程序运行不起来，而把LocateElem中的ListDelete(q,p)中替换为 123q-&gt;next=p-&gt;next;free(p);p=q-&gt;next; 就可以了，这是为什么呢？ 其原因就出现在了ListDelete中的p=q-&gt;next; 这个p是ListDelete中的p，并不是LocateElem中的p，虽然说p的指向是一样的（也就是说*p是一样的，试着输出p-&gt;data看一看）但它们两个不是一个变量！ 这就充分的证明了C语言形参只传值，变量要再拷贝一份的 下面这个例子还能加深理解一下。 1234567891011121314151617181920212223242526272829303132333435363738394041typedef struct &#123; int data[100001]; int length;&#125;SqList;//二分查找int midsearch(SqList *list, int k, int l, int r )&#123; int mid; mid=(l+r)/2; if(l&gt;r)&#123; return -1; &#125; else if(k==list-&gt;data[mid])&#123; return mid; &#125; else if(k&lt;list-&gt;data[mid])&#123; return midsearch(list,k,0,mid-1);//不用取地址了，已经是main中list的地址了，如过还取地址，那就成Sqlist**类型了，取了一个Sqlist指针的指针 &#125; else &#123; return midsearch(list,k,mid+1,r); &#125;&#125;int main()&#123; SqList list; int n, t, k, m; scanf("%d", &amp;n); initList(&amp;list,n);//构造线性表 scanf("%d", &amp;t); while(t--)&#123; scanf("%d", &amp;k);//查找值为k的元素，并返回位置 m=midsearch(&amp;list, k,0,(list.length)-1);//在主函数里要取地址 if(m!=-1)&#123; printf("%d", m+1); &#125;else&#123; printf("No Found!"); &#125; printf("\n"); &#125; return 0;&#125; 接下来分析如何解决在链表删除元素的问题 其实也就是把ListDelete中的p地址可以传到LocateElem中，把p,q想成单纯的变量，不要思考它是指针， 12345ListDelete(Linklist *q, Linklist *p)&#123; (*q)-&gt;next=(*p)-&gt;next;//(*p)就是LocateElem中的p了，**p就是main中的p了 free(*p); *p=*(q)-&gt;next;&#125; 调用ListDelete(&amp;q,&amp;p);就可以了， 其实上面LocateElem中还有一个地方需要修改，那就是m，我m的本意是保存p的地址，好在主函数里用，但是LocateElem中的p根本和main中的p没有关系，所以m就没用了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 背包问题]]></title>
    <url>%2F2021%2F06%2F29%2F01%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题 序号 重量 价值 1 2 3 2 3 4 3 4 5 4 5 8 5 9 10 有5件物品和一个容量为20的背包。求解可以装入背包的最大价值是多少。 状态转移方程定义一个数B(k,w)代表当前背包装载的最大价值,其中 k:前k件物品（不一定把前k件物品都拿进背包） w:背包剩下的空间 比如B(5,20)代表背包里装了前5件物品，且背包空间为20的情况下所得到背包里物品的最大值，也就是问题所需要求的数。 需要说明的是，B(0,x) x可以代表任意的背包空间，0代表拿了0件物品，所以不管背包空间有多大，B(0,x)恒等于0 由于该问题是个动态规划的问题，我们要想知道拿k件物品的情况，就必须知道拿k-1件物品时的情况。 我现在了拿了前k-1件物品（背包价值B(k-1,w)），在拿第k件物品时（想要求B(k,w’)会出现下列2种情况 第k件物品太重了，超过了当前背包剩余空间w(wk&gt;w)，那么这第k件物品不能拿，所以此时的B(k,w‘)=B(k-1,w)，相当于什么都没做就过渡到了B(k,w’)。 第k件物品可以装入背包，问题又出现了，我们是装入还是不装呢？装入占空间，有可能就把当前背包的某些物品给挤出去了，所以此时就要比较装入和不装入后背包价值的大小了。 如果装入第k件物品，B(k,w‘)=B(k-1,w-wk)+value(k)，也就是说我在拿了第前k-1件物品时，背包价值为B(k-1,w),我把第k件物品装入了背包，那么此时的背包剩余的空间要减去第k件物品的重量，也就是w’=w-wk,同时价值要增加第k件物品的价值，即最后+value(k)。 如果不装入第k件物品，那么情况就相当于超重的情况（反正都是不装），此时B(k,w’)=B(k-1,w) 我们要求出max(装入第k件物品的背包价值，不装入第k件物品的价值)，使其等于B(k,w),即： B(k,w)=max(B(k-1,w-wk)+value(k),B(k-1,w)) 这就是该问题的状态转移方程 二维数组表示计算过程 代码表示1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int dp[6][21]; int w[6]=&#123;0,2,3,4,5,9&#125;;//重量 int v[6]=&#123;0,3,4,5,8,10&#125;;//价值 memset(dp,0,sizeof(dp)); int k,c; for(k=1;k&lt;6;k++)&#123;//遍历物品 for(c=1;c&lt;21;c++)&#123;//遍历重量 if(w[k]&gt;c)&#123;//如果物品重量太大，装不下 dp[k][c]=dp[k-1][c];//等于没装之前的重量 &#125;else&#123;//能装下--&gt; 判断装下去合不合适（装下去可能会拿出一些东西 int value1=dp[k-1][c-w[k]]+v[k]; int value2=dp[k-1][c]; if(value1&gt;value2)&#123; dp[k][c]=value1; &#125;else&#123; dp[k][c]=value2; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[5][20]; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css笔记]]></title>
    <url>%2F2018%2F07%2F19%2Fcss%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CSS是用来干什么的？CSS全名叫Cascading Style Sheets，中文翻译为“层叠样式表”，简称样式表，它是一种制作网页的新技术。HTML文件就只包括资料，而CSS则是告诉浏览器这些资料应该要如何显现出来。打个比方，HTML是房子的框架，而CSS就是室内室外的装潢。css让网页变得好看。 如何在HTML中引入？（1）外联式(推荐) 通过&lt;link&gt;标记来引入外部的CSS文件(.css)。 可以被其它网页共享。 格式：&lt;link href=“CSS的URL” rel=“stylesheet” type=“text/css” /&gt; 注意：&lt;link&gt;标记只能放在&lt;head&gt;中 （2）内嵌式 通过&lt;style&gt;&lt;/style&gt;来书写CSS代码。 只能应用于当前网页，不能被其它网页共享。 注意：&lt;style&gt;标记可以放在网页的任何地方，但一般放在&lt;head&gt;。 （3）行内样式 通过style的属性来书写CSS代码。 每一个HTML元素，都有 style、class、id、name、title 属性。 举例：&lt;p style=“font-size:24px;”&gt;&lt;/p&gt; 关于外联式路径(url)补充： 绝对路径：从是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。 比如：D:\前端学习\H5+CSS3视频\CSS3 相对路径（推荐）：由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。 比如一个目录结构： 1234567文件夹/├── index.html/├── img/│ ├── img1.img/│ ├── img2.img/└── css/ └── main.css/ 你的html文档是index.html，你想要引入main.css,路径为：css/main.css (/相当于进入) 你的CSS文件时main.css，你想要引入一个背景图片img1.img(后面会有专门的内容介绍背景的知识) 路径为：../img/img1.img (.. 相当于上一级) 基础语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 1选择器 &#123;声明1; 声明2; 声明3 &#125; 选择器选择器就是选中html中的元素，方便对其的样式进行修改 比较常用的有 类选择器、ID选择器、结构（位置）伪类选择器、并集选择器、后代选择器，子元素选择器 标签选择器标签选择器是指用HTML标签名作为选择器的，按标签名进行分类。 1标签名 ｛样式;&#125; 标签选择器最大的优点是快速为页面中同类型的标签统一样式，但是不能进行差异化设计。 类选择器使用 .类名 表示 1.类名｛样式;｝ 标签调用是通过 class=”类名” 来调用 多类名选择器 我们可以给标签指定多个类名，从而达到给多选择的目的。 1&lt;p class="类名1 类名2"&gt;&lt;/p&gt; 121. 样式的显示效果与HTML中的类名先后顺序无关，受CSS样式的书写上下顺序影响2. 各个类名中间用空格隔开 ID选择器id选择器使用 # 进行标识 ，后面紧跟id名 1#id名｛样式;&#125; 通配符选择器用 * 号进行标识。他是所有选择器中作用范围最广的，能匹配页面中的所有元素 通常用来清除元素边距（不推荐，有专门的Normalize.css可以用来统一跨浏览器样式） 1234*&#123; margin: 0px; padding: 0px;&#125; 伪类选择器伪类选择器通常用于向某些选择器添加特殊效果。 选择器 伪类选择器 链接伪类选择器 :link 未访问的链接 :visited 以访问的链接 : hover 鼠标移动到链接上 : active 选定链接 通常与a标签选择器匹配使用 全部书写的时候顺序不要颠倒。可以单独书写。 结构（位置）伪类选择器（CSS3) :first-child 选取属于器父元素的首个子元素 :last-child 选取其父元素的最后一个子元素 :nth-child(n) 匹配属于其父元素的第N个子元素，n值可以为 even 偶数 odd 奇数 n从0开始开始，因此可以是公式，比如3n选中3的倍数，也可以是确定的数字。 :nth-last-chilf(n) 从最后一个子元素开始记数，匹配第N个元素 选择中的子元素是考虑元素类型的， ”0选取其父元素“相当于选择自己的兄弟元素 目标伪类选择器:target 选择器用于选取当前活动的目标元素 一般与锚点定位结合使用 CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的组合方式而成的。 交集选择器交集选择器由两个选择器构成，第一个为标签选择器，第二个为类选择器，两个选择器中间不能有空格。 1h1.class&#123;样式;&#125; 并集选择器多个选择器中间用逗号分开（一般换行），所有选择器都会执行后面的样式。 123p,class,id&#123;样式;&#125; 后代选择器后代选择器又称包含选择器，用来选择元素或元素组的后代。 写法：把外层标签写在前面，内层标签写在后面，中间用空格分隔 1class p&#123;样式;&#125; 子元素选择器子元素选择器只能选择某父元素的子元素，其写法就是把父级标签，子级标签写在后面，中间用 &gt; 连接，符号左后各留有一个空格 1.class &gt; p &#123;样式;&#125; 子元素选择器只能选择其亲儿子。不包括孙子等。 属性选择器 选择器 含义 E[xxx] 存在xxx属性 E[xxx=val] 属性值完全等于val E[xxx*=val] 属性值中包含val字符，并可以在任何位置 E[xxx^=val] 属性值中包含val字符，并在开始的位置 E[xxx$=val] 属性值中包含val字符，并在结束的位置 E为选择器 xxx为属性值 可以选中拥有该含义的内容 伪元素选择器之所以被称为伪元素，是因为他们不是真正的页面元素，HTML中没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的CSS样式，表面上看上去貌似是页面的某些元素展现，实际上是CSS样式展现的行为，因此被称为伪元素 E为选择器 E::first-letter 文本的第一个单词或字 E::first-line 文本中的第一行（受页面大小的影响） E::selection 改变选中文本时的样式 E::before 与 E::after 必须有content属性 在E元素内部的开始或结束位置创建一个元素，该元素为行内元素。并且不占位置 E:after与E:before 在旧版本里是伪元素，CSS3中”:”用来表示伪类，”::”用来表示伪元素，但是在高版本下E:after与E:before 会被自动识别为E::after 与 E::before 布局盒子模型盒子模型是html+css中最核心的基础知识，理解了这个重要的概念才能更好的排版，进行页面布局。 要把整个页面中的元素理解成一个一个盒子（div） 基础概念CSS盒子模型 又称框模型 (Box Model) ，包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。如图： 盒子模型顾名思义，你可以将其理解成一个盒子，element的width和height就是物品的大小，padding就是物品距边框的距离，border就是边框的大小，margin就是这个盒子与另外一个盒子的距离 盒子外边距（margin）margin用于设计外边距，设置外边距会在元素之间创建空白。 外边距实现盒子居中可以让一个盒子实现水平居中，需要满足：1必须是块级元素 2盒子必须指定了宽度 然后给盒子左右外边距设置 auto 就可以使盒子居中 margin:0 auto; 注意：行内元素只有左右外边距，没有上下外边距 外边距的合并相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象称为相邻块状元素外边距的合并（也称为外边距塌陷）。 嵌套块元素垂直外边距的合并对两个嵌套关系的块元素，如果父元素没有上内边距级边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后外边距为两者的较大者，即使父元素的上外边距为0，也会发生合并。 解决方案：1 可以为父元素定义1像素的上边框或上内边距， 2 可以为父元素添加overflow:hidden。 盒子边框（border)语法： border：border-width||border-style||border-color 边框样式要先有边框的宽度和颜色 12345none：没有边框样式 （默认值）solid: 边框为单实线dashed: 边框为虚线dotted: 边框为点线double: 边框为双实线 可以单独为盒子的一个边框设置样式 表格的细线边框border-collapse:collapse 合并相邻的边框 圆角边框（CSS3）border-radius: 左上角 右上角 右下角 左下角； 值 描述 测试 length 定义圆角的形状。 测试 % 以百分比定义圆角的形状。 测试 盒子内边距（padding）padding用于设计内边距，指边框与内容之间的距离 值的个数 表达意思 1个值 上下左右的边距 2个值 padding:3px 5px; 上下3像素 左右5像素 3个值 padding:3px 5px 10px;上3像素 左右5像素 下10像素 4个值 padding:上 右 下 左 也可以单独为某一方向设置边距 content宽度和高度使用宽度属性width和高度属性可以对盒子的大小进行控制。 注意： 1 宽度属性width和高度属性height仅使用与块级元素，对行内元素无效（img和input除外） 2 计算盒子总高度时要考虑上下两个盒子的垂直外边距合并的情况 3 如果一个盒子没有给定宽度或者高度或者继承父亲的宽度和高度，则padding不会影响盒子的大小 如果已经给一个盒子指定了宽高，再使用padding会把盒子撑开，定义盒子内容宽高时因考虑这个问题 盒子的大小box-sizing (CSS3)用来修正给盒子增加padding和boder后改变了盒子的大小的问题 content-box 默认值，宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 也就是说padding和margin会在content外添加。盒子大小=widith+padding+border border-box 为元素设定的宽度和高度决定了元素的边框盒。 就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。 通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 盒子的大小不会超过content规定的宽和高。盒子大小=widith 盒子模型布局的稳定性优先使用 宽度 width 其次 内边距 padding 最后 外边距 margin 原因：1 margin会有外边距合并问题，其次ie6下margin会加倍（bug) 2 padding 会影响盒子的大小，需要进行加减运算 3 width 没有问题，可以使用宽度剩余法或者高度剩余法 宽度剩余法和高度剩余法：利用盒子内容的宽高将其撑开 文档流介绍文档流之前，先介绍元素的三种显示模式 元素的显示模式块级元素(block-level)每个块元素通常都会独自占据一行或多整行，可以对其设置宽度、高度、对齐等属性(依然独自占据一行或多行）。 常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素 块级元素的特点： 1 总是从新行开始 2 高度，行高，外边距、内边距都可以控制 3 宽度默认是容器的100% 4 可以容纳内联元素和其他块级元素 行内元素(inline-level)行内元素（内联元素）不占有独立的区域，仅仅依靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中的文本样式。 常见的行内元素有&lt;a&gt; &lt;stong&gt; &lt;b&gt; &lt;em&gt; &lt;i&gt; &lt;del&gt; &lt;s&gt; &lt;ins&gt; &lt;u&gt; &lt;span&gt;等，其中&lt;span&gt;是最典型的行内元素。 行内元素的特点： 1 和相邻的行内元素在一行上。 2 高宽无效、但水平方向的padding和margin可以设置，垂直方向无效。 3 默认宽度就是它本身的宽度。（不能指定） 4 行内元素之内容纳文本或其它行内元素（a除外） 注意： 1 只用文字才能组成段落，因此p里面不能放块级元素，同理还有标题标签等，他们都是文字类块级标签，里面不能放其它块级元素。 2 链接里面不能放链接 行内块元素(inline-block)在行内元素中有几个特殊的标签——&lt;img&gt; &lt;input&gt; &lt;td&gt; ，可以对它们设置宽高和对齐属性，有些资料称他们为行内块元素。 行内块元素的特点：1 和相邻行内元素（行内块）在一行上，但是之间会有空隙 2 默认宽度是它本身内容的宽度 3 高度、行高、外边距、以及内边距都可以控制 模式的转换 displaydispaly: inline 块转行内 display: block 行内转块 display: inline-block 行、内转换为行内块 概念普通流或者标准流、文档流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 定位定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。显然，这个功能非常强大，也很让人吃惊。要知道，用户代理对 CSS2 中定位的支持远胜于对其它方面的支持，对此不应感到奇怪。 所以关键的找对相对于谁进行定位。 静态定位（static） position的默认值，默认在文本流的位置。 一般用来清除定位。 相对定位（relative）相对于自身进行定位 1、相对定位时本身不脱离文本流。 2、每次移动是以自己的左上角为基点。 相对定位的的盒子仍在标准流里，它后面的盒子仍以标准流的方式对待它。 绝对定位（absolute）绝对定位是完全脱离标准流的。 绝对定位是以依据最近已经定位（绝对、相对、固定）的父元素（祖先）进行定位的。如果祖先元素没有定位，会以body进行定。 使用技巧:子绝父相，保证父亲占有位置不影响下面的元素，还能保证子元素有定位的对象，以及飘在父元素的上方。 绝对定位实现居中加了absolute的盒子margin：0 auto；会失效。 左右居中： 1、首先left:50%(父盒子宽度的一半) 2、margin-left：自己的宽度一半（负值） 3、transfrom: translate(-50%) 可以不用知道元素的宽度 这个属性在动画里讲 上下居中同理。 固定定位（fixed）固定定位只认浏览器 相对于浏览器（视窗）进行定位 叠加顺序定位元素一定会覆盖没有定位的元素 z-index 1、默认值为0，取值越大，定位元素越居上。 2、只有绝对，相对，固定定位有此属性，其余标准流、浮动、静态定位都无此属性。 定位转换绝对定位、固定定位后会转换为行内块元素。 可以不用转化，直接给宽高。 浮动(float)浮动刚开始的时候是用来做文字环绕图片的。 现在主要用于让多个盒子在同一行显示。 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准流的控制，移动到器父元素指定位置的过程。 选择器{float:属性值;} 属性值 描述 left 向左浮动 right 向右浮动 none 元素不浮动（默认值） 浮动元素的特性浮动是脱离标准流的，不占位置，会影响标准流，浮动只有左右浮动。 浮动首先创建包含块的概念（包裹）。就是说浮动的元素总是找离它最近的父元素对齐。但是不会超过内边距的范围。 浮动的使用方法 给两个黑色的盒子增加浮动，必须要有父盒子（黄色）将其包裹，防止因黑盒子浮动脱离文本流，蓝盒子上移被遮挡。 浮动首先需要添加标准流父级 元素添加浮动后，元素会具有行内块元素的特性，元素的大小完全取决于定义的大小或者默认内容 清除浮动原因由于浮动元素不再占用原文档流的位置，会对后面的元素排版产生影响，所以我们要清除浮动后产生的影响。 清楚浮动本质主要是为了父级元素因为子集浮动引起内部高度为0的问题。 如果父元素没有设置高度，会由子元素撑起来，但当子元素浮动后，脱离了文本流，就会引起父元素的高度为0的问题 解决方法再CSS中，clear属性用于清除浮动，其基本值有： 属性值 描述 right 不允许右侧有浮动元素 left 不允许左侧有浮动元素 both 同时清除两侧的浮动影响 把浮动的盒子圈到里面，让父元素闭合出口，让其不能影响外部元素。 额外标签在子元素最后增加一个盒子清除浮动。 1234567891011&lt;style&gt; .clear&#123; clear:both; &#125;&lt;/style&gt;&lt;div class="box"&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt; &lt;/div&gt;&lt;div class="ex"&gt;&lt;/div&gt; 父级元素增加overflow1234567891011&lt;style&gt; .box&#123; overflow:hidden; &#125;&lt;/style&gt;&lt;div class="box"&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt; &lt;/div&gt;&lt;div class="ex"&gt;&lt;/div&gt; 缺点：内容增多时容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 使用after伪元素清除浮动1234567891011121314.clearfix:after&#123; content:".";/*防止就浏览器有空隙*/ display:block; height:0; clear:both; visibility:hidden;/*隐藏盒子*/&#125;.clearfix&#123; *zoom:1;/*兼容IE6、7*/&#125;&lt;div class="box1 clearfix"&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;div class="son1"&gt;&lt;/div&gt; &lt;/div&gt; 与增加盒子法原理一样 使用双伪元素清除浮动1234567891011.clearfix:before,clearfix::after&#123; content: ""; display: table; &#125;.clearfix:after&#123; clear:both;&#125;.clearfix&#123; *zoom:1;/*兼容IE6、7*/&#125; flex布局来源：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 grid布局来源：http://www.css88.com/archives/8506 Grid 布局是网站设计的基础，CSS Grid 是创建网格布局最强大和最简单的工具。 CSS Grid 今年也获得了主流浏览器（Safari，Chrome，Firefox，Edge）的原生支持，所以我相信所有的前端开发人员都必须在不久的将来学习这项技术。 在本文中，我将尽可能快速地介绍CSS网格的基本知识。我会把你不应该关心的一切都忽略掉了，只是为了让你了解最基础的知识。 你的第一个 Grid 布局CSS Grid 布局由两个核心组成部分是 wrapper（父元素）和 items（子元素）。 wrapper 是实际的 grid(网格)，items 是 grid(网格) 内的内容。 下面是一个 wrapper 元素，内部包含6个 items ： 123456789HTML 代码:&lt;div class="wrapper"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把 wrapper 元素变成一个 grid(网格)，只要简单地把其 display 属性设置为 grid 即可： 123CSS 代码:.wrapper &#123; display: grid;&#125; 但是，这还没有做任何事情，因为我们没有定义我们希望的 grid(网格) 是怎样的。它会简单地将6个 div 堆叠在一起。 我已经添加了一些样式，但是这与 CSS Grid 没有任何关系。 Columns(列) 和 rows(行)为了使其成为二维的网格容器，我们需要定义列和行。让我们创建3列和2行。我们将使用grid-template-row和grid-template-column属性。 1234CSS 代码:.wrapper &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 50px 50px;&#125; 正如你所看到的，我们为 grid-template-columns 写入了 3 个值，这样我们就会得到 3 列。 我们想要得到 2 行，因此我们为 grid-template-rows 指定了2个值。 这些值决定了我们希望我们的列有多宽（ 100px ），以及我们希望行数是多高（ 50px ）。 结果如下： 为了确保你能正确理解这些值与网格外观之间的关系，请看一下这个例子。 12345CSS 代码:.wrapper &#123; display: grid; grid-template-columns: 200px 50px 100px; grid-template-rows: 100px 30px;&#125; 请尝试理解上面的代码，思考一下以上代码会产生怎样的布局。 这是上面代码的布局的结果： 非常好理解，使用起来也非常简单是不是？下面我们来加大一点难度。 放置 items(子元素)接下来你需要学习的是如何在 grid(网格) 上放置 items(子元素) 。特别注意，这里才是体现 Grid 布局超能力的地方，因为它使得创建布局变得非常简单。 我们使用与之前相同的 HTML 标记，为了帮助我们更好的理解，我们在每个 items(子元素) 加上了单独的 class ： 123456789HTML 代码:&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;item1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item4&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;item5&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;item6&quot;&gt;6&lt;/div&gt;&lt;/div&gt; 现在，我们来创建一个 3×3 的 grid(网格)： 1234CSS 代码:.wrapper &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 将得到以下布局： 不知道你发现没有，我们只在页面上看到 3×2 的 grid(网格)，而我们定义的是 3×3 的 grid(网格)。这是因为我们只有 6 个 items(子元素) 来填满这个网格。如果我们再加3个 items(子元素)，那么最后一行也会被填满。 要定位和调整 items(子元素) 大小，我们将使用 grid-column 和 grid-row 属性来设置： 1234CSS 代码:.item1 &#123; grid-column-start: 1; grid-column-end: 4;&#125; 我们在这里要做的是，我们希望 item1 占据从第一条网格线开始，到第四条网格线结束。换句话说，它将独立占据整行。 以下是在屏幕上显示的内容： 如果你不明白我们设置的只有 3 列，为什么有4条网格线呢？看看下面这个图像，我画了黑色的列网格线： 请注意，我们现在正在使用网格中的所有行。当我们把第一个 items(子元素) 占据整个第一行时，它把剩下的 items(子元素) 都推到了下一行。 最后，给你一个更简单的缩写方法来编写上面的语法： 123CSS 代码:.item1 &#123; grid-column: 1 / 4;&#125; 为了确保你已经正确理解了这个概念，我们重新排列其他的 items(子元素) 。 12345678910CSS 代码:.item1 &#123; grid-column-start: 1; grid-column-end: 3;&#125;.item3 &#123; grid-row-start: 2; grid-row-end: 4;&#125;.item4 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 你可以尝试在你的脑子里过一边上面代码的布局效果，应该不会很难。 以下是页面上的布局效果： Grid 布局就是这么简单，当然这里展示的是最简单的 Grid 布局概念，但是 Grid 布局系统中还有更多强大灵活的特性。作为本文续篇，请阅读 如何使用 CSS Grid 快速而又灵活的布局 让你体会 Grid 布局真正的强大和灵活。在此之前建议阅读请CSS Grid 布局完全指南(图解 Grid 详细教程)，首先了解一下 Grid 相关的术语和所有属性。 常用样式字体font-size 字体大小font-size属性用于设置字号，该属性可以使用相对长度单位，也可以使用绝对长度单位，常用px。 font-family 字体font-family用于设置字体，网页中常用的字体有宋体、微软雅黑、黑体等。 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体,则会尝试下一个字体。 12中文字体需要加英文状态下的引号，英文字体一半不需要加引号，当设置英文字体时，英文字体必须位于中文字体名之前如果字体名中包含空格，#，$等符号，则该字体必须加英文状态下的单引号或双引号，列如：font-family:&quot;Time New Roman&quot; CSS unicode简单来说，用编码表示字体。 防止因文件编码不匹配产生乱码。 中文名 英文名 unicode unicode2 宋体 SimSun \5B8B\4F53 &amp;#x5B8B;&amp;#x4F53; 黑体 SimHei \9ED1\4F53 &amp;#x9ED1;&amp;#x4F53; 新宋体 NSimSun \65B0\5B8B\4F53 &amp;#x65B0;&amp;#x5B8B;&amp;#x4F53; 楷体 KaiTi \6977\4F53 &amp;#x6977;&amp;#x4F53; 微软正黑体 Microsoft JhengHei \5FAE\x8F6F\6B63\9ED1\4F53 &amp;#x5FAE;&amp;#x8F6F;&amp;#x6B63;&amp;#x9ED1;&amp;#x4F53; 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 &amp;#x5FAE;&amp;#x8F6F;&amp;#x96C5;&amp;#x9ED1; 参考资料：https://zhuyujia.github.io/css/css-font-unicode-table.html 字体强调font-weight 字体粗细字体加除了用b和strong标签外，可以用font-weight实现。 font-weight用于定义字体的粗细，其属性值可以为normal、bold、bloder、lighter、100~900（100的整数），其中400等价于 normal，700等价于bold font-style 字体风格字体倾斜除了用i和em外，可以用font-style实现。 其属性值有： normal 默认值，浏览器会显示标准的字体样式。 italic 斜体 oblique 倾斜 综合设定{font: font-style font-weihgt font-size/line-height font-family} 使用font属性时，必须按照以上顺序书写，不能更换顺序，各个属性之间一空格隔开。 其中不需要设置的属性可以忽略，但必须保留font-size和font-family属性 文字阴影（CSS3）text-shadow:水平位置 垂直位置 模糊距离 阴影颜色 1text-shadow: h-shadow v-shadow blur color; 注释：text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。省略的长度是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。参阅 CSS 颜色值。 参考资料：http://www.w3school.com.cn/cssref/pr_text-shadow.asp 背景CSS可以添加背景颜色和背景图片，以及来进行图片设计。 background-color 背景颜色 background-image 背景图片 background-repeat 是否平铺 background-position 背景位置 background-attachment 背景是固定还是滚动 背景的合写 background: 颜色 图片地址 背景平铺 背景滚动 背景位置 背景位置默认值 ： 左上角 123background-position:length||lengthbackground-position:position||positiion 参数： length：百分数 数字值 position：top、center、bottom、left、right 方位名词没有顺序 设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为（0% 0%） 如果只设定了一个值，该值将用于横坐标。纵坐标默认为50%。第二个值用于纵坐标。 注意： 1.postion 后面是x坐标和y坐标。可以使用方位名词或者精确单位。 2.如果精确单位和方位名词混合使用，必须是x坐标在前，y坐标在后面。 1background-postion:15px top; 背景附着1background-attachment:scroll||fixed; scroll: 背景图像是随内容滚动（默认值） fixed: 背景图像固定 背景透明使用rgba(0,0,0,透明度) 背景缩放background-size设置图片的尺寸 a、可以设置长度单位（px)或百分比（参照盒子的宽高） b、设置为cover时，会自动调整比例，保证图片填满背景区，如有溢出则会被隐藏。 c、设置为contain会自动调整比例，保证图片会完整的显示在背景区域（只要宽或高有一个达到了盒子的大小，则不会进行缩放,保证了图片完整） 多背景（CSS3）以逗号分隔可以设置多背景 一个元素可以设置多重背景图像 每组属性间用逗号隔开（定义属性的时候使用简写形式） 如果设置的多重背景图之间存在着交集（重叠关系），前面的背景图会覆盖在后面的背景图上 为了避免背景色将图像盖住，背景色通常为最后一组 12background:url(XXX.png) no-repeat scroll 10px 20px,url(YYY.png) no-repeat scroll left bottom; 显示与隐藏displaydisplay 设置检索对象如何显示。 dispay：none; 隐藏元素，隐藏之后，不在保留位置。 display：block；除了有转换为块级元素之外，还有显示元素的意思。 经常用于菜单。 visibiltyvisibilty:hidden;隐藏元素，并保留位置。 visibilty：visible; 显示元素。 overflow管理内容超出指定宽高时的做法。 值 说明 visible 默认值，超出显示 auto 自动，超出显示滚动条 scroll 一直显示滚动条（无论内容是否超出） hidden 超出部分隐藏 用户界面鼠标样式 cursor设置或检索在对象上移动鼠标指针采用何种系统预定义的光标形状。 cursor: default 小白(箭头）|pointer 小手|move 移动（十字标）|text 文本（光标） 轮廓 outline是绘制元素周围的一条线，位于边框的外围，可以起到突出元素的作用。 outline:outline-color||outline-style||outline-width (类似与border的设置) 我们平时都是去掉边框 写法为：outline:0; 1&lt;input type="text" style="outline:0"&gt; 防止拖拽文本域 resizeresize: none 防止用户随意拖拽文本域 1&lt;textarea style="resize:none;outline:0"&gt;&lt;/textarea&gt; 垂直对齐 vertical-alignvertical-align 不影响块级元素中的内容对齐，它只针对与行内元素或者行内块元素，特别是行内块元素，通常用来控制图片和表单文字的对齐。 vertical-align:baseline |top| middle| bottom 通常默认是基线对齐，比如： 12&lt;textarea name="" id="" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;p style="display:inline-block"&gt;文字文字文字文字&lt;/p&gt; 给文本域增加属性,使其与中线对齐 12&lt;textarea name="" id="" cols="30" rows="10" style="vertical-align:middle"&gt;&lt;/textarea&gt; &lt;p style="display:inline-block"&gt;文字文字文字文字&lt;/p&gt; 去除图片底侧空白间隙图片或者表单等行内块元素，它的底线会和父盒子的基线对齐，这样会造成图片底侧会有一个空白缝隙。 解决方案：1 将行内块元素转换块级元素， display:block; 2 给行内块元素添加 vertical-align:middle || top 等等， 让行内块元素不要和基线对齐。 溢出文字隐藏word-break 自动换行主要处理英语 normal 浏览器的默认换行规则 break-all 允许在单词内换行（任何时候,可以拆开单词） keep-all 只能在半角空格或连字符处换行（无法拆开单词，除非出现连字符“-”） white-space设置或检索对象内文本的显示方式，通常我们使用与强制一行显示内容 normal: 默认处理方式 nowrap: 强制在同一行显示所有文本，直到文本结束或者遭遇br标签 text-overflow 文字溢出text-overflow: clip||ellipsis 设置是否使用一个省略标记(…)表示对象文本的溢出 clip 不显示省略标记，而是简单的裁切 ellipsis 溢出时用省略号标记 注意使用条件 一定要首先强制一行内显示，再次和overflow属性搭配使用 123white-space: nowrap;/*首先添加这句话，强制不换行*/overflow: hidden;/*必须有这句话，溢出部分隐藏*/text-overflow: ellipsis; 字体图标图片是有诸多优点的，但是图片不能进行良好的“缩放”，因为图片的放大和缩小会失真，而且还增加了总文件的大小。但是字体图标可以改善这些缺点。 优点1234可以做出和图片一样的事情，改变透明度，旋转度，等但是本质是文字，可以改变颜色，产生阴影，透明效果等....体积小，但是所携带的信息没有消减几乎支持所有的浏览器 使用上传生成字体包当我们有.svg文件时，我们需要转换成我们页面能使用的字体文件，而且需要生成的是兼容性的适合各个浏览器的。 推荐网站：http://icomoon.io 阿里字库 http://www.icofont.cn/ icomoon的使用1 将font文件夹放到目录文件夹上 2 在样式中声明字体 在下载的文件夹中style文件中复制如下的代码放进css中 注意路径问题 比如： 12345678910@font-face &#123; font-family: 'icomoon'; src: url('fonts/icomoon.eot?1adt26'); src: url('fonts/icomoon.eot?1adt26#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?1adt26') format('truetype'), url('fonts/icomoon.woff?1adt26') format('woff'), url('fonts/icomoon.svg?1adt26#icomoon') format('svg'); font-weight: normal; font-style: normal;&#125; 3 增加span标签，并添加样式font-family: &quot;icomoon&quot; （要与上面声明的字体样式名字一样） 4 将demo中样式后面的小方格复制到span标签中 或增加样式span::before{content:&quot;\e906&quot;} (字体图标下面的代码) 追加新图标将压缩包中的selection.json从新上传，然后选中自己想要的新图标，从新下载压缩包，替换原来的文件即可。 动画过渡过渡三要素: 1 必须要有属性发生变化 2 必须告诉系统哪个属性发生了变化 transition-property 3 必须告诉系统过渡效果持续的时长 transition-duration 例如： 1234567891011121314.gd&#123; width: 300px; height: 200px; background-color: red; /* 告诉系统哪个属性需要执行过渡效果 */ transition-property: width,background-color; /* 告诉系统过渡效果所用的时间 */ transition-duration: 5s, 6s;&#125;/* 伪类选择器也可以用在不是a标签上，只是表示监听鼠标指向元素的事件 */.gd:hover&#123; width: 500px; background-color: blue;&#125; 其它的过渡属性： transition-delay 规定了过渡效果何时开始 transition-timing-function 规定了过渡的运动曲线 属性的连写： transition: property duration timing-function delay; transition: 过渡属性 过渡时长 运动时间函数 延迟 如果想给多个属性增加过渡效果用逗号隔开 连写的时候可以省略后两个参数 如果多个属性运动的速度/延迟的时间/持续的时间都一样，可以简写为： transition:all 0s; 如何编写过渡： 1 不要管过渡，先编写基本界面 2 修改我们认为需要修改的属性 3回过头去给被修改属性的那个元素添加过渡效果 2D转换通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。 基本属性 transformrotate() 方法通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 1234.d2 ul li:nth-child(2)&#123; /* 其中deg是单位，代表多少度 */ transform: rotate(45deg);&#125; translate() 方法通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数： 12345.d2 ul li:nth-child(3)&#123; /* 第一个参数:水平方向 第二个参数：垂直方向 */ transform: translate(100px, 50px);&#125; scale() 方法通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数： 123456789.d2 ul li:nth-child(4)&#123; /* 第一个参数:水平方向 第二个参数：垂直方向 如果取值为1， 代表不变 取值大于1 放大 取值小于1 缩小 如果水平和垂直的参数都一样，可以简写为一个参数*/ transform: scale(1.5,1.5);&#125; 如果需要进行多个转换，要用空格隔开 2D转化模块会修改元素的坐标系，所以旋转之后的平移就不是水平平移了 形变中心点默认情况下所有的元素都是以自己的中心点作为参考来旋转的，我们可以通过形变中心点属性来修改它的参考点 transform-origin：0px 0px; 第一个参数:水平方向 第二个参数:垂直方向 注意点: 取值有三种形式：具体像素 百分比 特殊关键字(left center top等) 旋转轴向默认情况下所有元素都是围绕Z轴进行旋转 Z轴的正方向为垂直屏幕向外 想围绕哪个轴旋转, 那么只需要在rotate后面加上哪个轴即可 比如rotateX(45deg) rotateY(-45deg) rotate Z(180deg) 透视：perspective: 500px; 呈现一种近大远小的效果,一般和旋转搭配使用 注意点:一定要注意, 透视属性必须添加到需要呈现近大远小效果的元素的父元素上面 注意过渡尽量:hover的元素和改变的元素是同一个，通过A:hover去控制B的也可以用CSS做，具体做法是：A是父级，B是子集，那么A:hover &gt;B{}就可以了（认为A:hover时找到B） AB同级时，A:hover ~B(A在HTML中在B的上面，认为A:hover时找到B) CSS 相邻兄弟选择器： + （A:hover +B) 选择紧接在另一个元素后的元素，而且二者有相同的父元素 ~ 在使用 ~ 连接两个元素时,它会匹配第二个元素,条件是它必须跟(不一定是紧跟)在第一个元素之后,且他们都有一个共同的父元素. 有一个过渡显示二级菜单的例子是通过:hover一级菜单的li去显示二级菜单的li的例子 代码：https://paste.ubuntu.com/p/84j55Xws62/ 3D转换关键： transform-style： preserve-3d //子元素将保留其 3D 位置 默认值为flat 即为2D转换 实例：画一个正方体 先画六个面，通过旋转和位移将面围成正方体，需要注意的是，当面进行旋转操作的时候，对于这个元素的坐标系会跟着一起旋转 具体可以看这个代码就明白了， https://paste.ubuntu.com/p/V6YwZp6HJV/ 动画过渡与动画的不同点： 过渡必须人为的触发才会执行 动画不需要人为的触发就可以执行动画 相同点： 过渡和动画都需要满足三要素 动画的用法：1 先告诉系统需要执行哪个动画 animation-name: lxx(随便给动画起个名称)； 2 告诉系统我们要创建一个名称为lxx的动画 12345678@keyframes lxx&#123; from&#123; 默认态&#125; to&#123; 结束状态&#125;&#125; 动画的过程也可以用%表示 1234567891011121314@keyframe lxx&#123; 0%&#123; &#125; 33%&#123; &#125; 66%&#123; &#125; 100%&#123; &#125;&#125; 3 告诉系统动画持续的时长 animation-duration:3s; 其它属性animation-iteration-count: 3; 动画需要执行几次 animation-direction：alternate;动画应该轮流反向播放 默认值：normal 动画不执行往返 animation-play-state: runing/paused 规定动画是否暂停（与hover联合使用） animation-fill-mode 值 描述 none 不改变默认行为。(恢复没有动画的状态) forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。 backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。（让动画在等待状态时显示第一帧的样子） both 向前和向后填充模式都被应用。（forward和backwards一起） 连写animation: name duration timing-function delay iteration-count direction;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
